/* ROOM */
const roomName = 'ðŸ†âš½ |Futsal 3v3| Pod Sraczem | âš½ðŸ†';
const maxPlayers = 18;
const roomPublic = true;
const token = "thr1.AAAAAGkmPLW9A4VNQs53SA.EtpFpTVdJfs"; // Insert token here

var roomWebhook = 'https://discord.com/api/webhooks/1417845044651626566/vZdV_vQDAU1n4dcwJnTWKUYYVQZExQrRd0HoC8gvXgQkIupqHfZplwt_ZtYRzVfsNxmT'; // Logi
var gameWebhook = 'https://discord.com/api/webhooks/1417844778112122973/eTZ_4hNdpMXgzUR68Brw9bQbyzhhptNj3oh-2SS8BPjQLlFmX5UPbzQqV4DaJgcxWjDx'; //  raporty meczow
// --- NOWE WEBHOOKI ---
// Webhook do listy graczy online (Status Roomu)
var statusWebhook = "https://discord.com/api/webhooks/1443065498756583560/p40RgjDs5NMNT1SstJh-8OskVES5BN6jVFDMz51Z1P_nP0tkK0v3yHe930T2_sf0Gv2S"; 

// Webhook do rankingu ELO (Ranking po meczu)
var rankingWebhook = "https://discord.com/api/webhooks/1443065290207268987/iuZBbuilIQZieQlFEYo3d7nxwHU4tfddZvs_g0GSZRWWy2r6e6WVo3jDkOod0MiF9CO6";// ---------------------
var fetchRecordingVariable = true;
var timeLimit = 3;
var scoreLimit = 3;

var gameConfig = {
    roomName: roomName,
    maxPlayers: maxPlayers,
    public: roomPublic,
    geo: { code: "PL", lat: 51.6650, lon: 19.4200 },
    noPlayer: true,
}

if (typeof token == 'string' && token.length == 39) {
    gameConfig.token = token;
}

var room = HBInit(gameConfig);

const originalSendAnnouncement = room.sendAnnouncement.bind(room);
room.sendAnnouncement = function (message, targetId, color, style, sound) {
    const resolveStyle = (input) => {
        if (input === undefined || input === null) return 'small';
        return input;
    };
    const finalStyle = resolveStyle(style);
    return originalSendAnnouncement.call(this, message, targetId, color, finalStyle, sound);
};

function safeFetch(url, options) {
    if (!url) return;
    try {
        fetch(url, options)
            .then((res) => res)
            .catch((err) => {
                if (typeof debugMode !== 'undefined' && debugMode) {
                    console.log('[fetch] request failed', err);
                }
            });
    } catch (err) {
        if (typeof debugMode !== 'undefined' && debugMode) {
            console.log('[fetch] request threw', err);
        }
    }
}

/* SAFE DISC HELPERS */
let ballDiscIndex = null;

function refreshDiscIndexes() {
    try {
        ballDiscIndex = null;
        const count = (room.getDiscCount && room.getDiscCount()) || 0;
        for (let i = 0; i < count; i++) {
            const props = room.getDiscProperties(i);
            if (props && Array.isArray(props.cGroup) && props.cGroup.indexOf('ball') !== -1) {
                ballDiscIndex = i;
                break;
            }
        }
    } catch (e) {
        ballDiscIndex = null;
    }
}

function getSafeDiscProps(index) {
    if (index == null) return null;
    try {
        const props = room.getDiscProperties(index);
        return props || null;
    } catch (e) {
        return null;
    }
}

function ballR() {
    let props = getSafeDiscProps(ballDiscIndex);
    if (!props) {
        refreshDiscIndexes();
        props = getSafeDiscProps(ballDiscIndex);
        if (!props) return 0;
    }
    return typeof props.radius === 'number' ? props.radius : 0;
}

function ballProps() {
    let props = getSafeDiscProps(ballDiscIndex);
    if (!props) {
        refreshDiscIndexes();
        props = getSafeDiscProps(ballDiscIndex);
    }
    if (!props) {
        props = getSafeDiscProps(0);
    }
    return props || null;
}

function resetBallDiscIndex() {
    ballDiscIndex = null;
}

setTimeout(refreshDiscIndexes, 100);

if (typeof globalThis !== 'undefined') {
    globalThis.refreshDiscIndexes = refreshDiscIndexes;
    globalThis.getSafeDiscProps = getSafeDiscProps;
    globalThis.ballProps = ballProps;
    globalThis.ballR = ballR;
}


const trainingMap = '{"name": "FUTSracz_Training","width": 510,"height": 230,"cameraWidth": 0,"cameraHeight": 0,"maxViewWidth": 0,"cameraFollow": "ball","spawnDistance": 150,"redSpawnPoints": [[-250,0]],"blueSpawnPoints": [[250,0]],"canBeStored": true,"kickOffReset": "full","bg": {"color": "425370","height": 200,"width": 400},"traits": {"ballArea": {"vis": false,"bCoef": 1,"cMask": ["ball"]},"goalPost": {"radius": 8,"invMass": 0,"bCoef": 0.5},"goalNet": {"vis": true,"bCoef": 0.1,"cMask": ["ball"]},"kickOffBarrier": {"vis": false,"bCoef": 0.1,"cGroup": ["redKO","blueKO"],"cMask": ["red","blue"]}},"vertexes": [{"x": -400,"y": -200,"bCoef": 1,"cMask": ["ball"],"color": "717F98","bias": -10},{"x": 400,"y": -200,"bCoef": 1,"cMask": ["ball"],"color": "717F98","bias": -10},{"x": -400,"y": 200,"bCoef": 1,"cMask": ["ball"],"color": "717F98","bias": 10,"curve": 0},{"x": 400,"y": 200,"bCoef": 1,"cMask": ["ball"],"color": "717F98","bias": 10,"curve": 0},{"x": -400,"y": 70,"bCoef": 1,"cMask": ["ball"],"color": "717F98","bias": 10,"pos": [-400,70]},{"x": -400,"y": 200,"bCoef": 1,"cMask": ["ball"],"color": "717F98","bias": 10},{"x": 400,"y": 70,"bCoef": 1,"cMask": ["ball"],"color": "717F98","bias": -10,"pos": [600,85]},{"x": 400,"y": 200,"bCoef": 1,"cMask": ["ball"],"color": "717F98","bias": -10},{"x": -400,"y": -200,"bCoef": 1,"cMask": ["ball"],"color": "717F98","bias": 10},{"x": -400,"y": -70,"bCoef": 1,"cMask": ["ball"],"color": "717F98","bias": 10,"pos": [-400,-70]},{"x": 400,"y": -200,"bCoef": 1,"cMask": ["ball"],"color": "717F98","bias": -10,"_data": {"mirror": {}}},{"x": 400,"y": -70,"bCoef": 1,"cMask": ["ball"],"color": "717F98","bias": -10,"_data": {"mirror": {}}},{"x": -435,"y": -70,"bCoef": 3,"cMask": ["ball"],"cGroup": ["ball"],"bias": -10,"color": "717F98","_data": {"mirror": {}}},{"x": -400,"y": -70,"bCoef": 3,"cMask": ["ball"],"cGroup": ["ball"],"bias": -10,"color": "717F98","pos": [-400,-70],"_data": {"mirror": {}}},{"x": -435,"y": 70,"bCoef": 3,"cMask": ["ball"],"cGroup": ["ball"],"bias": 10,"color": "717F98","_data": {"mirror": {}}},{"x": -400,"y": 70,"bCoef": 3,"cMask": ["ball"],"cGroup": ["ball"],"bias": 10,"color": "717F98","pos": [-400,70],"_data": {"mirror": {}}},{"x": -435,"y": -70,"bCoef": 3,"cMask": ["ball"],"cGroup": ["ball"],"bias": 10,"color": "717F98","curve": -35,"_data": {"mirror": {}}},{"x": -435,"y": 70,"bCoef": 3,"cMask": ["ball"],"cGroup": ["ball"],"bias": 10,"color": "717F98","curve": -35,"_data": {"mirror": {}}},{"x": 435,"y": -70,"bCoef": 2,"cMask": ["ball"],"cGroup": ["ball"],"bias": -10,"color": "717F98","curve": 35},{"x": 435,"y": 70,"bCoef": 2,"cMask": ["ball"],"cGroup": ["ball"],"bias": -10,"color": "717F98","curve": 35},{"x": 435,"y": -70,"bCoef": 2,"cMask": ["ball"],"cGroup": ["ball"],"bias": 10,"color": "717F98","_data": {"mirror": {}}},{"x": 400,"y": -70,"bCoef": 2,"cMask": ["ball"],"cGroup": ["ball"],"bias": 10,"color": "717F98","_data": {"mirror": {}}},{"x": 435,"y": 70,"bCoef": 2,"cMask": ["ball"],"cGroup": ["ball"],"bias": -10,"color": "717F98","curve": 0},{"x": 400,"y": 70,"bCoef": 2,"cMask": ["ball"],"cGroup": ["ball"],"bias": -10,"color": "717F98","pos": [600,85],"curve": 0},{"x": -400,"y": -70,"cMask": ["wall"],"cGroup": ["wall"],"color": "757FD0","pos": [-400,-70]},{"x": -400,"y": 70,"cMask": ["wall"],"cGroup": ["wall"],"color": "757FD0","pos": [-400,70]},{"x": 400,"y": -70,"cMask": ["wall"],"cGroup": ["wall"],"color": "757FD0"},{"x": 400,"y": 70,"cMask": ["wall"],"cGroup": ["wall"],"color": "757FD0","pos": [600,85]},{"x": 0,"y": -225,"cMask": ["red","blue"],"cGroup": ["redKO","blueKO"],"vis": false},{"x": 0,"y": -80,"cMask": ["red","blue"],"cGroup": ["redKO","blueKO"],"vis": false,"color": "0A1524"},{"x": 0,"y": 80,"cMask": ["red","blue"],"cGroup": ["redKO","blueKO"],"color": "333945"},{"x": 0,"y": 225,"cMask": ["red","blue"],"cGroup": ["redKO","blueKO"]},{"x": 0,"y": 80,"cMask": ["red","blue"],"cGroup": ["blueKO"],"color": "333945"},{"x": 0,"y": -80,"cMask": ["red","blue"],"cGroup": ["blueKO"],"color": "0A1524"},{"x": 0,"y": -80,"cMask": ["red","blue"],"cGroup": ["redKO"],"color": "0A1524"},{"x": 0,"y": 80,"cMask": ["red","blue"],"cGroup": ["redKO"],"color": "333945"},{"x": 0,"y": 80,"cMask": ["red","blue"],"cGroup": ["redKO","blueKO"],"color": "333945","vis": true},{"x": 0,"y": 79.3533815858876,"bCoef": 1,"cMask": ["wall"],"cGroup": ["wall"],"color": "333945"},{"x": 0,"y": 78.9185664888941,"bCoef": 1,"cMask": ["wall"],"cGroup": ["wall"],"color": "333945"},{"x": -0.6666666666666667,"y": 75.68671491922093,"bCoef": 1,"cMask": ["wall"],"cGroup": ["wall"],"color": "333945"},{"x": 2,"y": 76.58523315556077,"bCoef": 1,"cMask": ["wall"],"cGroup": ["wall"],"color": "333945"},{"x": -400,"y": -70,"cMask": ["wall"],"cGroup": ["wall"],"color": "1B2332","pos": [-400,-70]},{"x": -400,"y": 70,"cMask": ["wall"],"cGroup": ["wall"],"color": "1B2332","pos": [-400,70]},{"x": -400,"y": -70,"cMask": ["wall"],"cGroup": ["wall"],"color": "1B2332","curve": 0,"pos": [-400,-70]},{"x": -400,"y": 70,"cMask": ["wall"],"cGroup": ["wall"],"color": "1B2332","curve": 0,"pos": [-400,70]},{"x": 0,"y": -200,"cMask": ["wall"],"cGroup": ["wall"],"color": "454866"},{"x": 0,"y": -80,"cMask": ["wall"],"cGroup": ["wall"],"color": "454866"},{"x": 0,"y": 80,"cMask": ["wall"],"cGroup": ["wall"],"color": "333945"},{"x": 0,"y": 200,"cMask": ["wall"],"cGroup": ["wall"],"color": "454866"},{"x": 0,"y": -81,"cMask": ["wall"],"cGroup": ["wall"],"color": "454866"},{"x": 0,"y": 81,"cMask": ["wall"],"cGroup": ["wall"],"color": "333945"},{"x": 0,"y": 81,"cMask": ["wall"],"cGroup": ["wall"],"color": "333945"},{"x": 0,"y": -81,"cMask": ["wall"],"cGroup": ["wall"],"color": "454866"},{"x": -400,"y": -70,"cMask": ["wall"],"cGroup": ["wall"],"color": "1B2332","vis": true,"pos": [-400,-70]},{"x": -400,"y": 70,"cMask": ["wall"],"cGroup": ["wall"],"color": "1B2332","vis": true,"pos": [-400,70]},{"x": -400,"y": -70,"cMask": ["wall"],"cGroup": ["wall"],"color": "1B2332","vis": true,"pos": [-400,-70]},{"x": -400,"y": 70,"cMask": ["wall"],"cGroup": ["wall"],"color": "1B2332","vis": true,"pos": [-400,70]},{"x": 400,"y": -70,"cMask": ["wall"],"cGroup": ["wall"],"color": "1B2332"},{"x": 400,"y": 70,"cMask": ["wall"],"cGroup": ["wall"],"color": "1B2332"},{"x": 400,"y": -70,"cMask": ["wall"],"cGroup": ["wall"],"color": "1B2332","curve": 0},{"x": 400,"y": 70,"cMask": ["wall"],"cGroup": ["wall"],"color": "1B2332","curve": 0},{"x": 9.39130434782609,"y": -11.269565217391307,"cMask": ["wall"],"color": "333945"},{"x": 11.83280965079311,"y": 24.56958598810176,"cMask": ["wall"]},{"x": -32.376443145235896,"y": 8.8573507493062,"cMask": ["wall"]},{"x": -35.37391304347827,"y": 4.695652173913045,"cMask": ["wall"]},{"x": -42.88695652173914,"y": 1.2521739130434786,"cMask": ["wall"]},{"x": -48.48726446546526,"y": -30.481056772381155,"cMask": ["wall"]},{"x": -47.89565217391306,"y": -54.46956521739131,"cMask": ["wall"]},{"x": -20.034782608695657,"y": -63.23478260869567,"cMask": ["wall"]},{"x": -29.559051840888074,"y": -0.7611459019426459,"cMask": ["wall"]},{"x": 10.454626875638589,"y": -11.324715937712398,"cMask": ["wall"]},{"x": -7.200000000000002,"y": -64.80000000000001,"cMask": ["wall"]},{"x": 10.81394855609248,"y": -4.55640510638298,"cMask": ["wall"],"color": "333945"},{"x": 34.01470665839289,"y": 8.638759462926902,"cMask": ["wall"],"curve": 30.697755646979868},{"x": -19.297715744680854,"y": 3.2472844123145146,"cMask": ["wall"],"curve": 30.697755646979868},{"x": 4.020357446808512,"y": 9.648857872340427,"cMask": ["wall"],"curve": 30.697755646979868},{"x": 26.26633531914894,"y": 11.257000851063832,"cMask": ["wall"],"curve": 30.697755646979868},{"x": -11.7930485106383,"y": 3.216285957446809,"cMask": ["wall"]},{"x": -6.432571914893618,"y": 6.700595744680852,"cMask": ["wall"],"curve": 30.697755646979868},{"x": 10.184905531914895,"y": 8.844786382978725,"cMask": ["wall"],"curve": 30.697755646979868},{"x": 34.568395312271335,"y": 8.009716438749315,"cMask": ["wall"],"curve": 30.697755646979868,"color": "333945"},{"x": 14.174264523855701,"y": 10.820627286374345,"cMask": ["wall"],"curve": 30.697755646979868},{"x": 1.4397932438211498,"y": 6.9619408441862225,"cMask": ["wall"],"curve": 30.697755646979868},{"x": 22.059415254652034,"y": 18.072187607829242,"cMask": ["wall"],"curve": 85.827862608012},{"x": -28.67854978723405,"y": 7.236643404255321,"cMask": ["wall"]},{"x": -40.73962212765958,"y": -23.854120851063833,"cMask": ["wall"]},{"x": -32.430883404255326,"y": -49.04836085106385,"cMask": ["wall"]},{"x": -0.2680238297872341,"y": -58.69721872340427,"cMask": ["wall"]},{"x": 9.65553660262229,"y": -12.506519831938512,"cMask": ["wall"]},{"x": -31.626811914893622,"y": -50.92452765957447,"cMask": ["wall"]},{"x": -47.440217872340426,"y": -53.33674212765959,"cMask": ["wall"]},{"x": -49.04836085106383,"y": -48.7803370212766,"cMask": ["wall"]},{"x": -33.23495489361703,"y": -45.564051063829794,"cMask": ["wall"]},{"x": -33.28255870932828,"y": 12.037564590909652,"cMask": ["wall"]},{"x": -18.761668085106386,"y": 12.865143829787236,"cMask": ["wall"]},{"x": 28.41052595744682,"y": 16.61747744680851,"cMask": ["wall"]},{"x": 42.09120144091611,"y": 8.122026626187573,"cMask": ["wall"]},{"x": 39.56055238975308,"y": 13.604394476102472,"cMask": ["wall"]},{"x": 25.615308224365116,"y": 39.95729223661989,"cMask": ["wall"]},{"x": 25.06464381237601,"y": 57.17790976154849,"cMask": ["wall"]},{"x": -21.326479630988413,"y": 51.90718063012711,"cMask": ["wall"]},{"x": -22.06187548033284,"y": 31.622021521810407,"cMask": ["wall"]},{"x": 34.310628747013645,"y": 21.444142966883526,"cMask": ["wall"]},{"x": 0,"y": -235,"cMask": ["red","blue"],"cGroup": ["redKO","blueKO"]},{"x": 0,"y": -230,"cMask": ["wall"]},{"x": -150,"y": -220,"cMask": []},{"x": 150,"y": -220,"cMask": []}],"segments": [{"v0": 0,"v1": 1,"color": "717F98","bCoef": 1,"cMask": ["ball"],"bias": -10,"y": -320},{"v0": 2,"v1": 3,"curve": 0,"color": "717F98","bCoef": 1,"cMask": ["ball"],"bias": 10,"y": 320},{"v0": 4,"v1": 5,"color": "717F98","bCoef": 1,"cMask": ["ball"],"bias": 10,"x": -700},{"v0": 6,"v1": 7,"color": "717F98","bCoef": 1,"cMask": ["ball"],"bias": -10,"x": 700},{"v0": 8,"v1": 9,"color": "717F98","bCoef": 1,"cMask": ["ball"],"bias": 10,"x": -700},{"v0": 10,"v1": 11,"color": "717F98","bCoef": 1,"cMask": ["ball"],"bias": -10,"x": 700,"_data": {"mirror": {},"arc": {"a": [400,-200],"b": [400,-70],"radius": null,"center": [null,null],"from": null,"to": null}}},{"v0": 12,"v1": 13,"color": "717F98","bCoef": 3,"cMask": ["ball"],"cGroup": ["ball"],"bias": -10,"y": -85,"_data": {"mirror": {},"arc": {"a": [-435,-70],"b": [-400,-70],"radius": null,"center": [null,null],"from": null,"to": null}}},{"v0": 14,"v1": 15,"color": "717F98","bCoef": 3,"cMask": ["ball"],"cGroup": ["ball"],"bias": 10,"y": 85,"_data": {"mirror": {},"arc": {"a": [-435,70],"b": [-400,70],"radius": null,"center": [null,null],"from": null,"to": null}}},{"v0": 16,"v1": 17,"curve": -35,"color": "717F98","bCoef": 3,"cMask": ["ball"],"cGroup": ["ball"],"bias": 10,"x": -735,"_data": {"mirror": {},"arc": {"a": [-435,-70],"b": [-435,70],"curve": -35,"radius": 232.78566663961288,"center": [-212.98836383457515,0],"from": 2.8361600344907854,"to": -2.8361600344907854}}},{"v0": 18,"v1": 19,"curve": 35,"color": "717F98","bCoef": 2,"cMask": ["ball"],"cGroup": ["ball"],"bias": -10,"x": 735},{"v0": 20,"v1": 21,"color": "717F98","bCoef": 2,"cMask": ["ball"],"cGroup": ["ball"],"bias": 10,"_data": {"mirror": {},"arc": {"a": [435,-70],"b": [400,-70],"radius": null,"center": [null,null],"from": null,"to": null}}},{"v0": 22,"v1": 23,"curve": 0,"color": "717F98","bCoef": 2,"cMask": ["ball"],"cGroup": ["ball"],"bias": -10,"y": 70},{"v0": 24,"v1": 25,"color": "757FD0","cMask": ["wall"],"cGroup": ["wall"],"x": -700},{"v0": 26,"v1": 27,"color": "757FD0","cMask": ["wall"],"cGroup": ["wall"],"x": 400},{"v0": 28,"v1": 29,"vis": false,"color": "a3a3a3","cMask": ["red","blue"],"cGroup": ["redKO","blueKO"],"x": 0},{"v0": 30,"v1": 31,"vis": false,"color": "a3a3a3","cMask": ["red","blue"],"cGroup": ["redKO","blueKO"],"x": 0},{"v0": 32,"v1": 33,"curve": 180,"vis": false,"color": "0A1524","cMask": ["red","blue"],"cGroup": ["blueKO"],"x": 0},{"v0": 34,"v1": 35,"curve": 180,"vis": false,"color": "0A1524","cMask": ["red","blue"],"cGroup": ["redKO"],"x": 0},{"v0": 45,"v1": 46,"color": "454866","cMask": ["wall"],"cGroup": ["wall"],"x": 0},{"v0": 47,"v1": 48,"color": "454866","cMask": ["wall"],"cGroup": ["wall"],"x": 0},{"v0": 49,"v1": 50,"curve": 180,"color": "454866","cMask": ["wall"],"cGroup": ["wall"]},{"v0": 51,"v1": 52,"curve": 180,"color": "454866","cMask": ["wall"],"cGroup": ["wall"]},{"v0": 63,"v1": 64,"color": "333945","cMask": ["wall"]},{"v0": 64,"v1": 65,"color": "333945","cMask": ["wall"]},{"v0": 65,"v1": 66,"curve": 16.850696324072082,"color": "333945","cMask": ["wall"]},{"v0": 66,"v1": 67,"curve": 3.161798573766408,"color": "333945","cMask": ["wall"]},{"v0": 67,"v1": 68,"curve": 8.325843170237832,"color": "333945","cMask": ["wall"]},{"v0": 70,"v1": 71,"curve": -97.52517012489479,"color": "333945","cMask": ["wall"]},{"v0": 71,"v1": 68,"curve": -19.564814063614712,"color": "333945","cMask": ["wall"]},{"v0": 72,"v1": 73,"curve": 17.697755646979868,"color": "333945","cMask": ["wall"]},{"v0": 74,"v1": 72,"curve": 8.609687752906625,"color": "333945","cMask": ["wall"]},{"v0": 74,"v1": 75,"curve": -16.639174997709674,"color": "333945","cMask": ["wall"]},{"v0": 75,"v1": 76,"color": "333945","cMask": ["wall"]},{"v0": 76,"v1": 73,"curve": -27.922367075409877,"color": "333945","cMask": ["wall"]},{"v0": 72,"v1": 73,"curve": 17.697755646979868,"color": "333945","cMask": ["wall"]},{"v0": 77,"v1": 72,"curve": 17.697755646979868,"color": "333945","cMask": ["wall"]},{"v0": 77,"v1": 72,"curve": 17.697755646979868,"color": "333945","cMask": ["wall"]},{"v0": 78,"v1": 72,"curve": 17.697755646979868,"color": "333945","cMask": ["wall"]},{"v0": 78,"v1": 72,"curve": 17.697755646979868,"color": "333945","cMask": ["wall"]},{"v0": 75,"v1": 72,"curve": 17.697755646979868,"color": "333945","cMask": ["wall"]},{"v0": 79,"v1": 72,"curve": 17.697755646979868,"color": "333945","cMask": ["wall"]},{"v0": 76,"v1": 72,"curve": 17.697755646979868,"color": "333945","cMask": ["wall"]},{"v0": 73,"v1": 72,"curve": 17.697755646979868,"color": "333945","cMask": ["wall"]},{"v0": 80,"v1": 72,"curve": 17.697755646979868,"color": "333945","cMask": ["wall"]},{"v0": 81,"v1": 72,"curve": 17.697755646979868,"color": "333945","cMask": ["wall"]},{"v0": 82,"v1": 72,"curve": 17.697755646979868,"color": "333945","cMask": ["wall"]},{"v0": 74,"v1": 82,"curve": 30.697755646979868,"color": "333945","cMask": ["wall"]},{"v0": 74,"v1": 75,"curve": 30.697755646979868,"color": "333945","cMask": ["wall"]},{"v0": 74,"v1": 79,"curve": 30.697755646979868,"color": "333945","cMask": ["wall"]},{"v0": 78,"v1": 81,"curve": 30.697755646979868,"color": "333945","cMask": ["wall"]},{"v0": 82,"v1": 76,"curve": 30.697755646979868,"color": "333945","cMask": ["wall"]},{"v0": 82,"v1": 80,"curve": 68.3953665340623,"color": "333945","cMask": ["wall"]},{"v0": 79,"v1": 73,"curve": 30.697755646979868,"color": "333945","cMask": ["wall"]},{"v0": 73,"v1": 79,"curve": -87.31123949814534,"color": "333945","cMask": ["wall"]},{"v0": 76,"v1": 82,"curve": 30.697755646979868,"color": "333945","cMask": ["wall"]},{"v0": 72,"v1": 75,"curve": 30.697755646979868,"color": "333945","cMask": ["wall"]},{"v0": 72,"v1": 81,"curve": 77.41690755046625,"color": "333945","cMask": ["wall"]},{"v0": 72,"v1": 78,"curve": 30.697755646979868,"color": "333945","cMask": ["wall"]},{"v0": 72,"v1": 74,"curve": 30.697755646979868,"color": "333945","cMask": ["wall"]},{"v0": 75,"v1": 72,"curve": 30.697755646979868,"color": "333945","cMask": ["wall"]},{"v0": 82,"v1": 72,"curve": 30.697755646979868,"color": "333945","cMask": ["wall"]},{"v0": 83,"v1": 84,"curve": 30.09341366796523,"color": "333945","cMask": ["wall"]},{"v0": 84,"v1": 64,"curve": 30.09341366796523,"color": "333945","cMask": ["wall"]},{"v0": 69,"v1": 64,"curve": 30.09341366796523,"color": "333945","cMask": ["wall"]},{"v0": 69,"v1": 85,"curve": 69.16073107687012,"color": "333945","cMask": ["wall"]},{"v0": 85,"v1": 86,"curve": 30.09341366796523,"color": "333945","cMask": ["wall"]},{"v0": 86,"v1": 88,"curve": 181.43097013701654,"color": "333945","cMask": ["wall"]},{"v0": 89,"v1": 90,"curve": 66.49184618573582,"color": "333945","cMask": ["wall"]},{"v0": 91,"v1": 92,"curve": -48.455490635908575,"color": "333945","cMask": ["wall"]},{"v0": 93,"v1": 62,"curve": -24.958054346304802,"color": "333945","cMask": ["wall"]},{"v0": 83,"v1": 97,"curve": -29.533282419563072,"color": "333945","cMask": ["wall"]},{"v0": 97,"v1": 96,"curve": -55.54437177889409,"color": "333945","cMask": ["wall"]},{"v0": 69,"v1": 88,"color": "333945","cMask": ["wall"]},{"v0": 88,"v1": 96,"curve": 41.710719111983614,"color": "333945","cMask": ["wall"]},{"v0": 72,"v1": 80,"curve": 54.18593425555315,"color": "333945","cMask": ["wall"]},{"v0": 74,"v1": 80,"curve": -44.79426468732674,"color": "333945","cMask": ["wall"]},{"v0": 96,"v1": 98,"curve": 89.5812282216413,"color": "333945","cMask": ["wall"]},{"v0": 98,"v1": 99,"curve": 23.194873783277057,"color": "333945","cMask": ["wall"]},{"v0": 99,"v1": 100,"curve": 53.179295321916406,"color": "333945","cMask": ["wall"]},{"v0": 100,"v1": 101,"curve": -12.796380197087228,"color": "333945","cMask": ["wall"]},{"v0": 101,"v1": 64,"curve": 36.47641528430293,"color": "333945","cMask": ["wall"]},{"v0": 98,"v1": 101,"curve": 45.24940456016575,"color": "333945","cMask": ["wall"]},{"v0": 62,"v1": 102,"curve": -32.735238957707,"color": "333945","cMask": ["wall"]},{"v0": 102,"v1": 96,"curve": -90.29409777379153,"color": "333945","cMask": ["wall"]},{"v0": 105,"v1": 106,"color": "404040","cMask": []}],"goals": [],"discs": [{"radius": 5,"invMass": 0,"pos": [-400,-70],"color": "8198A3","bCoef": 1,"cMask": ["all"],"cGroup": ["all"],"_data": {"mirror": {}}},{"radius": 5,"invMass": 0,"pos": [-400,70],"color": "8198A3","bCoef": 1,"cMask": ["all"],"cGroup": ["all"]},{"radius": 5,"invMass": 0,"pos": [400,70],"color": "8198A3","bCoef": 1,"cMask": ["all"],"cGroup": ["all"],"x": 400},{"radius": 5,"invMass": 0,"pos": [400,-70],"color": "8198A3","bCoef": 1,"cMask": ["all"],"cGroup": ["all"],"x": 400},{"radius": 7,"pos": [0,-220],"color": "424242","cGroup": []},{"radius": 5,"pos": [0,-220],"color": "202020","cGroup": []}],"planes": [{"normal": [0,1],"dist": -300,"cMask": ["red","blue"],"_data": {"extremes": {"normal": [0,1],"dist": -300,"canvas_rect": [-892,-321,893,321],"a": [-892,-300],"b": [893,-300]}}},{"normal": [0,-1],"dist": -300,"cMask": ["red","blue"],"_data": {"extremes": {"normal": [0,-1],"dist": -300,"canvas_rect": [-892,-321,893,321],"a": [-892,300],"b": [893,300]}}},{"normal": [-1,0],"dist": -705,"cMask": ["red","blue"],"_data": {"extremes": {"normal": [-1,0],"dist": -705,"canvas_rect": [-892,-321,893,321],"a": [705,-321],"b": [705,321]}}},{"normal": [0,0],"dist": -705,"cMask": ["red","blue"],"_data": {"extremes": {"normal": [0,0],"dist": -705,"canvas_rect": [-892,-321,893,321],"a": [-705,-321],"b": [-705,321]}}},{"normal": [1,0],"dist": -695,"bCoef": 0,"cMask": ["c0"],"_data": {"extremes": {"normal": [1,0],"dist": -695,"canvas_rect": [-892,-321,893,321],"a": [-695,-321],"b": [-695,321]}}},{"normal": [-1,0],"dist": -700,"bCoef": 0,"cMask": ["c1"],"_data": {"extremes": {"normal": [-1,0],"dist": -700,"canvas_rect": [-892,-321,893,321],"a": [700,-321],"b": [700,321]}}}],"joints": [],"playerPhysics": {"radius": 15,"bCoef": 0,"invMass": 0.5,"damping": 0.96,"cGroup": ["red","blue"],"acceleration": 0.11,"gravity": [0,0],"kickingAcceleration": 0.083,"kickingDamping": 0.96,"kickStrength": 4.2,"kickback": 0},"ballPhysics": {"radius": 5.8,"bCoef": 0.412,"cMask": ["all"],"damping": 0.99,"invMass": 1.5,"gravity": [0,0],"color": "FFA500","cGroup": ["ball"]}}'
const classicMap = '{"name": "FutSracz_1v1","width": 510,"height": 230,"cameraWidth": 0,"cameraHeight": 0,"maxViewWidth": 0,"cameraFollow": "ball","spawnDistance": 150,"redSpawnPoints": [[-250,0]],"blueSpawnPoints": [[250,0]],"canBeStored": true,"kickOffReset": "full","bg": {"color": "425370","height": 200,"width": 400},"traits": {"ballArea": {"vis": false,"bCoef": 1,"cMask": ["ball"]},"goalPost": {"radius": 8,"invMass": 0,"bCoef": 0.5},"goalNet": {"vis": true,"bCoef": 0.1,"cMask": ["ball"]},"kickOffBarrier": {"vis": false,"bCoef": 0.1,"cGroup": ["redKO","blueKO"],"cMask": ["red","blue"]}},"vertexes": [{"x": -400,"y": -200,"bCoef": 1,"cMask": ["ball"],"color": "717F98","bias": -10},{"x": 400,"y": -200,"bCoef": 1,"cMask": ["ball"],"color": "717F98","bias": -10},{"x": -400,"y": 200,"bCoef": 1,"cMask": ["ball"],"color": "717F98","bias": 10,"curve": 0},{"x": 400,"y": 200,"bCoef": 1,"cMask": ["ball"],"color": "717F98","bias": 10,"curve": 0},{"x": -400,"y": 70,"bCoef": 1,"cMask": ["ball"],"color": "717F98","bias": 10,"pos": [-400,70]},{"x": -400,"y": 200,"bCoef": 1,"cMask": ["ball"],"color": "717F98","bias": 10},{"x": 400,"y": 70,"bCoef": 1,"cMask": ["ball"],"color": "717F98","bias": -10,"pos": [600,85]},{"x": 400,"y": 200,"bCoef": 1,"cMask": ["ball"],"color": "717F98","bias": -10},{"x": -400,"y": -200,"bCoef": 1,"cMask": ["ball"],"color": "717F98","bias": 10},{"x": -400,"y": -70,"bCoef": 1,"cMask": ["ball"],"color": "717F98","bias": 10,"pos": [-400,-70]},{"x": 400,"y": -200,"bCoef": 1,"cMask": ["ball"],"color": "717F98","bias": -10},{"x": 400,"y": -70,"bCoef": 1,"cMask": ["ball"],"color": "717F98","bias": -10},{"x": -435,"y": -70,"bCoef": 0.2,"cMask": ["ball"],"cGroup": ["ball"],"bias": -10,"color": "717F98"},{"x": -400,"y": -70,"bCoef": 0.2,"cMask": ["ball"],"cGroup": ["ball"],"bias": -10,"color": "717F98","pos": [-400,-70]},{"x": -435,"y": 70,"bCoef": 0.2,"cMask": ["ball"],"cGroup": ["ball"],"bias": 10,"color": "717F98"},{"x": -400,"y": 70,"bCoef": 0.2,"cMask": ["ball"],"cGroup": ["ball"],"bias": 10,"color": "717F98","pos": [-400,70]},{"x": -435,"y": -70,"bCoef": 0.2,"cMask": ["ball"],"cGroup": ["ball"],"bias": 10,"color": "717F98","curve": -35},{"x": -435,"y": 70,"bCoef": 0.2,"cMask": ["ball"],"cGroup": ["ball"],"bias": 10,"color": "717F98","curve": -35},{"x": 435,"y": -70,"bCoef": 0.2,"cMask": ["ball"],"cGroup": ["ball"],"bias": -10,"color": "717F98","curve": 35},{"x": 435,"y": 70,"bCoef": 0.2,"cMask": ["ball"],"cGroup": ["ball"],"bias": -10,"color": "717F98","curve": 35},{"x": 435,"y": -70,"bCoef": 0.2,"cMask": ["ball"],"cGroup": ["ball"],"bias": 10,"color": "717F98"},{"x": 400,"y": -70,"bCoef": 0.2,"cMask": ["ball"],"cGroup": ["ball"],"bias": 10,"color": "717F98"},{"x": 435,"y": 70,"bCoef": 0.2,"cMask": ["ball"],"cGroup": ["ball"],"bias": -10,"color": "717F98","curve": 0},{"x": 400,"y": 70,"bCoef": 0.2,"cMask": ["ball"],"cGroup": ["ball"],"bias": -10,"color": "717F98","pos": [600,85],"curve": 0},{"x": -400,"y": -70,"cMask": ["wall"],"cGroup": ["wall"],"color": "757FD0","pos": [-400,-70]},{"x": -400,"y": 70,"cMask": ["wall"],"cGroup": ["wall"],"color": "757FD0","pos": [-400,70]},{"x": 400,"y": -70,"cMask": ["wall"],"cGroup": ["wall"],"color": "757FD0"},{"x": 400,"y": 70,"cMask": ["wall"],"cGroup": ["wall"],"color": "757FD0","pos": [600,85]},{"x": 0,"y": -225,"cMask": ["red","blue"],"cGroup": ["redKO","blueKO"],"vis": false},{"x": 0,"y": -80,"cMask": ["red","blue"],"cGroup": ["redKO","blueKO"],"vis": false,"color": "0A1524"},{"x": 0,"y": 80,"cMask": ["red","blue"],"cGroup": ["redKO","blueKO"],"color": "333945"},{"x": 0,"y": 225,"cMask": ["red","blue"],"cGroup": ["redKO","blueKO"]},{"x": 0,"y": 80,"cMask": ["red","blue"],"cGroup": ["blueKO"],"color": "333945"},{"x": 0,"y": -80,"cMask": ["red","blue"],"cGroup": ["blueKO"],"color": "0A1524"},{"x": 0,"y": -80,"cMask": ["red","blue"],"cGroup": ["redKO"],"color": "0A1524"},{"x": 0,"y": 80,"cMask": ["red","blue"],"cGroup": ["redKO"],"color": "333945"},{"x": 0,"y": 80,"cMask": ["red","blue"],"cGroup": ["redKO","blueKO"],"color": "333945","vis": true},{"x": 0,"y": 79.3533815858876,"bCoef": 1,"cMask": ["wall"],"cGroup": ["wall"],"color": "333945"},{"x": 0,"y": 78.9185664888941,"bCoef": 1,"cMask": ["wall"],"cGroup": ["wall"],"color": "333945"},{"x": -0.6666666666666667,"y": 75.68671491922093,"bCoef": 1,"cMask": ["wall"],"cGroup": ["wall"],"color": "333945"},{"x": 2,"y": 76.58523315556077,"bCoef": 1,"cMask": ["wall"],"cGroup": ["wall"],"color": "333945"},{"x": -400,"y": -70,"cMask": ["wall"],"cGroup": ["wall"],"color": "1B2332","pos": [-400,-70]},{"x": -400,"y": 70,"cMask": ["wall"],"cGroup": ["wall"],"color": "1B2332","pos": [-400,70]},{"x": -400,"y": -70,"cMask": ["wall"],"cGroup": ["wall"],"color": "1B2332","curve": 0,"pos": [-400,-70]},{"x": -400,"y": 70,"cMask": ["wall"],"cGroup": ["wall"],"color": "1B2332","curve": 0,"pos": [-400,70]},{"x": 0,"y": -200,"cMask": ["wall"],"cGroup": ["wall"],"color": "454866"},{"x": 0,"y": -80,"cMask": ["wall"],"cGroup": ["wall"],"color": "454866"},{"x": 0,"y": 80,"cMask": ["wall"],"cGroup": ["wall"],"color": "333945"},{"x": 0,"y": 200,"cMask": ["wall"],"cGroup": ["wall"],"color": "454866"},{"x": 0,"y": -81,"cMask": ["wall"],"cGroup": ["wall"],"color": "454866"},{"x": 0,"y": 81,"cMask": ["wall"],"cGroup": ["wall"],"color": "333945"},{"x": 0,"y": 81,"cMask": ["wall"],"cGroup": ["wall"],"color": "333945"},{"x": 0,"y": -81,"cMask": ["wall"],"cGroup": ["wall"],"color": "454866"},{"x": -400,"y": -70,"cMask": ["wall"],"cGroup": ["wall"],"color": "1B2332","vis": true,"pos": [-400,-70]},{"x": -400,"y": 70,"cMask": ["wall"],"cGroup": ["wall"],"color": "1B2332","vis": true,"pos": [-400,70]},{"x": -400,"y": -70,"cMask": ["wall"],"cGroup": ["wall"],"color": "1B2332","vis": true,"pos": [-400,-70]},{"x": -400,"y": 70,"cMask": ["wall"],"cGroup": ["wall"],"color": "1B2332","vis": true,"pos": [-400,70]},{"x": 400,"y": -70,"cMask": ["wall"],"cGroup": ["wall"],"color": "1B2332"},{"x": 400,"y": 70,"cMask": ["wall"],"cGroup": ["wall"],"color": "1B2332"},{"x": 400,"y": -70,"cMask": ["wall"],"cGroup": ["wall"],"color": "1B2332","curve": 0},{"x": 400,"y": 70,"cMask": ["wall"],"cGroup": ["wall"],"color": "1B2332","curve": 0},{"x": 9.39130434782609,"y": -11.269565217391307,"cMask": ["wall"],"color": "333945"},{"x": 11.83280965079311,"y": 24.56958598810176,"cMask": ["wall"]},{"x": -32.376443145235896,"y": 8.8573507493062,"cMask": ["wall"]},{"x": -35.37391304347827,"y": 4.695652173913045,"cMask": ["wall"]},{"x": -42.88695652173914,"y": 1.2521739130434786,"cMask": ["wall"]},{"x": -48.48726446546526,"y": -30.481056772381155,"cMask": ["wall"]},{"x": -47.89565217391306,"y": -54.46956521739131,"cMask": ["wall"]},{"x": -20.034782608695657,"y": -63.23478260869567,"cMask": ["wall"]},{"x": -29.559051840888074,"y": -0.7611459019426459,"cMask": ["wall"]},{"x": 10.454626875638589,"y": -11.324715937712398,"cMask": ["wall"]},{"x": -7.200000000000002,"y": -64.80000000000001,"cMask": ["wall"]},{"x": 10.81394855609248,"y": -4.55640510638298,"cMask": ["wall"],"color": "333945"},{"x": 34.01470665839289,"y": 8.638759462926902,"cMask": ["wall"],"curve": 30.697755646979868},{"x": -19.297715744680854,"y": 3.2472844123145146,"cMask": ["wall"],"curve": 30.697755646979868},{"x": 4.020357446808512,"y": 9.648857872340427,"cMask": ["wall"],"curve": 30.697755646979868},{"x": 26.26633531914894,"y": 11.257000851063832,"cMask": ["wall"],"curve": 30.697755646979868},{"x": -11.7930485106383,"y": 3.216285957446809,"cMask": ["wall"]},{"x": -6.432571914893618,"y": 6.700595744680852,"cMask": ["wall"],"curve": 30.697755646979868},{"x": 10.184905531914895,"y": 8.844786382978725,"cMask": ["wall"],"curve": 30.697755646979868},{"x": 34.568395312271335,"y": 8.009716438749315,"cMask": ["wall"],"curve": 30.697755646979868,"color": "333945"},{"x": 14.174264523855701,"y": 10.820627286374345,"cMask": ["wall"],"curve": 30.697755646979868},{"x": 1.4397932438211498,"y": 6.9619408441862225,"cMask": ["wall"],"curve": 30.697755646979868},{"x": 22.059415254652034,"y": 18.072187607829242,"cMask": ["wall"],"curve": 85.827862608012},{"x": -28.67854978723405,"y": 7.236643404255321,"cMask": ["wall"]},{"x": -40.73962212765958,"y": -23.854120851063833,"cMask": ["wall"]},{"x": -32.430883404255326,"y": -49.04836085106385,"cMask": ["wall"]},{"x": -0.2680238297872341,"y": -58.69721872340427,"cMask": ["wall"]},{"x": 9.65553660262229,"y": -12.506519831938512,"cMask": ["wall"]},{"x": -31.626811914893622,"y": -50.92452765957447,"cMask": ["wall"]},{"x": -47.440217872340426,"y": -53.33674212765959,"cMask": ["wall"]},{"x": -49.04836085106383,"y": -48.7803370212766,"cMask": ["wall"]},{"x": -33.23495489361703,"y": -45.564051063829794,"cMask": ["wall"]},{"x": -33.28255870932828,"y": 12.037564590909652,"cMask": ["wall"]},{"x": -18.761668085106386,"y": 12.865143829787236,"cMask": ["wall"]},{"x": 28.41052595744682,"y": 16.61747744680851,"cMask": ["wall"]},{"x": 42.09120144091611,"y": 8.122026626187573,"cMask": ["wall"]},{"x": 39.56055238975308,"y": 13.604394476102472,"cMask": ["wall"]},{"x": 25.615308224365116,"y": 39.95729223661989,"cMask": ["wall"]},{"x": 25.06464381237601,"y": 57.17790976154849,"cMask": ["wall"]},{"x": -21.326479630988413,"y": 51.90718063012711,"cMask": ["wall"]},{"x": -22.06187548033284,"y": 31.622021521810407,"cMask": ["wall"]},{"x": 34.310628747013645,"y": 21.444142966883526,"cMask": ["wall"]},{"x": -135.07046388725777,"y": -219.63388138578978,"cMask": [],"_data": {"mirror": {}}},{"x": 135.07046388725777,"y": -219.63388138578978,"cMask": [],"_data": {"mirror": {}}}],"segments": [{"v0": 0,"v1": 1,"color": "717F98","bCoef": 1,"cMask": ["ball"],"bias": -10,"y": -320},{"v0": 2,"v1": 3,"curve": 0,"color": "717F98","bCoef": 1,"cMask": ["ball"],"bias": 10,"y": 320},{"v0": 4,"v1": 5,"color": "717F98","bCoef": 1,"cMask": ["ball"],"bias": 10,"x": -700},{"v0": 6,"v1": 7,"color": "717F98","bCoef": 1,"cMask": ["ball"],"bias": -10,"x": 700},{"v0": 8,"v1": 9,"color": "717F98","bCoef": 1,"cMask": ["ball"],"bias": 10,"x": -700},{"v0": 10,"v1": 11,"color": "717F98","bCoef": 1,"cMask": ["ball"],"bias": -10,"x": 700},{"v0": 12,"v1": 13,"color": "717F98","bCoef": 0.2,"cMask": ["ball"],"cGroup": ["ball"],"bias": -10,"y": -85},{"v0": 14,"v1": 15,"color": "717F98","bCoef": 0.2,"cMask": ["ball"],"cGroup": ["ball"],"bias": 10,"y": 85},{"v0": 16,"v1": 17,"curve": -35,"color": "717F98","bCoef": 0.2,"cMask": ["ball"],"cGroup": ["ball"],"bias": 10,"x": -735},{"v0": 18,"v1": 19,"curve": 35,"color": "717F98","bCoef": 0.2,"cMask": ["ball"],"cGroup": ["ball"],"bias": -10,"x": 735},{"v0": 20,"v1": 21,"color": "717F98","bCoef": 0.2,"cMask": ["ball"],"cGroup": ["ball"],"bias": 10},{"v0": 22,"v1": 23,"curve": 0,"color": "717F98","bCoef": 0.2,"cMask": ["ball"],"cGroup": ["ball"],"bias": -10,"y": 70},{"v0": 24,"v1": 25,"color": "757FD0","cMask": ["wall"],"cGroup": ["wall"],"x": -700},{"v0": 26,"v1": 27,"color": "757FD0","cMask": ["wall"],"cGroup": ["wall"],"x": 400},{"v0": 28,"v1": 29,"vis": false,"color": "a3a3a3","cMask": ["red","blue"],"cGroup": ["redKO","blueKO"],"x": 0},{"v0": 30,"v1": 31,"vis": false,"color": "a3a3a3","cMask": ["red","blue"],"cGroup": ["redKO","blueKO"],"x": 0},{"v0": 32,"v1": 33,"curve": 180,"vis": false,"color": "0A1524","cMask": ["red","blue"],"cGroup": ["blueKO"],"x": 0},{"v0": 34,"v1": 35,"curve": 180,"vis": false,"color": "0A1524","cMask": ["red","blue"],"cGroup": ["redKO"],"x": 0},{"v0": 45,"v1": 46,"color": "454866","cMask": ["wall"],"cGroup": ["wall"],"x": 0},{"v0": 47,"v1": 48,"color": "454866","cMask": ["wall"],"cGroup": ["wall"],"x": 0},{"v0": 49,"v1": 50,"curve": 180,"color": "454866","cMask": ["wall"],"cGroup": ["wall"]},{"v0": 51,"v1": 52,"curve": 180,"color": "454866","cMask": ["wall"],"cGroup": ["wall"]},{"v0": 63,"v1": 64,"color": "333945","cMask": ["wall"]},{"v0": 64,"v1": 65,"color": "333945","cMask": ["wall"]},{"v0": 65,"v1": 66,"curve": 16.850696324072082,"color": "333945","cMask": ["wall"]},{"v0": 66,"v1": 67,"curve": 3.161798573766408,"color": "333945","cMask": ["wall"]},{"v0": 67,"v1": 68,"curve": 8.325843170237832,"color": "333945","cMask": ["wall"]},{"v0": 70,"v1": 71,"curve": -97.52517012489479,"color": "333945","cMask": ["wall"]},{"v0": 71,"v1": 68,"curve": -19.564814063614712,"color": "333945","cMask": ["wall"]},{"v0": 72,"v1": 73,"curve": 17.697755646979868,"color": "333945","cMask": ["wall"]},{"v0": 74,"v1": 72,"curve": 8.609687752906625,"color": "333945","cMask": ["wall"]},{"v0": 74,"v1": 75,"curve": -16.639174997709674,"color": "333945","cMask": ["wall"]},{"v0": 75,"v1": 76,"color": "333945","cMask": ["wall"]},{"v0": 76,"v1": 73,"curve": -27.922367075409877,"color": "333945","cMask": ["wall"]},{"v0": 72,"v1": 73,"curve": 17.697755646979868,"color": "333945","cMask": ["wall"]},{"v0": 77,"v1": 72,"curve": 17.697755646979868,"color": "333945","cMask": ["wall"]},{"v0": 77,"v1": 72,"curve": 17.697755646979868,"color": "333945","cMask": ["wall"]},{"v0": 78,"v1": 72,"curve": 17.697755646979868,"color": "333945","cMask": ["wall"]},{"v0": 78,"v1": 72,"curve": 17.697755646979868,"color": "333945","cMask": ["wall"]},{"v0": 75,"v1": 72,"curve": 17.697755646979868,"color": "333945","cMask": ["wall"]},{"v0": 79,"v1": 72,"curve": 17.697755646979868,"color": "333945","cMask": ["wall"]},{"v0": 76,"v1": 72,"curve": 17.697755646979868,"color": "333945","cMask": ["wall"]},{"v0": 73,"v1": 72,"curve": 17.697755646979868,"color": "333945","cMask": ["wall"]},{"v0": 80,"v1": 72,"curve": 17.697755646979868,"color": "333945","cMask": ["wall"]},{"v0": 81,"v1": 72,"curve": 17.697755646979868,"color": "333945","cMask": ["wall"]},{"v0": 82,"v1": 72,"curve": 17.697755646979868,"color": "333945","cMask": ["wall"]},{"v0": 74,"v1": 82,"curve": 30.697755646979868,"color": "333945","cMask": ["wall"]},{"v0": 74,"v1": 75,"curve": 30.697755646979868,"color": "333945","cMask": ["wall"]},{"v0": 74,"v1": 79,"curve": 30.697755646979868,"color": "333945","cMask": ["wall"]},{"v0": 78,"v1": 81,"curve": 30.697755646979868,"color": "333945","cMask": ["wall"]},{"v0": 82,"v1": 76,"curve": 30.697755646979868,"color": "333945","cMask": ["wall"]},{"v0": 82,"v1": 80,"curve": 68.3953665340623,"color": "333945","cMask": ["wall"]},{"v0": 79,"v1": 73,"curve": 30.697755646979868,"color": "333945","cMask": ["wall"]},{"v0": 73,"v1": 79,"curve": -87.31123949814534,"color": "333945","cMask": ["wall"]},{"v0": 76,"v1": 82,"curve": 30.697755646979868,"color": "333945","cMask": ["wall"]},{"v0": 72,"v1": 75,"curve": 30.697755646979868,"color": "333945","cMask": ["wall"]},{"v0": 72,"v1": 81,"curve": 77.41690755046625,"color": "333945","cMask": ["wall"]},{"v0": 72,"v1": 78,"curve": 30.697755646979868,"color": "333945","cMask": ["wall"]},{"v0": 72,"v1": 74,"curve": 30.697755646979868,"color": "333945","cMask": ["wall"]},{"v0": 75,"v1": 72,"curve": 30.697755646979868,"color": "333945","cMask": ["wall"]},{"v0": 82,"v1": 72,"curve": 30.697755646979868,"color": "333945","cMask": ["wall"]},{"v0": 83,"v1": 84,"curve": 30.09341366796523,"color": "333945","cMask": ["wall"]},{"v0": 84,"v1": 64,"curve": 30.09341366796523,"color": "333945","cMask": ["wall"]},{"v0": 69,"v1": 64,"curve": 30.09341366796523,"color": "333945","cMask": ["wall"]},{"v0": 69,"v1": 85,"curve": 69.16073107687012,"color": "333945","cMask": ["wall"]},{"v0": 85,"v1": 86,"curve": 30.09341366796523,"color": "333945","cMask": ["wall"]},{"v0": 86,"v1": 88,"curve": 181.43097013701654,"color": "333945","cMask": ["wall"]},{"v0": 89,"v1": 90,"curve": 66.49184618573582,"color": "333945","cMask": ["wall"]},{"v0": 91,"v1": 92,"curve": -48.455490635908575,"color": "333945","cMask": ["wall"]},{"v0": 93,"v1": 62,"curve": -24.958054346304802,"color": "333945","cMask": ["wall"]},{"v0": 83,"v1": 97,"curve": -29.533282419563072,"color": "333945","cMask": ["wall"]},{"v0": 97,"v1": 96,"curve": -55.54437177889409,"color": "333945","cMask": ["wall"]},{"v0": 69,"v1": 88,"color": "333945","cMask": ["wall"]},{"v0": 88,"v1": 96,"curve": 41.710719111983614,"color": "333945","cMask": ["wall"]},{"v0": 72,"v1": 80,"curve": 54.18593425555315,"color": "333945","cMask": ["wall"]},{"v0": 74,"v1": 80,"curve": -44.79426468732674,"color": "333945","cMask": ["wall"]},{"v0": 96,"v1": 98,"curve": 89.5812282216413,"color": "333945","cMask": ["wall"]},{"v0": 98,"v1": 99,"curve": 23.194873783277057,"color": "333945","cMask": ["wall"]},{"v0": 99,"v1": 100,"curve": 53.179295321916406,"color": "333945","cMask": ["wall"]},{"v0": 100,"v1": 101,"curve": -12.796380197087228,"color": "333945","cMask": ["wall"]},{"v0": 101,"v1": 64,"curve": 36.47641528430293,"color": "333945","cMask": ["wall"]},{"v0": 98,"v1": 101,"curve": 45.24940456016575,"color": "333945","cMask": ["wall"]},{"v0": 62,"v1": 102,"curve": -32.735238957707,"color": "333945","cMask": ["wall"]},{"v0": 102,"v1": 96,"curve": -90.29409777379153,"color": "333945","cMask": ["wall"]},{"v0": 103,"v1": 104,"color": "404040","cMask": [],"_data": {"mirror": {},"arc": {"a": [-135.07046388725777,-219.63388138578978],"b": [135.07046388725777,-219.63388138578978],"radius": null,"center": [null,null],"from": null,"to": null}}}],"goals": [{"p0": [-408.79999999999995,-86],"p1": [-408.79999999999995,84],"team": "red"},{"p0": [408.79999999999995,-88],"p1": [408.79999999999995,82],"team": "blue"}],"discs": [{"radius": 5,"invMass": 0,"pos": [-400,-70],"color": "8198A3","bCoef": 1,"cMask": ["all"],"cGroup": ["all"]},{"radius": 5,"invMass": 0,"pos": [-400,70],"color": "8198A3","bCoef": 1,"cMask": ["all"],"cGroup": ["all"]},{"radius": 5,"invMass": 0,"pos": [400,70],"color": "8198A3","bCoef": 1,"cMask": ["all"],"cGroup": ["all"],"x": 400},{"radius": 5,"invMass": 0,"pos": [400,-70],"color": "8198A3","bCoef": 1,"cMask": ["all"],"cGroup": ["all"],"x": 400},{"radius": 6.303288314738697,"pos": [0,-219.63388138578978],"color": "424242","cGroup": [],"_data": {"mirror": {}}},{"radius": 4.502348796241926,"pos": [0,-219.63388138578978],"color": "202020","cGroup": [],"_data": {"mirror": {}}}],"planes": [{"normal": [0,1],"dist": -300,"cMask": ["red","blue"],"_data": {"extremes": {"normal": [0,1],"dist": -300,"canvas_rect": [-1051.6579660800003,-414.9491328000001,1053.0184550400002,416.3096217600001],"a": [-1051.6579660800003,-300],"b": [1053.0184550400002,-300]}}},{"normal": [0,-1],"dist": -300,"cMask": ["red","blue"],"_data": {"extremes": {"normal": [0,-1],"dist": -300,"canvas_rect": [-1051.6579660800003,-414.9491328000001,1053.0184550400002,416.3096217600001],"a": [-1051.6579660800003,300],"b": [1053.0184550400002,300]}}},{"normal": [-1,0],"dist": -705,"cMask": ["red","blue"],"_data": {"extremes": {"normal": [-1,0],"dist": -705,"canvas_rect": [-1051.6579660800003,-414.9491328000001,1053.0184550400002,416.3096217600001],"a": [705,-414.9491328000001],"b": [705,416.3096217600001]}}},{"normal": [0,0],"dist": -705,"cMask": ["red","blue"],"_data": {"extremes": {"normal": [0,0],"dist": -705,"canvas_rect": [-1051.6579660800003,-414.9491328000001,1053.0184550400002,416.3096217600001],"a": [-705,-414.9491328000001],"b": [-705,416.3096217600001]}}},{"normal": [1,0],"dist": -695,"bCoef": 0,"cMask": ["c0"],"_data": {"extremes": {"normal": [1,0],"dist": -695,"canvas_rect": [-1051.6579660800003,-414.9491328000001,1053.0184550400002,416.3096217600001],"a": [-695,-414.9491328000001],"b": [-695,416.3096217600001]}}},{"normal": [-1,0],"dist": -700,"bCoef": 0,"cMask": ["c1"],"_data": {"extremes": {"normal": [-1,0],"dist": -700,"canvas_rect": [-1051.6579660800003,-414.9491328000001,1053.0184550400002,416.3096217600001],"a": [700,-414.9491328000001],"b": [700,416.3096217600001]}}}],"joints": [],"playerPhysics": {"radius": 15,"bCoef": 0,"invMass": 0.5,"damping": 0.96,"cGroup": ["red","blue"],"acceleration": 0.11,"gravity": [0,0],"kickingAcceleration": 0.083,"kickingDamping": 0.96,"kickStrength": 4.2,"kickback": 0},"ballPhysics": {"radius": 5.8,"bCoef": 0.412,"cMask": ["all"],"damping": 0.99,"invMass": 1.5,"gravity": [0,0],"color": "FFA500","cGroup": ["ball"]}}';
const bigMap = '{"name": "FUTsracz3v3","width": 710,"height": 300,"bg": { "width": 600, "height": 270, "color": "425370" },"vertexes": [{ "x": -562.349880025621, "y": -253.0574460115295, "cMask": ["ball"], "_selected": true }, { "x": 562.349880025621, "y": -253.0574460115295, "cMask": ["ball"], "_selected": true }, { "x": -562.349880025621, "y": 253.0574460115295, "cMask": ["ball"], "_selected": true }, { "x": 562.349880025621, "y": 253.0574460115295, "cMask": ["ball"], "_selected": true }, { "x": -562.349880025621, "y": 79.66623300362966, "cMask": ["ball"], "_selected": true }, { "x": -562.349880025621, "y": 253.0574460115295, "cMask": ["ball"], "_selected": true }, { "x": 562.349880025621, "y": 79.66623300362966, "cMask": ["ball"], "_selected": true }, { "x": 562.349880025621, "y": 253.0574460115295, "cMask": ["ball"], "_selected": true }, { "x": -562.349880025621, "y": -253.0574460115295, "cMask": ["ball"], "_selected": true }, { "x": -562.349880025621, "y": -79.66623300362966, "cMask": ["ball"], "_selected": true }, { "x": 562.349880025621, "y": -253.0574460115295, "cMask": ["ball"], "_selected": true }, { "x": 562.349880025621, "y": -79.66623300362966, "cMask": ["ball"], "_selected": true }, { "x": -599.8398720273292, "y": -79.66623300362966, "bCoef": 0.2, "cMask": ["ball"], "cGroup": ["ball"], "_selected": true }, { "x": -562.349880025621, "y": -79.66623300362966, "bCoef": 0.2, "cMask": ["ball"], "cGroup": ["ball"], "_selected": true }, { "x": -599.8398720273292, "y": 79.66623300362966, "bCoef": 0.2, "cMask": ["ball"], "cGroup": ["ball"], "_selected": true }, { "x": -562.349880025621, "y": 79.66623300362966, "bCoef": 0.2, "cMask": ["ball"], "cGroup": ["ball"], "_selected": true }, { "x": -599.8398720273292, "y": -79.66623300362966, "bCoef": 0.2, "cMask": ["ball"], "cGroup": ["ball"], "_selected": true }, { "x": -599.8398720273292, "y": 79.66623300362966, "bCoef": 0.2, "cMask": ["ball"], "cGroup": ["ball"], "_selected": true }, { "x": 599.8398720273292, "y": -79.66623300362966, "bCoef": 0.2, "cMask": ["ball"], "cGroup": ["ball"], "_selected": true }, { "x": 599.8398720273292, "y": 79.66623300362966, "bCoef": 0.2, "cMask": ["ball"], "cGroup": ["ball"], "_selected": true }, { "x": 599.8398720273292, "y": -79.66623300362966, "bCoef": 0.2, "cMask": ["ball"], "cGroup": ["ball"], "_selected": true }, { "x": 562.349880025621, "y": -79.66623300362966, "bCoef": 0.2, "cMask": ["ball"], "cGroup": ["ball"], "_selected": true }, { "x": 599.8398720273292, "y": 79.66623300362966, "bCoef": 0.2, "cMask": ["ball"], "cGroup": ["ball"], "_selected": true }, { "x": 562.349880025621, "y": 79.66623300362966, "bCoef": 0.2, "cMask": ["ball"], "cGroup": ["ball"], "_selected": true }, { "x": -562.349880025621, "y": -79.66623300362966, "cMask": ["wall"], "_selected": true }, { "x": -562.349880025621, "y": 79.66623300362966, "cMask": ["wall"], "_selected": true }, { "x": 562.349880025621, "y": -79.66623300362966, "cMask": ["wall"], "_selected": true }, { "x": 562.349880025621, "y": 79.66623300362966, "cMask": ["wall"], "_selected": true }, { "x": -421.7624100192158, "y": -74.97998400341615, "cMask": ["wall"], "_selected": true }, { "x": -421.7624100192158, "y": 74.97998400341615, "cMask": ["wall"], "_selected": true }, { "x": 0, "y": -281.1749400128105, "cMask": ["red", "blue"], "cGroup": ["redKO", "blueKO"], "_selected": true }, { "x": 0, "y": -74.97998400341615, "cMask": ["red", "blue"], "cGroup": ["redKO", "blueKO"], "_selected": true }, { "x": 0, "y": 74.97998400341615, "cMask": ["red", "blue"], "cGroup": ["redKO", "blueKO"], "_selected": true }, { "x": 0, "y": 281.1749400128105, "cMask": ["red", "blue"], "cGroup": ["redKO", "blueKO"], "_selected": true }, { "x": 0, "y": 74.97998400341615, "cMask": ["red", "blue"], "cGroup": ["blueKO"], "_selected": true }, { "x": 0, "y": -74.97998400341615, "cMask": ["red", "blue"], "cGroup": ["blueKO"], "_selected": true }, { "x": 0, "y": -74.97998400341615, "cMask": ["red", "blue"], "cGroup": ["redKO"], "_selected": true }, { "x": 0, "y": 74.97998400341615, "cMask": ["red", "blue"], "cGroup": ["redKO"], "_selected": true }, { "x": 0, "y": 74.97998400341615, "cMask": ["red", "blue"], "cGroup": ["redKO", "blueKO"], "_selected": true }, { "x": 0, "y": 74.37394102408537, "cMask": ["wall"], "_selected": true }, { "x": 0, "y": 73.96641066137268, "cMask": ["wall"], "_selected": true }, { "x": -562.349880025621, "y": -79.66623300362966, "cMask": ["wall"], "_selected": true }, { "x": -562.349880025621, "y": 79.66623300362966, "cMask": ["wall"], "_selected": true }, { "x": -562.349880025621, "y": -79.66623300362966, "cMask": ["wall"], "_selected": true }, { "x": -562.349880025621, "y": 79.66623300362966, "cMask": ["wall"], "_selected": true }, { "x": 0, "y": -276.48869101259703, "cMask": ["wall"], "_selected": true }, { "x": 0, "y": -74.97998400341615, "cMask": ["wall"], "_selected": true }, { "x": 0, "y": 74.97998400341615, "cMask": ["wall"], "_selected": true }, { "x": 0, "y": 271.80244201238355, "cMask": ["wall"], "_selected": true }, { "x": 0, "y": -75.91723380345884, "cMask": ["wall"], "_selected": true }, { "x": 0, "y": 75.91723380345884, "cMask": ["wall"], "_selected": true }, { "x": 0, "y": 75.91723380345884, "cMask": ["wall"], "_selected": true }, { "x": 0, "y": -75.91723380345884, "cMask": ["wall"], "_selected": true }, { "x": -560.4753804255357, "y": -79.66623300362966, "cMask": ["wall"], "_selected": true }, { "x": -560.4753804255357, "y": 79.66623300362966, "cMask": ["wall"], "_selected": true }, { "x": -564.2243796257065, "y": -79.66623300362966, "cMask": ["wall"], "_selected": true }, { "x": -564.2243796257065, "y": 79.66623300362966, "cMask": ["wall"], "_selected": true }, { "x": 564.2243796257065, "y": -79.66623300362966, "cMask": ["wall"], "_selected": true }, { "x": 564.2243796257065, "y": 79.66623300362966, "cMask": ["wall"], "_selected": true }, { "x": 560.4753804255357, "y": -79.66623300362966, "cMask": ["wall"], "_selected": true }, { "x": 560.4753804255357, "y": 79.66623300362966, "cMask": ["wall"], "_selected": true }, { "x": -562.349880025621, "y": -220.25370301003494, "cMask": ["wall"], "_selected": true }, { "x": -421.7624100192158, "y": -74.97998400341615, "cMask": ["wall"], "_selected": true }, { "x": -421.7624100192158, "y": 74.97998400341615, "cMask": ["wall"], "_selected": true }, { "x": -562.349880025621, "y": 220.25370301003494, "cMask": ["wall"], "_selected": true }, { "x": 421.7624100192158, "y": -74.97998400341615, "cMask": ["wall"], "_selected": true }, { "x": 421.7624100192158, "y": 84.35248200384316, "cMask": ["wall"], "_selected": true }, { "x": 562.349880025621, "y": -220.25370301003494, "cMask": ["wall"], "_selected": true }, { "x": 421.7624100192158, "y": -74.97998400341615, "cMask": ["wall"], "_selected": true }, { "x": 421.7624100192158, "y": 84.35248200384316, "cMask": ["wall"], "_selected": true }, { "x": 562.349880025621, "y": 220.25370301003494, "cMask": ["wall"], "_selected": true }, { "x": -140.58747000640525, "y": -267.11619301217, "cMask": [], "_selected": true }, { "x": 140.58747000640525, "y": -267.11619301217, "cMask": [], "_selected": true }, { "x": 8.801998122140159, "y": -10.56239774656819, "cMask": ["wall"], "color": "333945", "_selected": true }, { "x": 11.090298479149194, "y": 23.02783955448034, "cMask": ["wall"], "_selected": true }, { "x": -30.344814863966246, "y": 8.30155021869531, "cMask": ["wall"], "_selected": true }, { "x": -33.15419292672793, "y": 4.400999061070079, "cMask": ["wall"], "_selected": true }, { "x": -40.19579142444005, "y": 1.1735997496186878, "cMask": ["wall"], "_selected": true }, { "x": -45.444678924874914, "y": -28.56836436500448, "cMask": ["wall"], "_selected": true }, { "x": -44.890190422914806, "y": -51.05158910841291, "cMask": ["wall"], "_selected": true }, { "x": -18.777595993899006, "y": -59.26678735574373, "cMask": ["wall"], "_selected": true }, { "x": -27.704215427324204, "y": -0.7133838443990667, "cMask": ["wall"], "_selected": true }, { "x": 9.798596948713323, "y": -10.614087748161344, "cMask": ["wall"], "_selected": true }, { "x": -6.748198560307455, "y": -60.73378704276709, "cMask": ["wall"], "_selected": true }, { "x": 10.13537112186974, "y": -4.270489774870993, "cMask": ["wall"], "color": "333945", "_selected": true }, { "x": 31.88027701408989, "y": 8.096675579245238, "cMask": ["wall"], "curve": 30.697755646979868, "_selected": true }, { "x": -18.08678022298303, "y": 3.043516666123561, "cMask": ["wall"], "curve": 30.697755646979868, "_selected": true }, { "x": 3.7680792131214647, "y": 9.043390111491515, "cMask": ["wall"], "curve": 30.697755646979868, "_selected": true }, { "x": 24.618117525726902, "y": 10.5506217967401, "cMask": ["wall"], "curve": 30.697755646979868, "_selected": true }, { "x": -11.05303235848963, "y": 3.0144633704971713, "cMask": ["wall"], "_selected": true }, { "x": -6.028926740994343, "y": 6.280132021869107, "cMask": ["wall"], "curve": 30.697755646979868, "_selected": true }, { "x": 9.545800673241043, "y": 8.289774268867221, "cMask": ["wall"], "curve": 30.697755646979868, "_selected": true }, { "x": 32.39922159422338, "y": 7.507105130616537, "cMask": ["wall"], "curve": 30.697755646979868, "color": "333945", "_selected": true }, { "x": 13.284826590736117, "y": 10.141630760490958, "cMask": ["wall"], "curve": 30.697755646979868, "_selected": true }, { "x": 1.3494459298742054, "y": 6.525077664122656, "cMask": ["wall"], "curve": 30.697755646979868, "_selected": true }, { "x": 20.675182536481543, "y": 16.93815422177215, "cMask": ["wall"], "curve": 85.827862608012, "_selected": true }, { "x": -26.878965053599785, "y": 6.782542583618636, "cMask": ["wall"], "_selected": true }, { "x": -38.18320269296417, "y": -22.357269997854022, "cMask": ["wall"], "_selected": true }, { "x": -30.39583898584648, "y": -45.97056640008187, "cMask": ["wall"], "_selected": true }, { "x": -0.25120528087476435, "y": -55.01395651157338, "cMask": ["wall"], "_selected": true }, { "x": 9.049649750112728, "y": -11.721733211714456, "cMask": ["wall"], "_selected": true }, { "x": -29.642223143222186, "y": -47.72900336620521, "cMask": ["wall"], "_selected": true }, { "x": -44.46333471483327, "y": -49.98985089407811, "cMask": ["wall"], "_selected": true }, { "x": -45.97056640008186, "y": -45.71936111920711, "cMask": ["wall"], "_selected": true }, { "x": -31.149454828470777, "y": -42.70489774870993, "cMask": ["wall"], "_selected": true }, { "x": -31.194071495227412, "y": 11.28220500583118, "cMask": ["wall"], "_selected": true }, { "x": -17.584369661233502, "y": 12.057853481988685, "cMask": ["wall"], "_selected": true }, { "x": 26.62775977272502, "y": 15.574727414235385, "cMask": ["wall"], "_selected": true }, { "x": 39.449970134055704, "y": 7.612367831335804, "cMask": ["wall"], "_selected": true }, { "x": 37.078119816874896, "y": 12.750716002429078, "cMask": ["wall"], "_selected": true }, { "x": 24.00794251131838, "y": 37.449964159019785, "cMask": ["wall"], "_selected": true }, { "x": 23.491832401290957, "y": 53.589984490870975, "cMask": ["wall"], "_selected": true }, { "x": -19.98823876975864, "y": 48.64999466636703, "cMask": ["wall"], "_selected": true }, { "x": -20.677488382508944, "y": 29.637733348262817, "cMask": ["wall"], "_selected": true }, { "x": 32.15762993247792, "y": 20.098518707798696, "cMask": ["wall"], "_selected": true }], "segments": [{ "v0": 0, "v1": 1, "color": "717F98", "cMask": ["ball"], "bias": -10, "_selected": true }, { "v0": 2, "v1": 3, "color": "717F98", "cMask": ["ball"], "bias": 10, "_selected": true }, { "v0": 4, "v1": 5, "color": "717F98", "cMask": ["ball"], "bias": 10, "_selected": true }, { "v0": 6, "v1": 7, "color": "717F98", "cMask": ["ball"], "bias": -10, "_selected": true }, { "v0": 8, "v1": 9, "color": "717F98", "cMask": ["ball"], "bias": 10, "_selected": true }, { "v0": 10, "v1": 11, "color": "717F98", "cMask": ["ball"], "bias": -10, "_selected": true }, { "v0": 12, "v1": 13, "color": "717F98", "bCoef": 0.2, "cMask": ["ball"], "cGroup": ["ball"], "bias": -10, "_selected": true }, { "v0": 14, "v1": 15, "color": "717F98", "bCoef": 0.2, "cMask": ["ball"], "cGroup": ["ball"], "bias": 10, "_selected": true }, { "v0": 17, "v1": 16, "curve": 35, "color": "717F98", "bCoef": 0.2, "cMask": ["ball"], "cGroup": ["ball"], "bias": -10, "curveF": 3.1715948023632126, "_selected": true }, { "v0": 18, "v1": 19, "curve": 35, "color": "717F98", "bCoef": 0.2, "cMask": ["ball"], "cGroup": ["ball"], "bias": -10, "curveF": 3.1715948023632126, "_selected": true }, { "v0": 20, "v1": 21, "color": "717F98", "bCoef": 0.2, "cMask": ["ball"], "cGroup": ["ball"], "bias": 10, "_selected": true }, { "v0": 22, "v1": 23, "color": "717F98", "bCoef": 0.2, "cMask": ["ball"], "cGroup": ["ball"], "bias": -10, "_selected": true }, { "v0": 24, "v1": 25, "color": "757FD0", "cMask": ["wall"], "_selected": true }, { "v0": 26, "v1": 27, "color": "757FD0", "cMask": ["wall"], "_selected": true }, { "v0": 28, "v1": 29, "color": "2B3548", "cMask": ["wall"], "_selected": true }, { "v0": 30, "v1": 31, "vis": false, "color": "A3A3A3", "cMask": ["red", "blue"], "cGroup": ["redKO", "blueKO"], "_selected": true }, { "v0": 32, "v1": 33, "vis": false, "color": "A3A3A3", "cMask": ["red", "blue"], "cGroup": ["redKO", "blueKO"], "_selected": true }, { "v0": 34, "v1": 35, "curve": 180, "vis": false, "color": "A1524", "cMask": ["red", "blue"], "cGroup": ["blueKO"], "curveF": 6.123233995736766e-17, "_selected": true }, { "v0": 36, "v1": 37, "curve": 180, "vis": false, "color": "A1524", "cMask": ["red", "blue"], "cGroup": ["redKO"], "curveF": 6.123233995736766e-17, "_selected" : true }, { "v0": 45, "v1": 46, "color": "454866", "cMask": ["wall"], "_selected": true }, { "v0": 47, "v1": 48, "color": "454866", "cMask": ["wall"], "_selected": true }, { "v0": 49, "v1": 50, "curve": 180, "color": "454866", "cMask": ["wall"], "curveF": 6.123233995736766e-17, "_selected": true }, { "v0": 51, "v1": 52, "curve": 180, "color": "454866", "cMask": ["wall"], "curveF": 6.123233995736766e-17, "_selected": true }, { "v0": 53, "v1": 54, "color": "1B2332", "cMask": ["wall"], "_selected": true }, { "v0": 55, "v1": 56, "color": "1B2332", "cMask": ["wall"], "_selected": true }, { "v0": 57, "v1": 58, "color": "1B2332", "cMask": ["wall"], "_selected": true }, { "v0": 59, "v1": 60, "color": "1B2332", "cMask": ["wall"], "_selected": true }, { "v0": 61, "v1": 62, "curve": 80.00000000000001, "color": "2B3548", "cMask": ["wall"], "curveF": 1.19175359259421, "_selected": true }, { "v0": 63, "v1": 64, "curve": 80.00000000000001, "color": "2B3548", "cMask": ["wall"], "curveF": 1.19175359259421, "_selected": true }, { "v0": 65, "v1": 66, "color": "2B3548", "cMask": ["wall"], "_selected": true }, { "v0": 68, "v1": 67, "curve": 80.00000000000001, "color": "2B3548", "cMask": ["wall"], "curveF": 1.19175359259421, "_selected": true }, { "v0": 70, "v1": 69, "curve": 80.00000000000001, "color": "2B3548", "cMask": ["wall"], "curveF": 1.19175359259421, "_selected": true }, { "v0": 71, "v1": 72, "color": "404040", "cMask": [], "_selected": true }, { "v0": 75, "v1": 76, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 76, "v1": 77, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 77, "v1": 78, "curve": 16.850696324072082, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 78, "v1": 79, "curve": 3.161798573766408, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 79, "v1": 80, "curve": 8.325843170237832, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 82, "v1": 83, "curve": -97.52517012489479, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 83, "v1": 80, "curve": -19.564814063614712, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 84, "v1": 85, "curve": 17.697755646979868, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 86, "v1": 84, "curve": 8.609687752906625, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 86, "v1": 87, "curve": -16.639174997709674, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 87, "v1": 88, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 88, "v1": 85, "curve": -27.922367075409877, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 84, "v1": 85, "curve": 17.697755646979868, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 89, "v1": 84, "curve": 17.697755646979868, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 89, "v1": 84, "curve": 17.697755646979868, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 90, "v1": 84, "curve": 17.697755646979868, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 90, "v1": 84, "curve": 17.697755646979868, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 87, "v1": 84, "curve": 17.697755646979868, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 91, "v1": 84, "curve": 17.697755646979868, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 88, "v1": 84, "curve": 17.697755646979868, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 85, "v1": 84, "curve": 17.697755646979868, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 92, "v1": 84, "curve": 17.697755646979868, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 93, "v1": 84, "curve": 17.697755646979868, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 94, "v1": 84, "curve": 17.697755646979868, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 86, "v1": 94, "curve": 30.697755646979868, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 86, "v1": 87, "curve": 30.697755646979868, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 86, "v1": 91, "curve": 30.697755646979868, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 90, "v1": 93, "curve": 30.697755646979868, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 94, "v1": 88, "curve": 30.697755646979868, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 94, "v1": 92, "curve": 68.3953665340623, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 91, "v1": 85, "curve": 30.697755646979868, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 85, "v1": 91, "curve": -87.31123949814534, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 88, "v1": 94, "curve": 30.697755646979868, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 84, "v1": 87, "curve": 30.697755646979868, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 84, "v1": 93, "curve": 77.41690755046625, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 84, "v1": 90, "curve": 30.697755646979868, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 84, "v1": 86, "curve": 30.697755646979868, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 87, "v1": 84, "curve": 30.697755646979868, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 94, "v1": 84, "curve": 30.697755646979868, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 95, "v1": 96, "curve": 30.09341366796523, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 96, "v1": 76, "curve": 30.09341366796523, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 81, "v1": 76, "curve": 30.09341366796523, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 81, "v1": 97, "curve": 69.16073107687012, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 97, "v1": 98, "curve": 30.09341366796523, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 98, "v1": 100, "curve": 181.43097013701654, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 101, "v1": 102, "curve": 66.49184618573582, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 103, "v1": 104, "curve": -48.455490635908575, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 105, "v1": 74, "curve": -24.958054346304802, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 95, "v1": 109, "curve": -29.533282419563072, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 109, "v1": 108, "curve": -55.54437177889409, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 81, "v1": 100, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 100, "v1": 108, "curve": 41.710719111983614, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 84, "v1": 92, "curve": 54.18593425555315, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 86, "v1": 92, "curve": -44.79426468732674, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 108, "v1": 110, "curve": 89.5812282216413, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 110, "v1": 111, "curve": 23.194873783277057, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 111, "v1": 112, "curve": 53.179295321916406, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 112, "v1": 113, "curve": -12.796380197087228, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 113, "v1": 76, "curve": 36.47641528430293, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 110, "v1": 113, "curve": 45.24940456016575, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 74, "v1": 114, "curve": -32.735238957709, "color": "333945", "cMask": ["wall"], "_selected": true }, { "v0": 114, "v1": 108, "curve": -90.29409777379153, "color": "333945", "cMask": ["wall"], "_selected": true }], "goals": [{ "p0": [-570.5976782659968, -79.66623300362966], "p1": [-570.5976782659968, 79.66623300362966], "team": "red", "_selected": true }, { "p0": [570.5976782659968, -79.66623300362966], "p1": [570.5976782659968, 79.66623300362966], "team": "blue", "_selected": true }], "discs": [{ "radius": 4.686249000213509, "invMass": 0, "pos": [-562.349880025621, -79.66623300362966], "color": "FF8080", "bCoef": 1, "_selected": true }, { "radius": 4.686249000213509, "invMass": 0, "pos": [-562.349880025621, 79.66623300362966], "color": "FF8080", "bCoef": 1, "_selected": true }, { "radius": 4.686249000213509, "invMass": 0, "pos": [562.349880025621, 79.66623300362966], "color": "80BFFF", "bCoef": 1, "_selected": true }, { "radius": 4.686249000213509, "invMass": 0, "pos": [562.349880025621, -79.66623300362966], "color": "80BFFF", "bCoef": 1, "_selected": true }, { "radius": 6.560748600298913, "pos": [0, -267.11619301217], "color": "424242", "cGroup": [], "_selected": true }, { "radius": 4.686249000213509, "pos": [0, -267.11619301217], "color": "202020", "cGroup": [], "_selected": true }, { "radius": 8.435248200384315, "pos": [937.2498000427018, -267.11619301217], "color": "DEDEDE", "cGroup": [], "_selected": true }], "playerPhysics": { "bCoef": 0, "acceleration": 0.125, "kickingAcceleration": 0.0833, "kickStrength": 4.3, "radius": 15, "invMass": 0.5, "damping": 0.96, "cGroup": ["red", "blue"], "gravity": [0, 0], "kickingDamping": 0.92, "kickback": 0 }, "ballPhysics": { "radius": 5.8, "bCoef": 0.43, "damping": 0.989, "invMass": 1.6, "gravity": [0, 0], "color": "FFA500", "cMask": ["all"], "cGroup": ["ball"] }, "spawnDistance": 150, "redSpawnPoints": [[-200, 0], [-250, 100], [-250, -100], [-300, 200], [-300, -200]], "blueSpawnPoints": [[200, 0], [250, 100], [250, -100], [300, 200], [300, -200]], "kickOffReset": "full", "traits": {}, "joints": [], "cameraWidth": 0, "cameraHeight": 0, "maxViewWidth": 0, "cameraFollow": "ball", "canBeStored": true }';
var currentStadium = 'classic';
var bigMapObj = JSON.parse(trainingMap);

room.setScoreLimit(scoreLimit);
room.setTimeLimit(timeLimit);
room.setTeamsLock(true);
room.setKickRateLimit(6, 0, 0);

var masterPassword = "sra";
var roomPassword = '';

/* OPTIONS */

var drawTimeLimit = 1;
var teamSize = 3;
var maxAdmins = 0;
var disableBans = false;
var debugMode = false;
var afkLimit = debugMode ? Infinity : 12;

var defaultSlowMode = 0.5;
var chooseModeSlowMode = 1;
var slowMode = defaultSlowMode;
var SMSet = new Set();

var hideClaimMessage = true;
var mentionPlayersUnpause = true;

/* OBJECTS */

class Goal {
    constructor(time, team, striker, assist) {
        this.time = time;
        this.team = team;
        this.striker = striker;
        this.assist = assist;
    }
}

class Game {
    constructor() {
        this.date = Date.now();
        this.scores = room.getScores();
        this.playerComp = getStartingLineups();
        this.goals = [];
        this.rec = room.startRecording();
        this.touchArray = [];
    }
}

class PlayerComposition {
    constructor(player, auth, timeEntry, timeExit) {
        this.player = player;
        this.auth = auth;
        this.timeEntry = timeEntry;
        this.timeExit = timeExit;
        this.inactivityTicks = 0;
        this.GKTicks = 0;
    }
}

class MutePlayer {
    constructor(name, id, auth) {
        this.id = MutePlayer.incrementId();
        this.name = name;
        this.playerId = id;
        this.auth = auth;
        this.unmuteTimeout = null;
    }

    static incrementId() {
        if (!this.latestId) this.latestId = 1
        else this.latestId++
        return this.latestId
    }

    setDuration(minutes) {
        this.unmuteTimeout = setTimeout(() => {
            room.sendAnnouncement(
                `MoÅ¼esz gadaÄ‡.`,
                this.playerId,
                announcementColor,
                "bold",
                HaxNotification.CHAT
            );
            this.remove();
        }, minutes * 60 * 1000);
        muteArray.add(this);
    }

    remove() {
        this.unmuteTimeout = null;
        muteArray.removeById(this.id);
    }
}

class MuteList {
    constructor() {
        this.list = [];
    }

    add(mutePlayer) {
        this.list.push(mutePlayer);
        return mutePlayer;
    }

    getById(id) {
        var index = this.list.findIndex(mutePlayer => mutePlayer.id === id);
        if (index !== -1) {
            return this.list[index];
        }
        return null;
    }

    getByPlayerId(id) {
        var index = this.list.findIndex(mutePlayer => mutePlayer.playerId === id);
        if (index !== -1) {
            return this.list[index];
        }
        return null;
    }

    getByAuth(auth) {
        var index = this.list.findIndex(mutePlayer => mutePlayer.auth === auth);
        if (index !== -1) {
            return this.list[index];
        }
        return null;
    }

    removeById(id) {
        var index = this.list.findIndex(mutePlayer => mutePlayer.id === id);
        if (index !== -1) {
            this.list.splice(index, 1);
        }
    }

    removeByAuth(auth) {
        var index = this.list.findIndex(mutePlayer => mutePlayer.auth === auth);
        if (index !== -1) {
            this.list.splice(index, 1);
        }
    }
}

class BallTouch {
    constructor(player, time, goal, position) {
        this.player = player;
        this.time = time;
        this.goal = goal;
        this.position = position;
    }
}

class HaxStatistics {
    constructor(playerName = '') {
        this.playerName = playerName;
        this.games = 0;
        this.wins = 0;
        this.losses = 0;
        this.winrate = '0.00%';
        this.playtime = 0;
        this.goals = 0;
        this.assists = 0;
        this.CS = 0;
        this.ownGoals = 0;
    }
}

/* PLAYERS */
let elo = {}; // elo[player.name] = rating
const baseElo = 1000;
const eloK = 25;

const Team = { SPECTATORS: 0, RED: 1, BLUE: 2 };
const State = { PLAY: 0, PAUSE: 1, STOP: 2 };
const Role = { PLAYER: 0, ADMIN_TEMP: 1, ADMIN_PERM: 2, MASTER: 3 };
const HaxNotification = { NONE: 0, CHAT: 1, MENTION: 2 };
const Situation = { STOP: 0, KICKOFF: 1, PLAY: 2, GOAL: 3 };

var gameState = State.STOP;
var playSituation = Situation.STOP;
var goldenGoal = false;

var playersAll = [];
var players = [];
var teamRed = [];
var teamBlue = [];
var teamSpec = [];
var fullTeamsAutoRestarted = false; // prevent repeated auto restarts once 3v3 is active

var teamRedStats = [];
var teamBlueStats = [];

let banList = [];

const VOLUNTARY_LEAVE_MESSAGE = 'Do zobaczenia ponownie! Zapraszamy na Discord! https://discord.gg/HBabx8b93k';
const voluntaryLeaveIds = new Set();
const BAN_MAX_DURATION_MS = 7 * 24 * 60 * 60 * 1000;
const BAN_DURATION_BASE = {
    '1m': 1 * 60 * 1000,
    '5m': 5 * 60 * 1000,
    '30m': 30 * 60 * 1000,
    '1h': 60 * 60 * 1000,
    '5h': 5 * 60 * 60 * 1000,
    '24h': 24 * 60 * 60 * 1000,
    '48h': 48 * 60 * 60 * 1000,
    '7d': 7 * 24 * 60 * 60 * 1000,
};
const BAN_DURATION_LABELS = {
    '1m': '1 minute',
    '5m': '5 minut',
    '30m': '30 minut',
    '1h': '1 godzine',
    '5h': '5 godzin',
    '24h': '24 godziny',
    '48h': '48 godzin',
    '7d': '7 dni',
};
const BAN_DURATION_ALIASES = {
    '1min': '1m',
    '5min': '5m',
    '30min': '30m',
    '1hr': '1h',
    '5hr': '5h',
    '24hr': '24h',
    '48hr': '48h',
    '1w': '7d',
    '7dni': '7d',
    'tydzien': '7d',
};
const BAN_ALLOWED_TOKENS = Object.keys(BAN_DURATION_BASE);
const BAN_DYNAMIC_HELP = ' (np. 90m / 3600s / 2h / 1d; brak litery = minuty; max 7d)';
const timedBanTasks = new Map();
const BAN_KEY_PREFIX_AUTH = 'auth:';
const BAN_KEY_PREFIX_ID = 'id:';
const BAN_STORAGE_KEY = '__banState';
const BAN_UNIT_MULTIPLIERS = {
    s: 1000,
    m: 60 * 1000,
    h: 60 * 60 * 1000,
    d: 24 * 60 * 60 * 1000,
};

function formatBanDurationLabel(ms) {
    if (!Number.isFinite(ms) || ms <= 0) return '0s';
    let remainingSeconds = Math.round(ms / 1000);
    const parts = [];
    const days = Math.floor(remainingSeconds / 86400);
    remainingSeconds -= days * 86400;
    const hours = Math.floor(remainingSeconds / 3600);
    remainingSeconds -= hours * 3600;
    const minutes = Math.floor(remainingSeconds / 60);
    remainingSeconds -= minutes * 60;
    const seconds = remainingSeconds;
    if (days) parts.push(days + 'd');
    if (hours) parts.push(hours + 'h');
    if (minutes) parts.push(minutes + 'm');
    if (parts.length === 0 && seconds) parts.push(seconds + 's');
    else if (seconds && parts.length < 2) parts.push(seconds + 's');
    return parts.slice(0, 3).join(' ');
}

function serializeBanRecordForStorage(record) {
    if (!record || typeof record !== 'object') return null;
    const serialized = {
        key: typeof record.key === 'string' ? record.key : null,
        auth: typeof record.auth === 'string' ? record.auth : null,
        id: typeof record.id === 'number' && isFinite(record.id) ? record.id : null,
        name: typeof record.name === 'string' ? record.name : '',
        adminName: typeof record.adminName === 'string' ? record.adminName : '',
        createdAt: typeof record.createdAt === 'number' && isFinite(record.createdAt) ? record.createdAt : Date.now(),
        expiresAt: typeof record.expiresAt === 'number' && isFinite(record.expiresAt) ? record.expiresAt : null,
        durationMs: typeof record.durationMs === 'number' && isFinite(record.durationMs) ? record.durationMs : null,
        durationKey: typeof record.durationKey === 'string' ? record.durationKey : null,
        durationLabel: typeof record.durationLabel === 'string' ? record.durationLabel : null,
        reason: typeof record.reason === 'string' ? record.reason : '',
        offline: !!record.offline
    };
    if (!serialized.key) return null;
    return serialized;
}

function sanitizeBanListForStorage(list) {
    if (!Array.isArray(list)) return [];
    const sanitized = [];
    for (let i = 0; i < list.length; i++) {
        const entry = list[i];
        if (!entry) continue;
        if (Array.isArray(entry) && entry.length >= 2) {
            const key = typeof entry[1] === 'string' ? entry[1] : String(entry[1] || '');
            if (!key) continue;
            const name = typeof entry[0] === 'string' ? entry[0] : '';
            sanitized.push([name, key]);
        } else if (typeof entry === 'object') {
            const key = typeof entry.key === 'string' ? entry.key : '';
            if (!key) continue;
            const name = typeof entry.name === 'string' ? entry.name : '';
            sanitized.push([name, key]);
        }
    }
    return sanitized;
}

function persistBanState() {
    try {
        if (typeof localStorage === 'undefined' || typeof localStorage.setItem !== 'function') return;
        const payload = {
            banList: sanitizeBanListForStorage(banList),
            records: []
        };
        const now = Date.now();
        timedBanTasks.forEach(function (record) {
            const serialized = serializeBanRecordForStorage(record);
            if (!serialized) return;
            if (serialized.expiresAt != null && serialized.expiresAt <= now) return;
            payload.records.push(serialized);
        });
        localStorage.setItem(BAN_STORAGE_KEY, JSON.stringify(payload));
    } catch (_) {}
}

function reinstateStoredBanRecord(data, now) {
    if (!data || typeof data !== 'object') return false;
    const key = typeof data.key === 'string' ? data.key : null;
    if (!key) return false;
    const expiresAt = typeof data.expiresAt === 'number' && isFinite(data.expiresAt) ? data.expiresAt : null;
    if (expiresAt != null && expiresAt <= now) return false;
    const record = {
        key: key,
        auth: typeof data.auth === 'string' ? data.auth : null,
        id: typeof data.id === 'number' && isFinite(data.id) ? data.id : null,
        name: typeof data.name === 'string' && data.name.length ? data.name : (typeof data.auth === 'string' ? data.auth : key),
        adminName: typeof data.adminName === 'string' && data.adminName.length ? data.adminName : 'admin',
        createdAt: typeof data.createdAt === 'number' && isFinite(data.createdAt) ? data.createdAt : now,
        expiresAt: expiresAt != null ? expiresAt : now,
        durationMs: typeof data.durationMs === 'number' && isFinite(data.durationMs) ? data.durationMs : null,
        durationKey: typeof data.durationKey === 'string' ? data.durationKey : null,
        durationLabel: typeof data.durationLabel === 'string' ? data.durationLabel : null,
        reason: typeof data.reason === 'string' ? data.reason : '',
        offline: !!data.offline,
        timeoutId: null
    };
    if (expiresAt != null) {
        const remaining = Math.max(0, expiresAt - now);
        record.timeoutId = setTimeout(function () {
            clearTimedBan(record.key, { source: 'timer' });
        }, remaining);
    }
    timedBanTasks.set(record.key, record);
    let existingIndex = -1;
    for (let i = 0; i < banList.length; i++) {
        if (banList[i] && banList[i][1] === record.key) {
            existingIndex = i;
            break;
        }
    }
    if (existingIndex === -1) {
        banList.push([record.name, record.key]);
    } else if (typeof record.name === 'string' && record.name.length) {
        banList[existingIndex][0] = record.name;
    }
    return true;
}

function loadStoredBanState() {
    let loaded = false;
    const expiredKeys = new Set();
    try {
        if (typeof localStorage === 'undefined' || typeof localStorage.getItem !== 'function') return;
        const raw = localStorage.getItem(BAN_STORAGE_KEY);
        if (!raw) return;
        loaded = true;
        const parsed = JSON.parse(raw);
        if (parsed && Array.isArray(parsed.banList)) {
            banList = sanitizeBanListForStorage(parsed.banList);
        }
        const now = Date.now();
        if (parsed && Array.isArray(parsed.records)) {
            for (let i = 0; i < parsed.records.length; i++) {
                const entry = parsed.records[i];
                const reinstated = reinstateStoredBanRecord(entry, now);
                if (!reinstated && entry && typeof entry.key === 'string') {
                    expiredKeys.add(entry.key);
                }
            }
        }
        if (expiredKeys.size > 0 && Array.isArray(banList) && banList.length > 0) {
            banList = banList.filter(function (entry) {
                return entry && !expiredKeys.has(entry[1]);
            });
        }
    } catch (_) {
        return;
    }
    if (loaded) {
        persistBanState();
    }
}

loadStoredBanState();

function getBanDurationInfo(token) {
    if (!token) return null;
    var normalized = token.trim().toLowerCase();
    if (!normalized) return null;
    if (BAN_DURATION_BASE.hasOwnProperty(normalized)) {
        return {
            key: normalized,
            ms: BAN_DURATION_BASE[normalized],
            label: BAN_DURATION_LABELS[normalized] || formatBanDurationLabel(BAN_DURATION_BASE[normalized]),
        };
    }
    if (BAN_DURATION_ALIASES.hasOwnProperty(normalized)) {
        var alias = BAN_DURATION_ALIASES[normalized];
        if (BAN_DURATION_BASE.hasOwnProperty(alias)) {
            var baseMs = BAN_DURATION_BASE[alias];
            return {
                key: alias,
                ms: baseMs,
                label: BAN_DURATION_LABELS[alias] || formatBanDurationLabel(baseMs),
            };
        }
    }
    var pattern = /(\d+(?:[.,]\d+)?)([a-z]*)/g;
    var totalMs = 0;
    var lastIndex = 0;
    var match = null;
    while ((match = pattern.exec(normalized)) !== null) {
        if (match.index !== lastIndex) {
            return null;
        }
        lastIndex = pattern.lastIndex;
        var numericPartRaw = match[1];
        var unitPartRaw = match[2] || '';
        var numericValue = parseFloat(numericPartRaw.replace(',', '.'));
        if (!Number.isFinite(numericValue) || numericValue <= 0) return null;
        var unitChar = unitPartRaw.length > 0 ? unitPartRaw[0] : '';
        if (unitChar) {
            unitChar = unitChar.toLowerCase();
        }
        if (!unitChar) unitChar = 'm';
        var multiplier = BAN_UNIT_MULTIPLIERS[unitChar];
        if (!multiplier) return null;
        var increment = Math.round(numericValue * multiplier);
        if (!Number.isFinite(increment) || increment <= 0) return null;
        totalMs += increment;
        if (totalMs > BAN_MAX_DURATION_MS) return null;
    }
    if (lastIndex !== normalized.length || totalMs <= 0) return null;
    return {
        key: normalized,
        ms: totalMs,
        label: formatBanDurationLabel(totalMs),
    };
}

function registerTimedBan(targetPlayer, adminPlayer, durationInfo, reasonText, extra) {
    extra = extra || {};
    if ((!targetPlayer && !extra.targetName) || !durationInfo) return null;
    var targetAuth = extra.targetAuth;
    if (!targetAuth && targetPlayer) {
        try {
            targetAuth = getPlayerAuth(targetPlayer);
        } catch (_){}
    }
    var banKey = extra.banKey;
    if (!banKey) {
        if (targetAuth) {
            banKey = BAN_KEY_PREFIX_AUTH + targetAuth;
        } else if (targetPlayer && typeof targetPlayer.id !== 'undefined') {
            banKey = BAN_KEY_PREFIX_ID + String(targetPlayer.id);
        } else if (extra.fallbackKey) {
            banKey = extra.fallbackKey;
        } else {
            return null;
        }
    }
    var existing = timedBanTasks.get(banKey);
    if (existing && existing.timeoutId) {
        clearTimeout(existing.timeoutId);
    }
    var now = Date.now();
    var record = {
        key: banKey,
        auth: targetAuth || null,
        id: targetPlayer && typeof targetPlayer.id !== 'undefined' ? targetPlayer.id : null,
        name: (targetPlayer && targetPlayer.name) || extra.targetName || (targetAuth ? targetAuth : banKey),
        adminName: adminPlayer && adminPlayer.name ? adminPlayer.name : 'admin',
        createdAt: now,
        expiresAt: now + durationInfo.ms,
        durationMs: durationInfo.ms,
        durationKey: durationInfo.key,
        durationLabel: durationInfo.label,
        reason: reasonText || '',
        offline: !!extra.offline,
        timeoutId: null,
    };
    record.timeoutId = setTimeout(function () {
        clearTimedBan(banKey, { source: 'timer' });
    }, durationInfo.ms);
    timedBanTasks.set(banKey, record);
    persistBanState();
    return record;
}

function clearTimedBan(banKey, options) {
    var record = timedBanTasks.get(banKey);
    if (!record) return;
    timedBanTasks.delete(banKey);
    if (record.timeoutId) {
        clearTimeout(record.timeoutId);
        record.timeoutId = null;
    }
    if (!options || options.performRoomClear !== false) {
        try {
            if (record.id != null) {
                room.clearBan(record.id);
            }
        } catch (_) {}
    }
    banList = banList.filter(function (entry) {
        return entry && entry[1] !== banKey;
    });
    persistBanState();
    if (!options || options.notify !== false) {
        try {
            var baseMsg = `Ban gracza ${record.name} wygasl.`;
            if (options && options.source === 'timer') {
                baseMsg = `Ban gracza ${record.name} wygasl automatycznie.`;
            }
            room.sendAnnouncement(baseMsg, null, announcementColor, 'bold', HaxNotification.CHAT);
        } catch (_) {}
    }
}

function formatBanRemaining(record) {
    if (!record || typeof record.expiresAt !== 'number') return '';
    var now = Date.now();
    var remainingMs = record.expiresAt - now;
    if (!Number.isFinite(remainingMs) || remainingMs <= 0) return '0s';
    var totalSeconds = Math.floor(remainingMs / 1000);
    var days = Math.floor(totalSeconds / 86400);
    totalSeconds -= days * 86400;
    var hours = Math.floor(totalSeconds / 3600);
    totalSeconds -= hours * 3600;
    var minutes = Math.floor(totalSeconds / 60);
    var parts = [];
    if (days > 0) parts.push(days + 'd');
    if (hours > 0) parts.push(hours + 'h');
    if (minutes > 0 && parts.length < 2) parts.push(minutes + 'm');
    if (parts.length === 0) {
        var seconds = Math.max(1, totalSeconds);
        parts.push(seconds + 's');
    }
    return parts.slice(0, 2).join(' ');
}

function banKeyFromAuth(auth) {
    if (!auth) return null;
    return BAN_KEY_PREFIX_AUTH + auth;
}

function banKeyFromId(id) {
    if (id == null) return null;
    return BAN_KEY_PREFIX_ID + String(id);
}

function recordKnownPlayer(player) {
    if (!player) return;
    var auth = null;
    try {
        auth = getPlayerAuth(player);
    } catch (_){}
    if (!auth) return;
    var previous = knownPlayersByAuth[auth] || {};
    knownPlayersByAuth[auth] = {
        name: player.name || previous.name || auth,
        lastSeen: Date.now(),
        lastId: player.id,
        conn: getPlayerConn(player) || previous.conn || null
    };
}

function getKnownPlayerByAuth(auth) {
    if (!auth) return null;
    return knownPlayersByAuth[auth] || null;
}

function findKnownPlayerByLastId(id) {
    if (id == null) return null;
    for (var auth in knownPlayersByAuth) {
        if (!Object.prototype.hasOwnProperty.call(knownPlayersByAuth, auth)) continue;
        var entry = knownPlayersByAuth[auth];
        if (entry && entry.lastId === id) {
            return { auth: auth, info: entry };
        }
    }
    return null;
}

function resolveBanKeyFromToken(token) {
    if (!token) return null;
    var trimmed = token.trim();
    if (trimmed.length === 0) return null;
    if (trimmed[0] === '#') {
        trimmed = trimmed.substring(1);
    } else if (trimmed.startsWith('@')) {
        trimmed = BAN_KEY_PREFIX_AUTH + trimmed.substring(1);
        return trimmed;
    }
    if (trimmed.startsWith('auth:')) {
        return BAN_KEY_PREFIX_AUTH + trimmed.substring(5);
    }
    if (trimmed.startsWith(BAN_KEY_PREFIX_AUTH) || trimmed.startsWith(BAN_KEY_PREFIX_ID)) {
        return trimmed;
    }
    if (/^\d+$/.test(trimmed)) {
        return BAN_KEY_PREFIX_ID + trimmed;
    }
    if (/^[A-Za-z0-9_-]{10,}$/.test(trimmed)) {
        return BAN_KEY_PREFIX_AUTH + trimmed;
    }
    return null;
}

function enforceActiveBanOnJoin(player) {
    try {
        var auth = getPlayerAuth(player);
        if (!auth) return false;
        var key = banKeyFromAuth(auth);
        if (!key) return false;
        var record = timedBanTasks.get(key);
        if (!record) return false;
        record.name = player.name || record.name || auth;
        record.id = player.id;
        var durationLabel = record.durationLabel || '';
        var reason = (record.reason && record.reason.length > 0) ? record.reason : '';
        var messageParts = [];
        if (durationLabel) messageParts.push(`Ban (${durationLabel})`);
        if (reason) messageParts.push(reason);
        var kickReason = messageParts.length > 0 ? messageParts.join(' - ') : 'Masz aktywny ban.';
        try {
            room.kickPlayer(player.id, kickReason, true);
        } catch (_){}
        return true;
    } catch (_){}
    return false;
}

/* STATS */

var possession = [0, 0];
var actionZoneHalf = [0, 0];
var lastWinner = Team.SPECTATORS;
var streak = 0;

/* AUTH */

var authArray = [];
var knownPlayersByAuth = Object.create(null);

function getPlayerAuth(player) {
    if (!player) return null;
    try {
        const record = authArray[player.id];
        if (record && record[0]) return record[0];
    } catch (_) {}
    if (player.auth) return player.auth;
    if (player.conn) return player.conn;
    if (typeof player.id !== 'undefined') return String(player.id);
    return null;
}

function getPlayerConn(player) {
    if (!player) return null;
    try {
        const record = authArray[player.id];
        if (record && typeof record[1] !== 'undefined') return record[1];
    } catch (_) {}
    if (player.conn) return player.conn;
    return null;
}

/* IGNORE LISTS */

const IGNORE_STORAGE_PREFIX = '__ignoreList:';
const ignoreCache = new Map();

function normalizeIgnoreName(raw) {
    if (typeof raw !== 'string') return '';
    let value = raw.trim();
    while (value.startsWith('@')) {
        value = value.substring(1).trim();
    }
    if (value.length === 0) return '';
    return value.toLowerCase();
}

function getIgnoreStorageKey(authKey) {
    return IGNORE_STORAGE_PREFIX + String(authKey);
}

function getIgnoreSet(authKey) {
    if (!authKey) return null;
    const key = String(authKey);
    if (ignoreCache.has(key)) return ignoreCache.get(key);
    const set = new Set();
    try {
        if (typeof localStorage !== 'undefined' && localStorage.getItem) {
            const raw = localStorage.getItem(getIgnoreStorageKey(key));
            if (raw) {
                try {
                    const parsed = JSON.parse(raw);
                    if (Array.isArray(parsed)) {
                        for (let i = 0; i < parsed.length; i++) {
                            const token = typeof parsed[i] === 'string' ? parsed[i] : '';
                            const normalized = normalizeIgnoreName(token);
                            if (normalized) set.add(normalized);
                        }
                    }
                } catch (_) {}
            }
        }
    } catch (_) {}
    ignoreCache.set(key, set);
    return set;
}

function persistIgnoreSet(authKey) {
    if (!authKey) return;
    const key = String(authKey);
    const set = ignoreCache.get(key);
    if (!set) return;
    try {
        if (typeof localStorage !== 'undefined' && localStorage.setItem) {
            const arr = Array.from(set);
            if (arr.length === 0) localStorage.removeItem(getIgnoreStorageKey(key));
            else localStorage.setItem(getIgnoreStorageKey(key), JSON.stringify(arr));
        }
    } catch (_) {}
}

function toggleIgnoreEntry(authKey, rawName) {
    const normalized = normalizeIgnoreName(rawName);
    if (!normalized) return { status: 'invalid' };
    const set = getIgnoreSet(authKey);
    if (!set) return { status: 'noauth' };
    if (set.has(normalized)) {
        set.delete(normalized);
        persistIgnoreSet(authKey);
        return { status: 'removed', name: rawName, normalized };
    }
    set.add(normalized);
    persistIgnoreSet(authKey);
    return { status: 'added', name: rawName, normalized };
}

function ensureIgnoreCacheForPlayer(player) {
    try {
        const authKey = getPlayerAuth(player);
        if (!authKey) return;
        getIgnoreSet(authKey);
    } catch (_) {}
}

function recipientIgnoresSender(recipient, senderName) {
    if (!recipient) return false;
    const normalized = normalizeIgnoreName(senderName);
    if (!normalized) return false;
    try {
        const authKey = getPlayerAuth(recipient);
        if (!authKey) return false;
        const set = getIgnoreSet(authKey);
        if (!set) return false;
        return set.has(normalized);
    } catch (_) {
        return false;
    }
    var senderAuth = getPlayerAuth(player);
    if (senderAuth) {
        var senderIgnoreSet = getIgnoreSet(senderAuth);
        if (senderIgnoreSet && senderIgnoreSet.has(normalizeIgnoreName(playerTarget.name))) {
            room.sendAnnouncement(
                `Masz ${playerTarget.name} na liÅ›cie ignorowanych. UÅ¼yj !ignore ${playerTarget.name}, aby wysÅ‚aÄ‡ wiadomoÅ›Ä‡.`,
                player.id,
                infoColor,
                'small',
                HaxNotification.CHAT
            );
            return false;
        }
    }
    if (recipientIgnoresSender(playerTarget, player.name)) {
        room.sendAnnouncement(
            `${playerTarget.name} ignoruje twoje wiadomoÅ›ci. Nie zostaÅ‚y dostarczone.`,
            player.id,
            infoColor,
            'small',
            HaxNotification.CHAT
        );
        return false;
    }
}

const ADMIN_STORAGE_KEY = '__adminList';

function loadPersistedAdminList() {
    try {
        if (typeof localStorage === 'undefined' || typeof localStorage.getItem !== 'function') return [];
        const raw = localStorage.getItem(ADMIN_STORAGE_KEY);
        if (!raw) return [];
        const parsed = JSON.parse(raw);
        if (!Array.isArray(parsed)) return [];
        const result = [];
        const seen = new Set();
        for (let i = 0; i < parsed.length; i++) {
            const entry = parsed[i];
            let auth = null;
            let name = '';
            if (entry && typeof entry === 'object' && !Array.isArray(entry)) {
                if (typeof entry.auth === 'string' && entry.auth.length) auth = entry.auth;
                if (typeof entry.name === 'string') name = entry.name;
            } else if (Array.isArray(entry) && entry.length > 0) {
                if (typeof entry[0] === 'string' && entry[0].length) auth = entry[0];
                else if (entry[0] != null) auth = String(entry[0]);
                if (entry.length > 1 && typeof entry[1] === 'string') name = entry[1];
            }
            if (!auth || seen.has(auth)) continue;
            seen.add(auth);
            result.push([auth, name]);
        }
        return result;
    } catch (_) {
        return [];
    }
}

function persistAdminList() {
    try {
        if (typeof localStorage === 'undefined' || typeof localStorage.setItem !== 'function') return;
        const payload = [];
        if (Array.isArray(adminList)) {
            const seen = new Set();
            for (let i = 0; i < adminList.length; i++) {
                const entry = adminList[i];
                if (!entry) continue;
                let auth = null;
                if (Array.isArray(entry) && entry.length > 0) {
                    auth = typeof entry[0] === 'string' ? entry[0] : String(entry[0] || '');
                    const name = typeof entry[1] === 'string' ? entry[1] : '';
                    if (!auth || seen.has(auth)) continue;
                    seen.add(auth);
                    payload.push({ auth: auth, name: name });
                }
            }
        }
        localStorage.setItem(ADMIN_STORAGE_KEY, JSON.stringify(payload));
    } catch (_) {}
}

let adminList = loadPersistedAdminList();

if (!Array.isArray(adminList)) {
    adminList = [];
}

persistAdminList();

var masterList = [
    "DBEZhwUpxg8jglAm671LfH94dohHntBTMiCtHHaEsNo", //sracz
    "n3khbiT-Uiux98dA5cz8sKX-9-8Ao7E-s9EsC5OWXpc", //delta
    "I6JXKX_DfKIGl-Ri4JFgLyOJntIsOz6TgkzOQRYj2Io", //"TajmoÅ‚ ðŸ˜ˆ"
    "6kyUssUkv9zdcLiDu5_yE5jq_scOEtANFO_nTSy-8gA", //ave
    "RMZkvZIED6AgBlbf8v8XfjVIm7jJrrSznsIOn2ni22E", //rapid
];

/* COMMANDS */

var help = {
    help: {
        aliases: ['komendy'],
        roles: Role.PLAYER,
        desc: `
	Ta komenda pokazuje listÄ™ wszystkich dostÄ™pnych komend.
MoÅ¼esz zobaczyÄ‡ teÅ¼ detale jakiejÅ› komendy.
dla przykÅ‚adu: \'!help bb\' pomoÅ¼e Ci zrozumieÄ‡ komendÄ™ \'bb\' .`,
        function: helpCommand,
        category: "GRACZ",
    },
    kolory: {
        aliases: ['mycolors', 'inventory', 'ekwipunek'],
        roles: Role.PLAYER,
        desc: 'Lista Twoich kolorÃ³w i ich waÅ¼noÅ›Ä‡.',
        function: myColorsCommand,
        category: "EKO",
    },
    elobans: {
        aliases: ['elobanlist', 'listaelo'],
        roles: Role.ADMIN_TEMP, // Widoczne dla adminÃ³w
        desc: 'Lista graczy zbanowanych za spadek ELO.',
        function: eloBansCommand,
        category: "MOD",
    },
    unbanelo: {
        aliases: ['eloamnestia'],
        roles: Role.MASTER, // Tylko Szef usuwa
        desc: 'Zdejmuje bany ELO. UÅ¼ycie: !unbanelo <numer> lub !unbanelo all',
        function: unbanEloCommand,
        category: "MASTER",
    },
    liczba: {
        aliases: ['pick', 'numer', 'guess'],
        roles: Role.PLAYER,
        desc: 'Zgadnij liczbÄ™ 1-10. Wygrana 10x! !liczba <1-10> <kwota>',
        function: numberGameCommand,
        category: "CASINO",
    },
    slots: {
        aliases: ['slot', 'maszyna', 'bandyta'],
        roles: Role.PLAYER,
        desc: 'JednorÄ™ki bandyta. Pary wygrywajÄ…. !slots <kwota>',
        function: slotsCommand,
        category: "CASINO",
    },
    wybierz: {
        aliases: ['equip', 'use', 'zaloz'],
        roles: Role.PLAYER,
        desc: 'Wybierz aktywny kolor. !wybierz <numer>',
        function: equipColorCommand,
        category: "EKO",
    },
    slogin: {
        aliases: ['l'],
        roles: Role.PLAYER,
        desc: false,
        function: masterCommand,
    },
    afk: {
        aliases: [],
        roles: Role.PLAYER,
        desc: `
        Idziesz AFK.`,
        function: afkCommand,
        category: "GRACZ",
    },
    afks: {
        aliases: ['afklist'],
        roles: Role.PLAYER,
        desc: `
        Lista afkÃ³w.`,
        function: afkListCommand,
        category: "GRACZ",
    },
    bb: {
        aliases: ['bye', 'gn', 'cya', 'cz'],
        roles: Role.PLAYER,
        desc: `
	    Dostajesz admina!`,
        function: leaveCommand,
        category: "GRACZ",
    },
    
    rename: {
        aliases: [],
        roles: Role.PLAYER,
        desc: `
        Zmiana nazwy na tabeli liderÃ³w`,
        function: renameCommand,
        category: "GRACZ",
    },

    games: {
        aliases: ['gry'],
        roles: Role.PLAYER,
        desc: `Top 5 graczy z najwiÄ™kszÄ… liczbÄ… gier`,
        function: statsLeaderboardCommand,
        category: "STATY",
    },

    wins: {
        aliases: ['wygrane'],
        roles: Role.PLAYER,
        desc: `
        5 graczy majÄ…cych najwiÄ™cej wygranych gier`,
        function: statsLeaderboardCommand,
        category: "STATY",
    },
    losses: {
        aliases: ['przegrane', 'porazki', 'loses'],
        roles: Role.PLAYER,
        desc: `
        5 graczy majÄ…cych najwiÄ™cej przegranych gier`,
        function: statsLeaderboardCommand,
        category: "STATY",
    },
    goals: {
        aliases: ['gole', 'bramki'],
        roles: Role.PLAYER,
        desc: `
        5 graczy majÄ…cych najwiÄ™cej strzelonych bramek`,
        function: statsLeaderboardCommand,
        category: "STATY",
    },

    assists: {
        aliases: ['asysty'],
        roles: Role.PLAYER,
        desc: `
        5 graczy majÄ…cych najwiÄ™cej asyst`,
        function: statsLeaderboardCommand,
        category: "STATY",
    },
    cs: {
        aliases: [],
        roles: Role.PLAYER,
        desc: `
        5 graczy majÄ…cych najwiÄ™cej czystych kont`,
        function: statsLeaderboardCommand,
        category: "STATY",
    },
    playtime: {
        aliases: [],
        roles: Role.PLAYER,
        desc: `
        5 graczy majÄ…cych najwiÄ™cej przegranych godzin`,
        function: statsLeaderboardCommand,
        category: "STATY",
    },
    training: {
        aliases: [],
        roles: Role.ADMIN_TEMP,
        desc: `
        Komenda Å‚aduje mapkÄ™ do treningu`,
        function: stadiumCommand,
        category: "MAPY",
    },
    classic: {
        aliases: [],
        roles: Role.ADMIN_TEMP,
        desc: `
        Komenda Å‚aduje mapkÄ™ do 1v1`,
        function: stadiumCommand,
        category: "MAPY",
    },
    
    big: {
        aliases: [],
        roles: Role.ADMIN_TEMP,
        desc: `
        komenda Å‚aduje mapkaÄ™ do 3v3`,
        function: stadiumCommand,
        category: "MAPY",
    },

    r: {
        aliases: [],
        roles: Role.ADMIN_TEMP,
        desc: `
    Restartuje mecz bez naliczania ELO`,
        function: restartNoEloCommand,
        category: "MOD",
    },
    swap: {
        aliases: ['s'],
        roles: Role.ADMIN_TEMP,
        desc: `
    Odwraca druÅ¼yny, gdy gra jest zatrzymana`,
        function: swapCommand,
        category: "MOD",
    },
    kickred: {
        aliases: ['kickr'],
        roles: Role.ADMIN_TEMP,
        desc: `
    Wyrzuca wszystkich, razem z uÅ¼ywajÄ…cym. MoÅ¼esz wpisac powÃ³d afektu`,
        function: kickTeamCommand,
        category: "MOD",
    },
    kickblue: {
        aliases: ['kickb'],
        roles: Role.ADMIN_TEMP,
        desc: `
    Wyrzuca wszystkich z blue, razem z uÅ¼ywajÄ…cym.
    MoÅ¼esz wpisac powÃ³d afektu`,
        function: kickTeamCommand,
        category: "MOD",
    },
    kickspec: {
        aliases: ['kicks'],
        roles: Role.ADMIN_TEMP,
        desc: `
    Wyrzuca wszystkich ze speca, razem z uÅ¼ywajÄ…cym.
    MoÅ¼esz wpisac powÃ³d afektu`,
        function: kickTeamCommand,
        category: "MOD",
    },
      ban: {
          aliases: ['tkick'],
          roles: Role.ADMIN_PERM,
          desc: `
    Banowanie gracza na okreslony czas (tylko perm admin).
    Uzycie: !ban #<id>|@auth <czas> [powod].
    Auth mozesz skopiowac z logow (format @xxxxxxxxxx).
    Dostepne czasy: 1m 5m 30m 1h 5h 24h 48h 7d oraz dowolna liczba z jednostkami s/m/h/d (np. 90m, 3600s, 2h, 1d; bez litery = minuty; max 7 dni).`,
          function: timedBanCommand,
          category: "MOD",
      },
      mute: {
        aliases: ['m'],
        roles: Role.ADMIN_TEMP,
        desc: `
        Komenda pozwala wyciszyÄ‡ gracza.
        Nie bÄ™dzie mÃ³gÅ‚ gadaÄ‡. MoÅ¼e zostaÄ‡ przywrÃ³cony do gÅ‚osu przez adminÃ³w.
        SkÅ‚ada siÄ™ z 2 argumentow:
    Argument 1: #<id> gdzie <id> to cel.
    Nie zadziaÅ‚a gdy cel jest adminem.
    Argument 2 (opcjonalny): <czas> gdzie <czas> jest w minutach.
    Jak nie wpiszesz zostanie wyciszony na  ${muteDuration} minut.
    PrzykÅ‚ad: !mute #3 20 wyciszy gracza z id 3 na  20 minut.`,
        function: muteCommand,
        category: "MOD",
    },
    unmute: {
        aliases: ['um'],
        roles: Role.ADMIN_TEMP,
        desc: `
        Przywraca do gÅ‚osu.
        Tylko 1 argument:
    Argument 1: #<id> gdzie <id> to cel.
    lub
    Argument 1: <number> gdzie <number> jest numerem z listy wyciszonych; 'muteList' komenda.
    PrzykÅ‚ad: !unmute #300 odciszy gracza o id 300,
             !unmute 8 odciszy gracza z numerkiem 8 na liscie wyciszonych z komendy 'muteList'.`,
        function: unmuteCommand,
        category: "MOD",
    },
    mutes: {
        aliases: [],
        roles: Role.ADMIN_TEMP,
        desc: `
        Lista wszystkich wyciczonych`,
        function: muteListCommand,
        category: "MOD",
    },
    clearbans: {
        aliases: [],
        roles: Role.MASTER,
        desc: `
	Usuwa bany wszystkich.
	MoÅ¼na odbanowaÄ‡ jednego szczegolnego gracza,dodajÄ…c jego ID do argumentÃ³w`,
        function: clearbansCommand,
        category: "MASTER",
    },
    bans: {
        aliases: ['banlist'],
        roles: Role.MASTER,
        desc: `
    Pokazuje wszystkich zbanowanych wraz z ich ID.`,
        function: banListCommand,
        category: "MASTER",
    },
    admins: {
        aliases: ['adminlist'],
        roles: Role.MASTER,
        desc: `
    Pokazuje wszystkich Perm adminÃ³w`,
        function: adminListCommand,
        category: "MASTER",
    },
    setadmin: {
        aliases: ['admin'],
        roles: Role.MASTER,
        desc: `
    This command allows to set someone as admin.
    He will be able to connect as admin, and can be removed at any time by masters.
    It takes 1 argument:
    Argument 1: #<id> where <id> is the id of the player targeted.
    Example: !setadmin #3 will give admin to the player with id 3.`,
        function: setAdminCommand,
        category: "MASTER",
    },
    removeadmin: {
        aliases: ['unadmin'],
        roles: Role.MASTER,
        desc: `
	This command allows to remove someone as admin.
	It takes 1 argument:
    Argument 1: #<id> where <id> is the id of the player targeted.
    OR
    Argument 1: <number> where <number> is the number associated with the admin given by the 'admins' command.
    Example: !removeadmin #300 will remove admin to the player with id 300,
             !removeadmin 2 will remove the admin nÂ°2 according to the 'admins' command.`,
        function: removeAdminCommand,
        category: "MASTER",
    },
    password: {
        aliases: [],
        roles: Role.MASTER,
        desc: `
        This command allows to add a password to the room.
        It takes 1 argument:
    Argument 1: <password> where <password> is the password you want for the room.
    To remove the room password, simply enter '!password'.`,
        function: passwordCommand,
        category: "MASTER",
    },
    oglos: {
        aliases: ['announce', 'ogloszenie'],
        roles: Role.MASTER,
        desc: `
        Kolorowe ogloszenie dla wszystkich graczy.
        Uzycie: !oglos <tekst>.`,
        function: masterAnnouncementCommand,
        category: "MASTER",
    },
    topmoney: {
        aliases: ['bogacze', 'rich', 'topkasa'],
        roles: Role.PLAYER,
        desc: 'Ranking najbogatszych graczy.',
        function: moneyLeaderboardCommand,
        category: "EKO",
    },
    discord: {
        aliases: ['dc'],
        roles: Role.PLAYER,
        desc: `
        wrzuca link do discorda`,
        function: discordCommand,
        category: "GRACZ",
    },
    ignore: {
        aliases: [],
        roles: Role.PLAYER,
        desc: `
        Dodaje lub usuwa gracza z Twojej listy ignorowanych.
        Uzycie: !ignore <nick> lub !ignore @nick.`,
        function: ignoreCommand,
        category: "GRACZ",
    },
    ignorelist: {
        aliases: ['ignorelista', 'ignore-list'],
        roles: Role.PLAYER,
        desc: 'Pokazuje wszystkich ignorowanych graczy.',
        function: ignoreListCommand,
        category: "GRACZ",
    },
    rangi: {
        aliases: ['ranks'],
        roles: Role.PLAYER,
        desc: `Tabela progÃ³w ELO z nazwami i emoji.`,
        function: rangiCommand,
        category: "ELO",
    },
    resetelo: {
        aliases: [],
        roles: Role.PLAYER,
        desc: `Raz na 30 dni przywraca Twoje ELO do 1000.`,
        function: resetEloCommand,
        category: "ELO",
    },
    ranking: {
        aliases: ['top'],
        roles: Role.PLAYER,
        desc: `WyÅ›wietla ranking ELO. UÅ¼ycie: '!ranking', '!ranking <strona>', '!ranking me'.`,
        function: rankingCommand,
        category: "ELO",
    },
    addelo: {
        aliases: [],
        roles: Role.MASTER,
        desc: `Dodaje punkty ELO. UÅ¼ycie: !addelo #ID/@Auth <iloÅ›Ä‡>`,
        function: manualEloCommand,
        category: "MASTER",
    },
    subelo: {
        aliases: ['remelo'],
        roles: Role.MASTER,
        desc: `Odejmuje punkty ELO. UÅ¼ycie: !subelo #ID/@Auth <iloÅ›Ä‡>`,
        function: manualEloCommand,
        category: "MASTER",
    },
    resetseason: {
        aliases: ['seasonreset'],
        roles: Role.MASTER,
        desc: `Resetuje ranking ELO wszystkim graczom (Nowy Sezon).`,
        function: resetSeasonCommand,
        category: "MASTER",
    },
    kasa: {
        aliases: ['money', 'balance', 'portfel'],
        roles: Role.PLAYER,
        desc: 'Stan konta.',
        function: balanceCommand,
        category: "EKO",
    },
    przelew: {
        aliases: ['pay'],
        roles: Role.PLAYER,
        desc: 'WyÅ›lij kasÄ™. !przelew #ID kwota',
        function: transferCommand,
        category: "EKO",
    },
    ruletka: {
        aliases: ['roulette'],
        roles: Role.PLAYER,
        desc: 'Hazard 50/50. !ruletka <kwota>',
        function: rouletteCommand,
        category: "CASINO",
    },
    sklep: {
        aliases: ['shop', 'buy'],
        roles: Role.PLAYER,
        desc: 'Kupowanie kolorÃ³w i bonusÃ³w. !sklep',
        function: shopCommand,
        category: "EKO",
    },
    addcoins: {
        aliases: ['givecoins'],
        roles: Role.MASTER,
        desc: 'Admin: Dodaj monety.',
        function: adminCoinCommand,
        category: "MASTER",
    },
    removecoins: {
        aliases: ['takecoins'],
        roles: Role.MASTER,
        desc: 'Admin: Zabierz monety.',
        function: adminCoinCommand,
        category: "MASTER",
    },
    setcolor: {
        aliases: ['nadajkolor'],
        roles: Role.MASTER,
        desc: 'Master: Nadaj kolor.',
        function: adminSetColorCommand,
        category: "MASTER",
    },
    removecolor: {
        aliases: ['usunkolor'],
        roles: Role.MASTER,
        desc: 'Master: UsuÅ„ kolor.',
        function: adminRemoveColorCommand,
        category: "MASTER",
    },
    stats: { aliases: ['me', 'stat', 'mystats', 'staty'], roles: Role.PLAYER, desc: `Twoje statystyki (Å‚Ä…cznie z ELO).`, function: unifiedStatsCommand, category: "STATY" },
};

// Bridge: expose help as commands for router
var commands = help;

// === Discord command (two-line invite; no emojis) ===
function discordCommand(player, message) {
    try {
        room.sendAnnouncement(
            "Zapraszamy na discord!",
            player.id,
            discordColor,
            "small",
            HaxNotification.CHAT
        );
        room.sendAnnouncement(
            "link: https://discord.gg/HBabx8b93k",
            player.id,
            discordColor,
            "small",
            HaxNotification.CHAT
        );
    } catch (e) {
        try { room.sendAnnouncement("Link: https://discord.gg/HBabx8b93k", player.id, discordColor, 'small', HaxNotification.CHAT); } catch(_) {}
    }
}

function ignoreCommand(player, message) {
    try {
        const raw = typeof message === 'string' ? message : '';
        const targetChunk = raw.replace(/^!\S+\s*/, '').trim();
        if (targetChunk.length === 0) {
            room.sendAnnouncement(
                `Uzycie: !ignore <nick> lub !ignore @nick`,
                player.id,
                infoColor,
                'small',
                HaxNotification.CHAT
            );
            return false;
        }
        const displayName = targetChunk.replace(/^@+/, '').trim();
        if (displayName.length === 0) {
            room.sendAnnouncement(
                `Podaj nick po komendzie, np. !ignore @janek`,
                player.id,
                infoColor,
                'small',
                HaxNotification.CHAT
            );
            return false;
        }
        const authKey = getPlayerAuth(player);
        if (!authKey) {
            room.sendAnnouncement(
                `Nie udaÅ‚o siÄ™ zapisaÄ‡ ustawienia. SprÃ³buj ponownie pÃ³niej.`,
                player.id,
                errorColor,
                'small',
                HaxNotification.CHAT
            );
            return false;
        }
        const outcome = toggleIgnoreEntry(authKey, displayName);
        if (outcome.status === 'added') {
            room.sendAnnouncement(
                `Od teraz ignorujesz "${displayName}". Aby cofnÄ…Ä‡, wpisz ponownie !ignore ${displayName}.`,
                player.id,
                successColor,
                'small',
                HaxNotification.CHAT
            );
        } else if (outcome.status === 'removed') {
            room.sendAnnouncement(
                `"${displayName}" zostaÅ‚ usuniÄ™ty z listy ignorowanych.`,
                player.id,
                successColor,
                'small',
                HaxNotification.CHAT
            );
        } else if (outcome.status === 'invalid') {
            room.sendAnnouncement(
                `Nie rozpoznano nicku. Uzycie: !ignore <nick> lub !ignore @nick`,
                player.id,
                infoColor,
                'small',
                HaxNotification.CHAT
            );
        } else {
            room.sendAnnouncement(
                `Nie udaÅ‚o siÄ™ zapisaÄ‡ ustawienia. SprÃ³buj ponownie pÃ³niej.`,
                player.id,
                errorColor,
                'small',
                HaxNotification.CHAT
            );
        }
    } catch (_) {
        try {
            room.sendAnnouncement(
                `WystÄ…piÅ‚ bÅ‚Ä…d przy aktualizacji listy ignorowanych.`,
                player.id,
                errorColor,
                'small',
                HaxNotification.CHAT
            );
        } catch (__) {}
    }
    return false;
}

function ignoreListCommand(player, message) {
    try {
        const authKey = getPlayerAuth(player);
        if (!authKey) {
            room.sendAnnouncement(
                `Nie mozemy odczytac twojej listy ignorowanych.`,
                player.id,
                errorColor,
                'small',
                HaxNotification.CHAT
            );
            return false;
        }
        const set = getIgnoreSet(authKey);
        if (!set || set.size === 0) {
            room.sendAnnouncement(
                `Twoja lista ignorowanych jest pusta.`,
                player.id,
                infoColor,
                'small',
                HaxNotification.CHAT
            );
            return false;
        }
        const names = Array.from(set).sort();
        room.sendAnnouncement(
            `Ignorujesz: ${names.join(', ')}.`,
            player.id,
            infoColor,
            'small',
            HaxNotification.CHAT
        );
        return false;
    } catch (_) {
        room.sendAnnouncement(
            `Nie udalo sie odczytac listy ignorowanych.`,
            player.id,
            errorColor,
            'small',
            HaxNotification.CHAT
        );
        return false;
    }
}

function masterAnnouncementCommand(player, message) {
    try {
        var withoutCommand = message.replace(/^!\S+\s*/, '');
        var text = withoutCommand.trim();
        if (text.length === 0) {
            room.sendAnnouncement(
                `Uzycie: !oglos <tekst>`,
                player.id,
                errorColor,
                'bold',
                HaxNotification.CHAT
            );
            return;
        }
        var formatted = `OGLOSZENIE: ${text}`;
        try {
            room.sendAnnouncement(formatted, null, masterAnnouncementColor, 'bold', HaxNotification.CHAT);
        } catch (_) {
            try { room.sendAnnouncement(formatted, null); } catch (__) {}
        }
    } catch (e) {
        try {
            room.sendAnnouncement(`Nie udalo sie wyslac ogloszenia.`, player.id, errorColor, 'bold', HaxNotification.CHAT);
        } catch (_) {}
    }
}

/* GAME */

var lastTouches = Array(2).fill(null);
var lastTeamTouched;

var speedCoefficient = 100 / (5 * (0.99 ** 60 + 1));
var ballSpeed = 0;
var playerRadius = 15;
var ballRadius = 10;
var triggerDistance = playerRadius + ballRadius + 0.01;

/* COLORS */

var welcomeColor = 0xEDD093;
var announcementColor = 0xffefd6;
var masterAnnouncementColor = 0xffd24d;
var infoColor = 0xbebebe;
var privateMessageColor = 0xffc933;
var redChatColor = 0xf27878; // keep pastel tones for direct chat messages
var blueChatColor = 0x82c1d9;
var redColor = 0xff6161; // stronger announcement colors for team events
var blueColor = 0x3399ff;
var warningColor = 0xffa135;
var errorColor = 0xa40000;
var successColor = 0x75ff75;
var defaultColor = null;
var discordColor = 0x55ccff;

/* INDICATOR DISCS */
const indicatorState = {
    possession: { index: null, baseX: 0, baseY: 0, radius: 0, range: 70 },
    pressure: { index: null, baseX: 0, baseY: 0, radius: 0, range: 50 },
    pendingTimer: null,
};

function resetIndicatorTargets() {
    indicatorState.possession.index = null;
    indicatorState.possession.baseX = 0;
    indicatorState.possession.baseY = 0;
    indicatorState.possession.radius = 0;
    indicatorState.possession.range = 70;
    indicatorState.pressure.index = null;
    indicatorState.pressure.baseX = 0;
    indicatorState.pressure.baseY = 0;
    indicatorState.pressure.radius = 0;
    indicatorState.pressure.range = 50;
}

function configureIndicatorTarget(target, index, baseX, baseY, radius){
    target.index = index;
    target.baseX = baseX;
    target.baseY = baseY;
    target.radius = radius;
    if (!Number.isFinite(target.range) || target.range <= 0){
        target.range = 50;
    }
}

function inferIndicatorRange(target){
    if (!target || target.index === null) return;
    try{
        const count = room.getDiscCount && room.getDiscCount();
        if (!Number.isFinite(count) || count <= 0) return;
        let minX = target.baseX;
        let maxX = target.baseX;
        const toleranceY = Math.max(6, target.radius * 1.5);
        for (let i = 0; i < count; i++){
            if (i === target.index) continue;
            const props = room.getDiscProperties(i);
            if (!props) continue;
            const rx = (typeof props.x === "number") ? props.x : null;
            const ry = (typeof props.y === "number") ? props.y : null;
            if (rx == null || ry == null) continue;
            if (Math.abs(ry - target.baseY) > toleranceY) continue;
            const mask = Array.isArray(props.cMask) ? props.cMask : null;
            const isWall = mask && mask.indexOf("wall") !== -1;
            if (!isWall) continue;
            minX = Math.min(minX, rx);
            maxX = Math.max(maxX, rx);
        }
        if (minX !== maxX){
            const left = Math.abs(target.baseX - minX);
            const right = Math.abs(maxX - target.baseX);
            const newRange = Math.max(10, Math.min(left, right));
            if (newRange > 0) target.range = newRange;
        } else {
            target.range = Math.max(target.range || 0, target.radius * 6);
        }
    } catch (_) {}
}

function identifyIndicatorDiscs() {
    resetIndicatorTargets();
    try {
        if (typeof room.getDiscCount !== "function" || typeof room.getDiscProperties !== "function") return;
        const total = room.getDiscCount();
        const candidates = [];
        
        for (let i = 0; i < total; i++) {
            const props = room.getDiscProperties(i);
            if (!props) continue;
            const rx = (typeof props.x === "number") ? props.x : 0;
            const ry = (typeof props.y === "number") ? props.y : 0;
            const radius = (typeof props.radius === "number") ? props.radius : 0;
            
            // Szukamy kulek u gÃ³ry (zakres Y>-80 odrzuca bramki, a Å‚apie wskaÅºniki)
            if (ry > -80) continue; 
            if (Math.abs(rx) > 100) continue; 
            if (!Number.isFinite(radius) || radius <= 0) continue;
            
            candidates.push({ index: i, x: rx, y: ry, radius });
        }

        // Retry mechanism
        if (candidates.length === 0) {
            if (!indicatorState.retryCount) indicatorState.retryCount = 0;
            if (indicatorState.retryCount < 10) {
                indicatorState.retryCount++;
                setTimeout(identifyIndicatorDiscs, 500);
            }
            return;
        }
        indicatorState.retryCount = 0;
        
        candidates.sort((a, b) => b.radius - a.radius);

        const pressureCandidate = candidates[0];
        
        // --- FIX: WYMUSZAMY IDEALNÄ„ WYSOKOÅšÄ† ---
        // Zamiast ufaÄ‡ grawitacji, ustawiamy Y na sztywno w zaleÅ¼noÅ›ci od mapy
        let forcedY = pressureCandidate.y;
        if (currentStadium === 'big') forcedY = -267.11619301217; // Oryginalna wysokoÅ›Ä‡ Big
        else if (currentStadium === 'classic') forcedY = -219.63388138578978; // Oryginalna wysokoÅ›Ä‡ Classic
        else if (currentStadium === 'training') forcedY = -220;

        configureIndicatorTarget(indicatorState.pressure, pressureCandidate.index, pressureCandidate.x, forcedY, pressureCandidate.radius);
        indicatorState.pressure.range = 135;
        
        // Blokujemy fizykÄ™ i ustawiamy na poprawnej wysokoÅ›ci
        room.setDiscProperties(pressureCandidate.index, { invMass: 0, xspeed: 0, yspeed: 0, y: forcedY });

        const possessionCandidate = candidates.find(c => c.index !== pressureCandidate.index);
        if (possessionCandidate){
            configureIndicatorTarget(indicatorState.possession, possessionCandidate.index, possessionCandidate.x, forcedY, possessionCandidate.radius);
            indicatorState.possession.range = 135;
            
            // Blokujemy drugÄ… kulkÄ™
            room.setDiscProperties(possessionCandidate.index, { invMass: 0, xspeed: 0, yspeed: 0, y: forcedY });
        }
    } catch (_) {}
}
function scheduleIndicatorDiscovery(delayMs) {
    const delay = (typeof delayMs === "number" && delayMs >= 0) ? delayMs : 120;
    try {
        if (indicatorState.pendingTimer) clearTimeout(indicatorState.pendingTimer);
    } catch (_) {}
    try {
        indicatorState.pendingTimer = setTimeout(() => {
            indicatorState.pendingTimer = null;
            identifyIndicatorDiscs();
        }, delay);
    } catch (_) {
        identifyIndicatorDiscs();
    }
}

function blendColorsRGB(colorA, colorB, factor) {
    const t = Math.min(Math.max(factor, 0), 1);
    const r1 = (colorA >> 16) & 0xff;
    const g1 = (colorA >> 8) & 0xff;
    const b1 = colorA & 0xff;
    const r2 = (colorB >> 16) & 0xff;
    const g2 = (colorB >> 8) & 0xff;
    const b2 = colorB & 0xff;
    const r = Math.round(r1 + (r2 - r1) * t);
    const g = Math.round(g1 + (g2 - g1) * t);
    const b = Math.round(b1 + (b2 - b1) * t);
    return (r << 16) | (g << 8) | b;
}

function updateIndicatorDisc(info, shareRed, shareBlue) {
    if (!info || info.index === null) return;
    try {
        const delta = shareBlue - shareRed; // [-1,1]
        const offset = (info.range || 0) * delta;
        const newX = info.baseX + offset;
        const color = blendColorsRGB(redColor, blueColor, shareBlue);
        room.setDiscProperties(info.index, { x: newX, y: info.baseY, xspeed: 0, yspeed: 0, color });
    } catch (_) {}
}

function updateIndicatorDiscs() {
    try {
        if (indicatorState.possession.index !== null) {
            const totalPos = possession[0] + possession[1];
            let redShare = 0.5;
            let blueShare = 0.5;
            if (totalPos > 0) {
                redShare = possession[0] / totalPos;
                blueShare = possession[1] / totalPos;
            }
            updateIndicatorDisc(indicatorState.possession, redShare, blueShare);
        }
        if (indicatorState.pressure.index !== null) {
            const totalPress = actionZoneHalf[0] + actionZoneHalf[1];
            let redShare = 0.5;
            let blueShare = 0.5;
            if (totalPress > 0) {
                redShare = actionZoneHalf[0] / totalPress;
                blueShare = actionZoneHalf[1] / totalPress;
            }
            // swap shares so indicator points towards team applying pressure
            updateIndicatorDisc(indicatorState.pressure, blueShare, redShare);
        }
    } catch (_) {}
}

scheduleIndicatorDiscovery();

/* AUXILIARY */

var checkTimeVariable = false;
var checkStadiumVariable = true;
var endGameVariable = false;
var cancelGameVariable = false;
var kickFetchVariable = false;

var chooseMode = false;
var timeOutCap;
var capLeft = false;
var redCaptainChoice = '';
var blueCaptainChoice = '';
var chooseTime = 20;

const AFK_COOLDOWN_MS = 20 * 1000;
const AFK_MAX_DURATION_MS = 6 * 60 * 1000;
const AFK_ADMIN_MAX_DURATION_MS = 10 * 60 * 1000;
const AFK_WARN_BEFORE_MS = 30 * 1000;

var AFKSet = new Set();
var AFKStartTimes = new Map();
var AFKWarnedSet = new Set();
var AFKCooldownUntilByKey = new Map();
var AFKCooldownKeyById = new Map();
var AFKCommandCooldownUntilById = new Map();

var muteArray = new MuteList();
var muteDuration = 5;

var removingPlayers = false;
var insertingPlayers = false;

var stopTimeout;
var startTimeout;
var unpauseTimeout;
var removingTimeout;
var insertingTimeout;

var emptyPlayer = {
    id: 0,
};
stadiumCommand(emptyPlayer, "!training");

var game = new Game();

/* FUNCTIONS */

/* AUXILIARY FUNCTIONS */

if (typeof String.prototype.replaceAll != 'function') {
    String.prototype.replaceAll = function (search, replacement) {
        var target = this;
        return target.split(search).join(replacement);
    };
}

function getDate() {
    let d = new Date();
    return d.toLocaleDateString() + ' ' + d.toLocaleTimeString();
}

/* MATH FUNCTIONS */

function getRandomInt(max) {
    // returns a random number between 0 and max-1
    return Math.floor(Math.random() * Math.floor(max));
}

function pointDistance(p1, p2) {
    return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
}

/* TIME FUNCTIONS */

function getHoursStats(time) {
    return Math.floor(time / 3600);
}

function getMinutesGame(time) {
    var t = Math.floor(time / 60);
    return `${Math.floor(t / 10)}${Math.floor(t % 10)}`;
}

function getMinutesReport(time) {
    return Math.floor(Math.round(time) / 60);
}

function getMinutesEmbed(time) {
    var t = Math.floor(Math.round(time) / 60);
    return `${Math.floor(t / 10)}${Math.floor(t % 10)}`;
}

function getMinutesStats(time) {
    return Math.floor(time / 60) - getHoursStats(time) * 60;
}

function getSecondsGame(time) {
    var t = Math.floor(time - Math.floor(time / 60) * 60);
    return `${Math.floor(t / 10)}${Math.floor(t % 10)}`;
}

function getSecondsReport(time) {
    var t = Math.round(time);
    return Math.floor(t - getMinutesReport(t) * 60);
}

function getSecondsEmbed(time) {
    var t = Math.round(time);
    var t2 = Math.floor(t - Math.floor(t / 60) * 60);
    return `${Math.floor(t2 / 10)}${Math.floor(t2 % 10)}`;
}

function getTimeGame(time) {
    return `[${getMinutesGame(time)}:${getSecondsGame(time)}]`;
}

function getTimeEmbed(time) {
    return `[${getMinutesEmbed(time)}:${getSecondsEmbed(time)}]`;
}

function getTimeStats(time) {
    if (getHoursStats(time) > 0) {
        return `${getHoursStats(time)}h${getMinutesStats(time)}m`;
    } else {
        return `${getMinutesStats(time)}m`;
    }
}

function getGoalGame() {
    return game.scores.red + game.scores.blue;
}

/* REPORT FUNCTIONS */

function findFirstNumberCharString(str) {
    let str_number = str[str.search(/[0-9]/g)];
    return str_number === undefined ? "0" : str_number;
}

function getIdReport() {
    var d = new Date();
    return `${d.getFullYear() % 100}${d.getMonth() < 9 ? '0' : ''}${d.getMonth() + 1}${d.getDate() < 10 ? '0' : ''}${d.getDate()}${d.getHours() < 10 ? '0' : ''}${d.getHours()}${d.getMinutes() < 10 ? '0' : ''}${d.getMinutes()}${d.getSeconds() < 10 ? '0' : ''}${d.getSeconds()}${findFirstNumberCharString(roomName)}`;
}

function getRecordingName(game) {
    let d = new Date();
    let redCap = game.playerComp[0][0] != undefined ? game.playerComp[0][0].player.name : 'Red';
    let blueCap = game.playerComp[1][0] != undefined ? game.playerComp[1][0].player.name : 'Blue';
    let day = d.getDate() < 10 ? '0' + d.getDate() : d.getDate();
    let month = d.getMonth() < 10 ? '0' + (d.getMonth() + 1) : (d.getMonth() + 1);
    let year = d.getFullYear() % 100 < 10 ? '0' + (d.getFullYear() % 100) : (d.getFullYear() % 100);
    let hour = d.getHours() < 10 ? '0' + d.getHours() : d.getHours();
    let minute = d.getMinutes() < 10 ? '0' + d.getMinutes() : d.getMinutes();
    return `${day}-${month}-${year}-${hour}h${minute}-${redCap}vs${blueCap}.hbr2`;
}

function fetchRecording(game) {
    if (gameWebhook == "") return;
    if (typeof FormData !== 'function' || typeof File !== 'function') {
        if (debugMode) {
            console.log('[fetchRecording] FormData/File unavailable, skipping recording upload.');
        }
        return;
    }
    try {
        let form = new FormData();
        form.append(null, new File([game.rec], getRecordingName(game), { "type": "text/plain" }));
        form.append("payload_json", JSON.stringify({
            "username": roomName
        }));

        safeFetch(gameWebhook, {
            method: 'POST',
            body: form,
        });
    } catch (err) {
        if (debugMode) {
            console.log('[fetchRecording] Failed to queue recording upload:', err);
        }
    }
}

/* FEATURE FUNCTIONS */

function getCommand(commandStr) {
    if (commands.hasOwnProperty(commandStr)) return commandStr;
    for (const [key, value] of Object.entries(commands)) {
        for (let alias of value.aliases) {
            if (alias == commandStr) return key;
        }
    }
    return false;
}

function getPlayerComp(player) {
    if (player == null || player.id == 0) return null;
    var comp = game.playerComp;
    var playerAuth = getPlayerAuth(player);
    var index = comp[0].findIndex((c) => c.auth == playerAuth);
    if (index != -1) return comp[0][index];
    index = comp[1].findIndex((c) => c.auth == playerAuth);
    if (index != -1) return comp[1][index];
    return null;
}

function getTeamArray(team, includeAFK = true) {
    if (team == Team.RED) return teamRed;
    if (team == Team.BLUE) return teamBlue;
    if (includeAFK) {
      return playersAll.filter((p) => p.team === Team.SPECTATORS);
    }
    return teamSpec;
}

function sendAnnouncementTeam(message, team, color, style, mention, sender) {
    for (let player of team) {
        if (!player) continue;
        if (sender && player.id !== sender.id && recipientIgnoresSender(player, sender.name)) continue;
        room.sendAnnouncement(message, player.id, color, style, mention);
    }
}

function getChatEmojiForPlayer(player) {
    try {
        if (
            typeof AFKSet !== "undefined" &&
            AFKSet instanceof Set &&
            player &&
            AFKSet.has(player.id)
        ) {
            return "\u{1F634}";
        }
    } catch (_) {}
    const badge = getRankEmojiForPlayer(player);
    return badge || "";
}

function teamChat(player, message) {
    var msgArray = message.split(/ +/).slice(1);
    var emoji = player.team == Team.RED ? 'ðŸ”´' : player.team == Team.BLUE ? 'ðŸ”µ' : 'âšª';
    const rankBadge = getChatEmojiForPlayer(player);
    var message = `${emoji} [TEAM] ${rankBadge ? rankBadge + ' ' : ''}${player.name}: ${msgArray.join(' ')}`;
    var team = getTeamArray(player.team, true);
    var color = player.team == Team.RED ? redChatColor : player.team == Team.BLUE ? blueChatColor : null;
    var style = 'bold';
    var mention = HaxNotification.CHAT;
    sendAnnouncementTeam(message, team, color, style, mention, player);
}

function playerChat(player, message) {
    var msgArray = message.split(/ +/);
    var playerTargetIndex = playersAll.findIndex(
        (p) => p.name.replaceAll(' ', '_') == msgArray[0].substring(2)
    );
    if (playerTargetIndex == -1) {
        room.sendAnnouncement(
            `Nie ma takiego numeru`,
            player.id,
            errorColor,
            'bold',
            null
        );
        return false;
    }
    var playerTarget = playersAll[playerTargetIndex];
    if (player.id == playerTarget.id) {
        room.sendAnnouncement(
            `Matce powiedz zeby do ciebie napisala`,
            player.id,
            errorColor,
            'bold',
            null
        );
        return false;
    }
    var senderAuth = getPlayerAuth(player);
    if (senderAuth) {
        var senderIgnoreSet = getIgnoreSet(senderAuth);
        if (senderIgnoreSet && senderIgnoreSet.has(normalizeIgnoreName(playerTarget.name))) {
            room.sendAnnouncement(
                `Masz ${playerTarget.name} na liÅ›cie ignorowanych. UÅ¼yj !ignore ${playerTarget.name}, aby wysÅ‚aÄ‡ wiadomoÅ›Ä‡.`,
                player.id,
                infoColor,
                'small',
                HaxNotification.CHAT
            );
            return false;
        }
    }
    if (recipientIgnoresSender(playerTarget, player.name)) {
        room.sendAnnouncement(
            `${playerTarget.name} ignoruje twoje wiadomoÅ›ci. Nie zostaÅ‚y dostarczone.`,
            player.id,
            infoColor,
            'small',
            HaxNotification.CHAT
        );
        return false;
    }
    const rankBadge = getChatEmojiForPlayer(player);
    const senderLabel = `${rankBadge ? rankBadge + ' ' : ''}${player.name}`;
    var messageFrom = `ðŸ“ [wiadomoÅ›Ä‡ prywatna do ${playerTarget.name}] ${senderLabel}: ${msgArray.slice(1).join(' ')}`

    var messageTo = `ðŸ“ [WiadomoÅ›Ä‡ prywatna od ${player.name}] ${senderLabel}: ${msgArray.slice(1).join(' ')}`

    room.sendAnnouncement(
        messageFrom,
        player.id,
        privateMessageColor,
        'bold',
        HaxNotification.CHAT
    );
    room.sendAnnouncement(
        messageTo,
        playerTarget.id,
        privateMessageColor,
        'bold',
        HaxNotification.CHAT
    );
}

/* PHYSICS FUNCTIONS */

function calculateStadiumVariables() {
    if (checkStadiumVariable && teamRed.length + teamBlue.length > 0) {
        checkStadiumVariable = false;
        setTimeout(() => {
            // Safe fetch of ball & player disc
            let ballDisc = ballProps();
            const firstPlayer = teamRed.concat(teamBlue)[0];
            let playerDisc = firstPlayer ? room.getPlayerDiscProperties(firstPlayer.id) : null;

            if (!ballDisc) {
                if (typeof refreshDiscIndexes === "function") refreshDiscIndexes();
                ballDisc = ballProps();
            }
            if (!ballDisc || !playerDisc) {
                // Unable to compute yet; try again shortly and exit gracefully.
                setTimeout(calculateStadiumVariables, 50);
                return;
            }

            const bR = typeof ballDisc.radius === "number" ? ballDisc.radius : 0;
            const pR = typeof playerDisc.radius === "number" ? playerDisc.radius : 0;
            const invM = typeof ballDisc.invMass === "number" ? ballDisc.invMass : 1;
            const damp = typeof ballDisc.damping === "number" ? ballDisc.damping : 0;

            ballRadius = bR;
            playerRadius = pR;
            triggerDistance = bR + pR + 0.01;
            speedCoefficient = 100 / (5 * invM * (Math.pow(damp, 60) + 1));
        }, 1);
    }
}

function checkGoalKickTouch(array, index, goal) {
    if (array != null && array.length >= index + 1) {
        var obj = array[index];
        if (obj != null && obj.goal != null && obj.goal == goal) return obj;
    }
    return null;
}

/* BUTTONS */

function topButton() {
    if (teamSpec.length > 0) {
        if (teamRed.length == teamBlue.length && teamSpec.length > 1) {
            room.setPlayerTeam(teamSpec[0].id, Team.RED);
            room.setPlayerTeam(teamSpec[1].id, Team.BLUE);
        } else if (teamRed.length < teamBlue.length)
            room.setPlayerTeam(teamSpec[0].id, Team.RED);
        else room.setPlayerTeam(teamSpec[0].id, Team.BLUE);
    }
}

function randomButton() {
    if (teamSpec.length > 0) {
        if (teamRed.length == teamBlue.length && teamSpec.length > 1) {
            var r = getRandomInt(teamSpec.length);
            room.setPlayerTeam(teamSpec[r].id, Team.RED);
            teamSpec = teamSpec.filter((spec) => spec.id != teamSpec[r].id);
            room.setPlayerTeam(teamSpec[getRandomInt(teamSpec.length)].id, Team.BLUE);
        } else if (teamRed.length < teamBlue.length)
            room.setPlayerTeam(teamSpec[getRandomInt(teamSpec.length)].id, Team.RED);
        else
            room.setPlayerTeam(teamSpec[getRandomInt(teamSpec.length)].id, Team.BLUE);
    }
}

function blueToSpecButton() {
    clearTimeout(removingTimeout);
    removingPlayers = true;
    removingTimeout = setTimeout(() => {
        removingPlayers = false;
    }, 100);
    for (var i = 0; i < teamBlue.length; i++) {
        room.setPlayerTeam(teamBlue[teamBlue.length - 1 - i].id, Team.SPECTATORS);
    }
}

function redToSpecButton() {
    clearTimeout(removingTimeout);
    removingPlayers = true;
    removingTimeout = setTimeout(() => {
        removingPlayers = false;
    }, 100);
    for (var i = 0; i < teamRed.length; i++) {
        room.setPlayerTeam(teamRed[teamRed.length - 1 - i].id, Team.SPECTATORS);
    }
}

function resetButton() {
    clearTimeout(removingTimeout);
    removingPlayers = true;
    removingTimeout = setTimeout(() => {
        removingPlayers = false;
    }, 100);
    for (let i = 0; i < Math.max(teamRed.length, teamBlue.length); i++) {
        if (Math.max(teamRed.length, teamBlue.length) - teamRed.length - i > 0)
            room.setPlayerTeam(teamBlue[teamBlue.length - 1 - i].id, Team.SPECTATORS);
        else if (Math.max(teamRed.length, teamBlue.length) - teamBlue.length - i > 0)
            room.setPlayerTeam(teamRed[teamRed.length - 1 - i].id, Team.SPECTATORS);
        else break;
    }
    for (let i = 0; i < Math.min(teamRed.length, teamBlue.length); i++) {
        room.setPlayerTeam(
            teamBlue[Math.min(teamRed.length, teamBlue.length) - 1 - i].id,
            Team.SPECTATORS
        );
        room.setPlayerTeam(
            teamRed[Math.min(teamRed.length, teamBlue.length) - 1 - i].id,
            Team.SPECTATORS
        );
    }
}

function swapButton() {
    clearTimeout(removingTimeout);
    removingPlayers = true;
    removingTimeout = setTimeout(() => {
        removingPlayers = false;
    }, 100);
    for (let player of teamBlue) {
        room.setPlayerTeam(player.id, Team.RED);
    }
    for (let player of teamRed) {
        room.setPlayerTeam(player.id, Team.BLUE);
    }
}

/* COMMAND FUNCTIONS */

/* PLAYER COMMANDS */

function leaveCommand(player, message) {
    setTimeout(function () {
        try {
            voluntaryLeaveIds.add(player.id);
            room.kickPlayer(player.id, VOLUNTARY_LEAVE_MESSAGE, false);
        } catch (_) {}
    }, 30);
}
function helpCommand(player, message) {
    var msgArray = message.split(/ +/).slice(1);
    
    // --- DEFINICJE KATEGORII I KOLORÃ“W ---
    const CATEGORY_DEFINITIONS = {
        'GRACZ': { title: 'ðŸ‘¤ OGÃ“LNE KOMENDY GRACZA', color: infoColor, roles: Role.PLAYER },
        'EKO': { title: 'ðŸ’° EKONOMIA I SKLEP', color: 0x00FF00, roles: Role.PLAYER },
        'CASINO': { title: 'ðŸŽ° KASYNO', color: 0xFF69B4, roles: Role.PLAYER },
        'ELO': { title: 'ðŸ‘‘ ELO I RANKING', color: 0xFFD700, roles: Role.PLAYER },
        'STATY': { title: 'ðŸ“ˆ STATYSTYKI GRY', color: 0x82C1D9, roles: Role.PLAYER },
        'MAPY': { title: 'ðŸ—ºï¸ ZMIANA MAP', color: 0x3399ff, roles: Role.ADMIN_TEMP },
        'MOD': { title: 'ðŸ›¡ï¸ MODERACJA I KICKI', color: redColor, roles: Role.ADMIN_TEMP },
        'MASTER': { title: 'ðŸ› ï¸ ZARZÄ„DZANIE SERWEREM (Master)', color: errorColor, roles: Role.MASTER },
    };
    // -------------------------------------------

    if (msgArray.length == 0) {
        
        // 1. NagÅ‚Ã³wek (Ramka)
        room.sendAnnouncement(`â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—`, player.id, 0xFFFFFF, 'bold', HaxNotification.CHAT);
        room.sendAnnouncement(`â•‘       ðŸ“š P O M O C (Komendy) ðŸ“š      â•‘`, player.id, 0xFFFFFF, 'bold', HaxNotification.CHAT);
        room.sendAnnouncement(`â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•`, player.id, 0xFFFFFF, 'bold', HaxNotification.CHAT);
        
        let categoriesData = {};

        // 2. Zbieranie komend do kategorii
        for (const [key, value] of Object.entries(commands)) {
            if (!value.desc) continue; 

            const categoryKey = value.category || 'GRACZ';
            const categoryInfo = CATEGORY_DEFINITIONS[categoryKey] || CATEGORY_DEFINITIONS['GRACZ'];

            // Ustalanie uprawnieÅ„: PokaÅ¼ tylko, jeÅ›li rola gracza jest WYÅ»SZA lub RÃ“WNA wymaganej
            if (getRole(player) < categoryInfo.roles) continue;
            // Dodatkowe sprawdzenie dla ADMIN_PERM vs ADMIN_TEMP
            if (value.roles > getRole(player) && value.roles !== Role.MASTER) continue;


            if (!categoriesData[categoryKey]) {
                categoriesData[categoryKey] = {
                    title: categoryInfo.title,
                    color: categoryInfo.color,
                    commands: []
                };
            }
            
            categoriesData[categoryKey].commands.push(`!${key}`);
        }

        // 3. Sortowanie i wyÅ›wietlanie komend (Master -> Mod -> Player)
        const sortedCategories = Object.keys(categoriesData).sort((a, b) => {
            return CATEGORY_DEFINITIONS[b].roles - CATEGORY_DEFINITIONS[a].roles;
        });

        for (const key of sortedCategories) {
            const data = categoriesData[key];
            if (data.commands.length === 0) continue;

            // WyÅ›wietl nagÅ‚Ã³wek kategorii (USUNIÄ˜TO \n)
            room.sendAnnouncement(`${data.title}:`, player.id, data.color, 'bold', HaxNotification.CHAT);
            
            // WyÅ›wietl listÄ™ komend
            const commandsList = data.commands.join(' ');
            room.sendAnnouncement(commandsList, player.id, data.color, 'small', HaxNotification.CHAT);
        }

        // 4. Stopka (USUNIÄ˜TO \n)
        room.sendAnnouncement(
            `âž¡ï¸ UÅ¼yj '!help <komenda>', aby zobaczyÄ‡ opis i uÅ¼ycie.`,
            player.id,
            infoColor,
            'small',
            HaxNotification.CHAT
        );

    } else if (msgArray.length >= 1) {
        var commandName = getCommand(msgArray[0].toLowerCase());
        if (commandName != false && commands[commandName].desc != false)
            room.sendAnnouncement(
                `\'${commandName}\' komenda :\n${commands[commandName].desc}`,
                player.id,
                infoColor,
                'small',
                HaxNotification.CHAT
            );
        else
            room.sendAnnouncement(
                `Nie ma takiej komendy.`,
                player.id,
                errorColor,
                'small',
                HaxNotification.CHAT
            );
    }
}

function globalStatsCommand(player, message) {
    var stats = new HaxStatistics(player.name);
    var storageKey = getPlayerAuth(player);
    if (storageKey && localStorage.getItem(storageKey)) {
        stats = JSON.parse(localStorage.getItem(storageKey));
    }
    var statsString = printPlayerStats(stats);
    room.sendAnnouncement(
        statsString,
        player.id,
        infoColor,
        'bold',
        HaxNotification.CHAT
    );
}

function renameCommand(player, message) {
    var msgArray = message.split(/ +/).slice(1);
    var storageKey = getPlayerAuth(player);
    if (storageKey && localStorage.getItem(storageKey)) {
        var stats = JSON.parse(localStorage.getItem(storageKey));
        if (msgArray.length == 0) {
            stats.playerName = player.name;
        } else {
            stats.playerName = msgArray.join(' ');
        }
        localStorage.setItem(storageKey, JSON.stringify(stats));
        room.sendAnnouncement(
            `PrzechrzciÄ¹â€šeÄ¹â€º siÃ„â„¢ skutecznie ${stats.playerName} !`,
            player.id,
            successColor,
            'bold',
            HaxNotification.CHAT
        );
    } else {
        room.sendAnnouncement(
            `Jeszcze tu nie graÅ‚eÅ›`,
            player.id,
            errorColor,
            'bold',
            HaxNotification.CHAT
        );
    }
}

function statsLeaderboardCommand(player, message) {
    var key = message.split(/ +/)[0].substring(1).toLowerCase();
    // Mapuj polskie aliasy (i kanoniczne) na klucz statystyki
    // Nie tworzymy nowych helperÃ³w â€“ wszystko inline
    var map = {
        'gry': 'games',
        'games': 'games',
        'zwyciestwa': 'wins',
        'wygrane': 'wins',
        'wins': 'wins',
        'przegrane': 'losses',
        'porazki': 'losses',
        'loses': 'losses',
        'losses': 'losses',
        'gole': 'goals',
        'bramki': 'goals',
        'goals': 'goals',
        'asysty': 'assists',
        'assists': 'assists',
        'cs': 'cs',
        'czystokonto': 'cs',
        'czas': 'playtime',
        'playtime': 'playtime'
    };
    key = map[key] || key;
    printRankings(key, player.id);
}

function rankingCommand(player, message) {
    const tokens = (message || '').trim().split(/\s+/);
    const PAGE_SIZE = 10;
    let standings = Object.entries(elo.ratings || {}).map(([authId, rating]) => {
        const value = Number(rating);
        return [authId, Number.isFinite(value) ? value : baseElo];
    });
    standings.sort((a, b) => b[1] - a[1]);

    const total = standings.length;
    if (total === 0) {
        const info = 'Ranking jest pusty - rozegraj mecz, aby siÄ™ pojawiÄ‡.';
        room.sendAnnouncement(info, player.id, infoColor, 'small', HaxNotification.CHAT);
        room.sendAnnouncement('PodpowiedÅº: uÅ¼yj "!ranking {nr}" albo "!ranking me".', player.id, infoColor, 'small', HaxNotification.CHAT);
        return false;
    }

    let page = 1;
    if (tokens.length >= 2) {
        const arg = tokens[1].toLowerCase();
        if (arg === 'me') {
            const auth = getAuthIdByPlayer(player);
            const index = standings.findIndex(([id]) => id === auth);
            page = index >= 0 ? Math.floor(index / PAGE_SIZE) + 1 : 1;
        } else {
            const num = parseInt(arg, 10);
            if (!Number.isNaN(num) && num >= 1) page = num;
        }
    }

    const totalPages = Math.max(1, Math.ceil(total / PAGE_SIZE));
    if (page > totalPages) page = totalPages;

    const start = (page - 1) * PAGE_SIZE;
    const slice = standings.slice(start, start + PAGE_SIZE);

    const header = `Ranking ELO - strona ${page}/${totalPages} (pozycje ${start + 1}-${start + slice.length} z ${total})`;
    room.sendAnnouncement(header, player.id, infoColor, 'small', HaxNotification.CHAT);

    for (let i = 0; i < slice.length; i++) {
        const [authId, rating] = slice[i];
        ensureProfile(authId);
        const label = classLabel(rating);
        const emoji = rankEmoji(label);
        const name = (elo.names && elo.names[authId]) ? elo.names[authId] : authId;
        const position = start + i + 1;
        const line = `#${position} ${emoji} ${name}: ${rating.toFixed(1)}${label ? ` | ${label}` : ''}`;
        const color = rankColor(label);
        room.sendAnnouncement(line, player.id, color, 'small', HaxNotification.CHAT);
    }

    const auth = getAuthIdByPlayer(player);
    const myIndex = standings.findIndex(([id]) => id === auth);
    if (myIndex >= 0) {
        const myRating = standings[myIndex][1];
        const myLabel = classLabel(myRating);
        const myEmoji = rankEmoji(myLabel);
        const summary = `Twoja pozycja: #${myIndex + 1} - ${myEmoji} ${player.name} | ${myRating.toFixed(1)}${myLabel ? ` | ${myLabel}` : ''}`;
        room.sendAnnouncement(summary, player.id, rankColor(myLabel), 'small', HaxNotification.CHAT);
    } else {
        room.sendAnnouncement('Brak pozycji (brak gier).', player.id, infoColor, 'small', HaxNotification.CHAT);
    }

    room.sendAnnouncement('PodpowiedÅº: uÅ¼yj "!ranking {nr}" albo "!ranking me".', player.id, infoColor, 'small', HaxNotification.CHAT);
    return false;
}

function resetEloCommand(player, message) {
    try {
        if (typeof globalThis.__eloResetCommand === 'function') {
            const outcome = globalThis.__eloResetCommand(player, message);
            return outcome === undefined ? false : outcome;
        }
        room.sendAnnouncement(
            `Komenda chwilowo niedostÄ™pna.`,
            player.id,
            errorColor,
            'bold',
            HaxNotification.CHAT
        );
        return false;
    } catch (_) {
        room.sendAnnouncement(
            `Nie udaÅ‚o siÄ™ przetworzyÄ‡ komendy.`,
            player.id,
            errorColor,
            'bold',
            HaxNotification.CHAT
        );
        return false;
    }
}

function clearAFKTracking(playerId) {
    AFKSet.delete(playerId);
    AFKStartTimes.delete(playerId);
    AFKWarnedSet.delete(playerId);
}

function getAFKCooldownKey(player) {
    if (!player) return null;
    const authKey = getPlayerAuth(player);
    if (authKey) {
        return `auth:${authKey}`;
    }
    const connKey = getPlayerConn(player);
    if (connKey) {
        return `conn:${connKey}`;
    }
    return `id:${player.id}`;
}

function afkCommand(player, message) {
    const now = Date.now();
    const cooldownKey = getAFKCooldownKey(player);
    const cooldownUntil = cooldownKey ? (AFKCooldownUntilByKey.get(cooldownKey) || 0) : 0;
    const idCooldownUntil = AFKCommandCooldownUntilById.get(player.id) || 0;
    if (cooldownKey) {
        AFKCooldownKeyById.set(player.id, cooldownKey);
    }
    const effectiveCooldown = cooldownUntil || idCooldownUntil;
    if (effectiveCooldown && now < effectiveCooldown) {
        const remainingSec = Math.max(0, Math.ceil((effectiveCooldown - now) / 1000));
        room.sendAnnouncement(
            `ðŸš« Spokojnie, zostaÅ‚o ci ${remainingSec} sekund siedzenia na dupie.`,
            player.id,
            warningColor,
            'small',
            HaxNotification.CHAT
        );
        return;
    }

    if (AFKSet.has(player.id)) {

        clearAFKTracking(player.id);
        room.sendAnnouncement(`ðŸŒ… ${player.name} Nie jest juÅ¼ AFK!`, null, announcementColor, 'small', null);
        if (cooldownKey) {
            AFKCooldownUntilByKey.set(cooldownKey, now + AFK_COOLDOWN_MS);
        }
        AFKCommandCooldownUntilById.set(player.id, now + AFK_COOLDOWN_MS);
        movePlayerToQueueEnd(player.id);
        updateTeams();
        handlePlayersJoin();

    } else {
        const previousTeam = player.team;
        AFKSet.add(player.id);
        AFKStartTimes.set(player.id, now);
        AFKWarnedSet.delete(player.id);
        if (previousTeam === Team.RED || previousTeam === Team.BLUE){
            try{
                const auth = getPlayerAuth(player);
                const g = (typeof globalThis !== 'undefined') ? globalThis
                          : (typeof window !== 'undefined' ? window : {});
                if (auth && typeof g.__eloApplyAfkPenalty === 'function'){
                    g.__eloApplyAfkPenalty(auth, previousTeam, player?.name, false);
                }
            }catch(_){}
        }
        room.setPlayerTeam(player.id, Team.SPECTATORS);
        movePlayerToQueueEnd(player.id);
        room.sendAnnouncement(
            `ðŸ˜´ ${player.name} Jest afk`,
            player.id,
            announcementColor,
            'small',
            null
        );
        if (cooldownKey) {
            AFKCooldownUntilByKey.set(cooldownKey, now + AFK_COOLDOWN_MS);
        }
        AFKCommandCooldownUntilById.set(player.id, now + AFK_COOLDOWN_MS);
        updateTeams();
        handlePlayersLeave();
        balanceTeams();
    }
}

function afkListCommand(player, message) {
    if (AFKSet.size == 0) {
        room.sendAnnouncement(
            "ðŸ˜´ Nik nie jest afk!",
            player.id,
            announcementColor,
            'small',
            null
        );
        return;
    }
    var cstm = 'ðŸ˜´ AFK list : ';
    AFKSet.forEach((_, value) => {
        var p = room.getPlayer(value);
        if (p != null) cstm += `ðŸ˜´ ${p.name}, `;
    });
    cstm = cstm.substring(0, cstm.length - 2) + '.';
    room.sendAnnouncement(cstm, player.id, announcementColor, 'small', null);
}

function masterCommand(player, message) {
    var msgArray = message.split(/ +/).slice(1);
    var playerAuth = getPlayerAuth(player);
    var isInMasterRole = playerAuth ? masterList.includes(playerAuth) : false;
    var isInAdminRole = playerAuth ? adminList.find(a => a[0] == playerAuth) : null;
    if (msgArray[0] == masterPassword && (isInMasterRole || isInAdminRole)) {
        if (!player.admin) {
            
            room.setPlayerAdmin(player.id, true);
            room.sendAnnouncement(
                `${player.name} jest ${isInMasterRole ? 'adminem' : 'adminem'}.`,
                player.id,
                announcementColor,
                'bold',
                HaxNotification.CHAT
            );
        } else {
            room.sendAnnouncement(
                `JesteÅ› juz adminem !`,
                player.id,
                errorColor,
                'bold',
                HaxNotification.CHAT
            );
        }
    }
}

/* ADMIN COMMANDS */
/* === RÄ˜CZNA OBSÅUGA ELO === */

function manualEloCommand(player, message) {
    var msgArray = message.split(/ +/);
    var cmd = msgArray[0].toLowerCase();
    var isAdd = (cmd === "!addelo");
    
    if (msgArray.length < 3) {
        room.sendAnnouncement(`UÅ¼ycie: ${cmd} #ID/@Auth <iloÅ›Ä‡>`, player.id, errorColor, 'bold', HaxNotification.CHAT);
        return;
    }

    var targetInput = msgArray[1];
    var amount = parseInt(msgArray[2]);

    if (isNaN(amount) || amount < 0) {
        room.sendAnnouncement(`Podaj poprawnÄ… liczbÄ™ punktÃ³w.`, player.id, errorColor, 'bold', HaxNotification.CHAT);
        return;
    }

    var targetAuth = null;
    var targetName = "Gracz";
    var targetPlayerObj = null;

    // 1. Szukanie po ID
    if (targetInput.startsWith("#")) {
        var id = parseInt(targetInput.substring(1));
        var p = room.getPlayer(id);
        if (p) {
            targetAuth = (typeof getAuthIdByPlayer === "function") ? getAuthIdByPlayer(p) : p.auth;
            targetName = p.name;
            targetPlayerObj = p;
        } else {
            room.sendAnnouncement(`Nie ma gracza o ID ${id}.`, player.id, errorColor, 'bold', HaxNotification.CHAT);
            return;
        }
    } 
    // 2. Szukanie po Auth
    else if (targetInput.startsWith("@")) {
        targetAuth = targetInput.substring(1);
        if (globalThis.eloStore && globalThis.eloStore.names && globalThis.eloStore.names[targetAuth]) {
            targetName = globalThis.eloStore.names[targetAuth];
        } else {
            targetName = targetAuth.substring(0, 10) + "...";
        }
    } else {
        targetAuth = targetInput;
    }

    var store = globalThis.eloStore;
    if (!store || !store.ratings) {
        room.sendAnnouncement(`BÅ‚Ä…d: Baza ELO niedostÄ™pna.`, player.id, errorColor, 'bold', HaxNotification.CHAT);
        return;
    }

    if (typeof ensureProfile === "function") ensureProfile(targetAuth, targetName);
    
    var current = Number(store.ratings[targetAuth]);
    if (isNaN(current)) current = 1000;

    var change = isAdd ? amount : -amount;
    var newElo = current + change;
    if (newElo < 0) newElo = 0;

    // --- SPRAWDZANIE BANA PRZY RÄ˜CZNEJ ZMIANIE ---
    if (newElo < 800) {
        newElo = 1000; // Reset
        store.ratings[targetAuth] = newElo;
        localStorage.setItem("__eloStore", JSON.stringify(store));

        room.sendAnnouncement(`ðŸ“‰ ${targetName} spadÅ‚ poniÅ¼ej 800 ELO (po edycji admina)! Ban 48h + Reset.`, null, errorColor, 'bold', HaxNotification.CHAT);

        if (typeof getBanDurationInfo === 'function' && typeof registerTimedBan === 'function') {
            const durInfo = getBanDurationInfo('48h');
            registerTimedBan(targetPlayerObj, player, durInfo, "Spadek poniÅ¼ej 800 pkt (Admin)", {
                targetAuth: targetAuth,
                targetName: targetName
            });
        }
        if (targetPlayerObj) {
            room.kickPlayer(targetPlayerObj.id, "SpadÅ‚eÅ› poniÅ¼ej 800 ELO. Ban 48h.", false);
        }
        return; // KoÅ„czymy funkcjÄ™, bo gracz zbanowany
    }
    // ---------------------------------------------

    store.ratings[targetAuth] = newElo;
    localStorage.setItem("__eloStore", JSON.stringify(store));

    var action = isAdd ? "Dodano" : "OdjÄ™to";
    var color = isAdd ? successColor : warningColor;
    
    room.sendAnnouncement(`ðŸ“ ${action} ${amount} pkt ELO dla gracza ${targetName}.`, null, color, 'bold', HaxNotification.CHAT);
    room.sendAnnouncement(`Nowy ranking: ${newElo.toFixed(1)}`, player.id, color, 'small', HaxNotification.CHAT);
}

function resetSeasonCommand(player, message) {
    var msgArray = message.split(/ +/);
    
    // Zabezpieczenie: wymagane potwierdzenie
    if (msgArray.length < 2 || msgArray[1].toLowerCase() !== "potwierdzam") {
        room.sendAnnouncement(`âš ï¸ UWAGA: Ta komenda CAÅKOWICIE USUNIE bazÄ™ ELO i historiÄ™ graczy!`, player.id, errorColor, 'bold', HaxNotification.CHAT);
        room.sendAnnouncement(`To odciÄ…Å¼y serwer, ale wszyscy stracÄ… statystyki.`, player.id, warningColor, 'bold', HaxNotification.CHAT);
        room.sendAnnouncement(`Aby potwierdziÄ‡, wpisz: !resetseason potwierdzam`, player.id, warningColor, 'bold', HaxNotification.CHAT);
        return;
    }

    // 1. Czyszczenie istniejÄ…cego obiektu (NIE nadpisywanie go nowym!)
    // To kluczowe, aby moduÅ‚ ELO "widziaÅ‚" te zmiany.
    if (typeof globalThis.eloStore !== 'undefined') {
        globalThis.eloStore.ratings = Object.create(null);
        globalThis.eloStore.games = Object.create(null);
        globalThis.eloStore.names = Object.create(null);
        globalThis.eloStore.resets = Object.create(null);

        // Bezpieczny zapis do localStorage
        try {
            if (typeof localStorage !== 'undefined') {
                localStorage.setItem("__eloStore", JSON.stringify(globalThis.eloStore));
            }
        } catch (e) {}
    }

    // 2. Wyczyszczenie pamiÄ™ci podrÄ™cznej znanych graczy
    if (typeof knownPlayersByAuth !== 'undefined') {
        knownPlayersByAuth = Object.create(null);
    }

    room.sendAnnouncement(`ðŸ—‘ï¸ BAZA DANYCH I CACHE WYCZYSZCZONE!`, null, 0xFFD700, 'bold', HaxNotification.CHAT);
    room.sendAnnouncement(`Rozpoczynamy nowy sezon z czystÄ… kartÄ….`, null, announcementColor, 'small', HaxNotification.CHAT);
    
    // Wymuszenie aktualizacji rankingu na Discordzie (pokaÅ¼e, Å¼e jest pusty)
    setTimeout(sendRankingToDiscord, 1000);
}
function restartNoEloCommand(player, message) {
    try {
        const eloState = (typeof globalThis !== 'undefined' && globalThis.__eloState) ? globalThis.__eloState : null;
        if (eloState && typeof eloState === 'object') {
            eloState.settled = true;
            eloState.ranked = false;
            eloState.active = false;
        }
    } catch (_){}
    try {
        const pending = (typeof globalThis !== 'undefined' && globalThis.__eloPendingWalkover) ? globalThis.__eloPendingWalkover : null;
        if (pending && typeof pending === 'object') {
            pending.authId = null;
            pending.teamId = 0;
            pending.ts = 0;
        }
    } catch (_){}
    try {
        instantRestart();
        try {
            const notice = `Restart bez naliczania ELO wykonany przez ${player.name || 'admina'}.`;
            room.sendAnnouncement(notice, null, announcementColor, 'bold', HaxNotification.CHAT);
        } catch (_){}
    } catch (e) {
        try {
            room.sendAnnouncement(
                `Nie udalo sie zrestartowac meczu.`,
                player.id,
                errorColor,
                'bold',
                HaxNotification.CHAT
            );
        } catch (_){}
    }
}

function swapCommand(player, message) {
    if (playSituation == Situation.STOP) {
        swapButton();
        room.sendAnnouncement(
            'âœ”ï¸ DruÅ¼yny przerzucone!',
            player.id,
            announcementColor,
            'bold',
            null
        );
    } else {
        room.sendAnnouncement(
            `Zatrzymaj grÄ™, przed przerzucankiem`,
            player.id,
            errorColor,
            'bold',
            HaxNotification.CHAT
        );
    }
}

function kickTeamCommand(player, message) {
    var msgArray = message.split(/ +/);
    var reasonString = `Druzyna wyjebana dziÄ™ki ${player.name}!`;
    if (msgArray.length > 1) {
        reasonString = msgArray.slice(1).join(' ');
    }
    if (['!kickred', '!kickr'].includes(msgArray[0].toLowerCase())) {
        for (let i = 0; i < teamRed.length; i++) {
            setTimeout(() => {
                room.kickPlayer(teamRed[0].id, reasonString, false);
            }, i * 20)
        }
    } else if (['!kickblue', '!kickb'].includes(msgArray[0].toLowerCase())) {
        for (let i = 0; i < teamBlue.length; i++) {
            setTimeout(() => {
                room.kickPlayer(teamBlue[0].id, reasonString, false);
            }, i * 20)
        }
    } else if (['!kickspec', '!kicks'].includes(msgArray[0].toLowerCase())) {
        for (let i = 0; i < teamSpec.length; i++) {
            setTimeout(() => {
                room.kickPlayer(teamSpec[0].id, reasonString, false);
            }, i * 20)
        }
    }
}

function timedBanCommand(player, message) {
    if (disableBans) {
        room.sendAnnouncement(
            'Bany sa obecnie wylaczone.',
            player.id,
            errorColor,
            'bold',
            HaxNotification.CHAT
        );
        return;
    }
    var args = message.split(/ +/).slice(1);
    const isTargetToken = (tok) => {
        if (typeof tok !== 'string' || tok.length === 0) return false;
        if (tok.startsWith('#') || tok.startsWith('@')) return true;
        if (tok.startsWith('auth:')) return true;
        return /^\d+$/.test(tok);
    };
    const findDurationIndex = (arr) => {
        if (!Array.isArray(arr)) return -1;
        for (let i = 0; i < arr.length; i++) {
            const norm = (arr[i] || '').toLowerCase();
            if (BAN_DURATION_BASE.hasOwnProperty(norm) || BAN_DURATION_ALIASES.hasOwnProperty(norm)) {
                return i;
            }
        }
        return -1;
    };
    if (!isTargetToken(args[0])) {
        try {
            const bracketMatches = [...message.matchAll(/\[([A-Za-z0-9_\-]{10,})\]/g)];
            let bestAuth = null;
            for (const match of bracketMatches) {
                if (match && match[1]) {
                    if (!bestAuth || match[1].length > bestAuth.length) {
                        bestAuth = match[1];
                    }
                }
            }
            if (bestAuth) {
                const durIndex = findDurationIndex(args);
                if (durIndex !== -1) {
                    const rebuilt = ['@' + bestAuth, args[durIndex]];
                    for (let i = durIndex + 1; i < args.length; i++) {
                        rebuilt.push(args[i]);
                    }
                    args = rebuilt;
                }
            }
        } catch (_) {}
    }
    if (args.length < 2) {
        room.sendAnnouncement(
            'Uzycie: !ban #<id>|@auth <czas> [powod]. Czasy: ' + BAN_ALLOWED_TOKENS.join(' ') + BAN_DYNAMIC_HELP + '.',
            player.id,
            errorColor,
            'bold',
            HaxNotification.CHAT
        );
        return;
    }
    var targetToken = args[0];
    var durationJoinEnd = 1;
    var durationTokenRaw = args[1].toLowerCase();
    for (var i = 2; i < args.length; i++) {
        var candidate = (args[i] || '').toLowerCase();
        if (/^\d+(?:[.,]\d+)?[a-z]*$/.test(candidate)) {
            durationTokenRaw += candidate;
            durationJoinEnd = i;
        } else {
            break;
        }
    }
    var durationInfo = getBanDurationInfo(durationTokenRaw);
    if (!durationInfo || durationInfo.ms > BAN_MAX_DURATION_MS) {
        room.sendAnnouncement(
            'Niepoprawny czas. Czasy: ' + BAN_ALLOWED_TOKENS.join(' ') + BAN_DYNAMIC_HELP + '.',
            player.id,
            errorColor,
            'bold',
            HaxNotification.CHAT
        );
        return;
    }
    var reasonStartIndex = durationJoinEnd + 1;
    var reasonText = reasonStartIndex < args.length ? args.slice(reasonStartIndex).join(' ').trim() : '';
    var targetPlayer = null;
    var targetAuth = null;
    var targetName = null;
    var offlineTarget = false;
    if (targetToken.length > 0 && targetToken[0] === '#') {
        var idToken = targetToken.substring(1);
        var targetId = parseInt(idToken, 10);
        if (isNaN(targetId) || targetId <= 0) {
            room.sendAnnouncement(
                'Podaj poprawne ID gracza.',
                player.id,
                errorColor,
                'bold',
                HaxNotification.CHAT
            );
            return;
        }
        targetPlayer = room.getPlayer(targetId);
        if (!targetPlayer) {
            var known = findKnownPlayerByLastId(targetId);
            if (known) {
                targetAuth = known.auth;
                targetName = known.info && known.info.name ? known.info.name : known.auth;
                offlineTarget = true;
            } else {
                room.sendAnnouncement(
                    'Nie ma gracza o ID ' + targetId + '.',
                    player.id,
                    errorColor,
                    'bold',
                    HaxNotification.CHAT
                );
                return;
            }
        }
    } else if (targetToken.startsWith('@')) {
        targetAuth = targetToken.substring(1);
        offlineTarget = true;
    } else if (targetToken.startsWith('auth:')) {
        targetAuth = targetToken.substring(5);
        offlineTarget = true;
    } else {
        room.sendAnnouncement(
            'Podaj cel jako #<id> lub @auth.',
            player.id,
            errorColor,
            'bold',
            HaxNotification.CHAT
        );
        return;
    }
    if (targetAuth) {
        targetAuth = targetAuth.trim();
    }
    if (targetPlayer) {
        targetAuth = targetAuth || getPlayerAuth(targetPlayer);
        targetName = targetPlayer.name;
    }
    if (!targetPlayer && targetAuth) {
        try {
            const liveMatch = room.getPlayerList().find(p => getPlayerAuth(p) === targetAuth);
            if (liveMatch) {
                targetPlayer = liveMatch;
                offlineTarget = false;
                targetName = targetPlayer.name;
            }
        } catch (_) {}
    }
    if (offlineTarget && (!targetAuth || targetAuth.length === 0)) {
        room.sendAnnouncement(
            'Nie znam auth tego gracza. Skopiuj wartosc z logow.',
            player.id,
            errorColor,
            'bold',
            HaxNotification.CHAT
        );
        return;
    }
    var authIsMaster = targetAuth ? masterList.includes(targetAuth) : false;
    var authIsPermAdmin = false;
    if (targetAuth) {
        for (var i = 0; i < adminList.length; i++) {
            if (adminList[i][0] === targetAuth) {
                authIsPermAdmin = true;
                break;
            }
        }
    }
    if (targetPlayer) {
        if (targetPlayer.id === player.id) {
            room.sendAnnouncement(
                'Nie mozesz banowac siebie.',
                player.id,
                errorColor,
                'bold',
                HaxNotification.CHAT
            );
            return;
        }
        if (targetPlayer.id === 0) {
            room.sendAnnouncement(
                'Nie da sie zbanowac hosta.',
                player.id,
                errorColor,
                'bold',
                HaxNotification.CHAT
            );
            return;
        }
        if (authIsMaster || authIsPermAdmin || getRole(targetPlayer) >= Role.ADMIN_PERM) {
            room.sendAnnouncement(
                'Nie mozesz banowac innego admina.',
                player.id,
                errorColor,
                'bold',
                HaxNotification.CHAT
            );
            return;
        }
    } else {
        if (authIsMaster || authIsPermAdmin) {
            room.sendAnnouncement(
                'Nie mozesz banowac innego admina.',
                player.id,
                errorColor,
                'bold',
                HaxNotification.CHAT
            );
            return;
        }
    }
    var adminName = player && player.name ? player.name : 'admin';
    var durationLabel = durationInfo.label || durationToken;
    var kickReason = reasonText.length > 0
        ? '[' + durationLabel + '] ' + reasonText
        : 'Ban na ' + durationLabel + ' (przez ' + adminName + ')';
    var record = null;
    if (targetPlayer) {
        try {
            room.kickPlayer(targetPlayer.id, kickReason, true);
        } catch (_) {
            room.sendAnnouncement(
                'Nie udalo sie zbanowac ' + targetPlayer.name + '.',
                player.id,
                errorColor,
                'bold',
                HaxNotification.CHAT
            );
            return;
        }
        record = registerTimedBan(targetPlayer, player, durationInfo, reasonText, {
            targetAuth: targetAuth || null,
            targetName: targetPlayer.name
        });
    } else {
        var knownName = targetName || (targetAuth ? targetAuth : 'Gracz');
        if (targetAuth) {
            if (!knownPlayersByAuth[targetAuth]) {
                knownPlayersByAuth[targetAuth] = { name: knownName, lastSeen: Date.now(), lastId: null, conn: null };
            } else if (!knownPlayersByAuth[targetAuth].name) {
                knownPlayersByAuth[targetAuth].name = knownName;
            }
        }
        record = registerTimedBan(null, player, durationInfo, reasonText, {
            targetAuth: targetAuth,
            targetName: knownName,
            offline: true
        });
        if (!record) {
            room.sendAnnouncement(
                'Nie udalo sie zapisac bana.',
                player.id,
                errorColor,
                'bold',
                HaxNotification.CHAT
            );
            return;
        }
    }
    if (record) {
        record.name = record.name || targetName || (targetPlayer ? targetPlayer.name : targetAuth);
        var existingIndex = -1;
        for (let i = 0; i < banList.length; i++) {
            if (banList[i][1] === record.key) {
                existingIndex = i;
                break;
            }
        }
        if (existingIndex === -1) {
            banList.push([record.name, record.key]);
        } else {
            banList[existingIndex][0] = record.name;
        }
        persistBanState();
    }
    var announceTargetName = (targetPlayer && targetPlayer.name) || targetName || (record ? record.name : 'gracz');
    room.sendAnnouncement(
        'ðŸš« ' + announceTargetName + ' dostal bana na ' + durationLabel + '.',
        null,
        announcementColor,
        'bold',
        HaxNotification.CHAT
    );
    if (!targetPlayer && targetAuth) {
        room.sendAnnouncement(
            'Ban zostanie wyegzekwowany przy najblizszym wejsciu gracza.',
            player.id,
            infoColor,
            'bold',
            HaxNotification.CHAT
        );
    }
}

function stadiumCommand(player, message) {
    var msgArray = message.split(/ +/);

    // --- FIX: AUTO-STOP Z OPÃ“Å¹NIENIEM ---
    // JeÅ›li to Bot (ID 0) i gra trwa, zatrzymujemy jÄ… i prÃ³bujemy ponownie za 100ms
    if (player.id === 0 && gameState !== State.STOP) {
        room.stopGame();
        setTimeout(() => {
            stadiumCommand(player, message);
        }, 100); // 100ms czasu na zatrzymanie silnika gry
        return;
    }
    // ------------------------------------

    if (gameState == State.STOP) {
        var stadiumChanged = false;
        if (['!classic'].includes(msgArray[0].toLowerCase())) {
            if (JSON.parse(classicMap).name == 'Classic') {
                room.setDefaultStadium('Classic');
            } else {
                room.setCustomStadium(classicMap);
            }
            currentStadium = 'classic';
            stadiumChanged = true;
        } else if (['!big'].includes(msgArray[0].toLowerCase())) {
            if (JSON.parse(bigMap).name == 'Big') {
                room.setDefaultStadium('Big');
            } else {
                room.setCustomStadium(bigMap);
            }
            currentStadium = 'big';
            stadiumChanged = true;
        } else if (['!training'].includes(msgArray[0].toLowerCase())) {
            room.setCustomStadium(trainingMap);
            currentStadium = 'training';
            stadiumChanged = true;
        } else {
            room.sendAnnouncement(
                `Stadium not recognized.`,
                player.id,
                errorColor,
                'bold',
                HaxNotification.CHAT
            );
        }
        if (stadiumChanged) {
            scheduleIndicatorDiscovery();
        }
    } else {
        room.sendAnnouncement(
            `Zatrzymaj grÄ™, zanim uÅ¼yjesz tej komendy`,
            player.id,
            errorColor,
            'bold',
            HaxNotification.CHAT
        );
    }
}

function muteCommand(player, message) {
    var msgArray = message.split(/ +/).slice(1);
    if (msgArray.length > 0) {
        if (msgArray[0].length > 0 && msgArray[0][0] == '#') {
            msgArray[0] = msgArray[0].substring(1, msgArray[0].length);
            if (room.getPlayer(parseInt(msgArray[0])) != null) {
                var playerMute = room.getPlayer(parseInt(msgArray[0]));
                var minutesMute = muteDuration;
                if (msgArray.length > 1 && parseInt(msgArray[1]) > 0) {
                    minutesMute = parseInt(msgArray[1]);
                }
                if (!playerMute.admin) {
                    var muteAuth = getPlayerAuth(playerMute);
                    var muteObj = new MutePlayer(playerMute.name, playerMute.id, muteAuth);
                    muteObj.setDuration(minutesMute);
                    room.sendAnnouncement(
                        `${playerMute.name} zostaÄ¹â€š wyciszony na ${minutesMute} minut.`,
                        player.id,
                        announcementColor,
                        'bold',
                        null
                    );
                } else {
                    room.sendAnnouncement(
                        `Nie wyciszysz admina`,
                        player.id,
                        errorColor,
                        'bold',
                        HaxNotification.CHAT
                    );
                }
            } else {
                room.sendAnnouncement(
                    `Nie ma takiego numeru`,
                    player.id,
                    errorColor,
                    'bold',
                    HaxNotification.CHAT
                );
            }
        } else {
            room.sendAnnouncement(
                `zÅ‚y format dla twojego argumentu. Wpisz "!help mute" po wiecej informacji.`,
                player.id,
                errorColor,
                'bold',
                HaxNotification.CHAT
            );
        }
    } else {
        room.sendAnnouncement(
            `ZÅ‚a liczba argumentÃ³w. Wpisz "!help mute" po wiecej informacji.`,
            player.id,
            errorColor,
            'bold',
            HaxNotification.CHAT
        );
    }
}

function unmuteCommand(player, message) {
    var msgArray = message.split(/ +/).slice(1);
    if (msgArray.length > 0) {
        if (msgArray[0].length > 0 && msgArray[0][0] == '#') {
            msgArray[0] = msgArray[0].substring(1, msgArray[0].length);
            if (room.getPlayer(parseInt(msgArray[0])) != null) {
                var playerUnmute = room.getPlayer(parseInt(msgArray[0]));
                if (muteArray.getByPlayerId(playerUnmute.id) != null) {
                    var muteObj = muteArray.getByPlayerId(playerUnmute.id);
                    muteObj.remove()
                    room.sendAnnouncement(
                        `${playerUnmute.name} moÅ¼e gadaÄ‡!`,
                        player.id,
                        announcementColor,
                        'bold',
                        HaxNotification.CHAT
                    );
                } else {
                    room.sendAnnouncement(
                        `Nie jest wyciszony`,
                        player.id,
                        errorColor,
                        'bold',
                        HaxNotification.CHAT
                    );
                }
            } else {
                room.sendAnnouncement(
                    `Nie ma takiego ID na roomie. Wpisz "!help unmute" po wiecej informacji.`,
                    player.id,
                    errorColor,
                    'bold',
                    HaxNotification.CHAT
                );
            }
        } else if (msgArray[0].length > 0 && parseInt(msgArray[0]) > 0 && muteArray.getById(parseInt(msgArray[0])) != null) {
            var playerUnmute = muteArray.getById(parseInt(msgArray[0]));
            playerUnmute.remove();
            room.sendAnnouncement(
                `${playerUnmute.name} moÅ¼e gadaÄ‡`,
                player.id,
                announcementColor,
                'bold',
                HaxNotification.CHAT
            );
        } else {
            room.sendAnnouncement(
                `ZÅ‚y format dla twojego argumentu. Wpisz "!help unmute" po wiecej informacji.`,
                player.id,
                errorColor,
                'bold',
                HaxNotification.CHAT
            );
        }
    } else {
        room.sendAnnouncement(
            `ZÅ‚a liczba argumentÃ³w. Wpisz "!help unmute" po wiecej informacji.`,
            player.id,
            errorColor,
            'bold',
            HaxNotification.CHAT
        );
    }
}

function muteListCommand(player, message) {
    if (muteArray.list.length == 0) {
        room.sendAnnouncement(
            "ðŸ”‡ Nikt nie jest wyciszony.",
            player.id,
            announcementColor,
            'bold',
            null
        );
        return false;
    }
    var cstm = 'ðŸ”‡ Lista wyciszonych: ';
    for (let mute of muteArray.list) {
        cstm += mute.name + `[${mute.id}], `;
    }
    cstm = cstm.substring(0, cstm.length - 2) + '.';
    room.sendAnnouncement(
        cstm,
        player.id,
        announcementColor,
        'bold',
        null
    );
}

/* MASTER COMMANDS */

function clearbansCommand(player, message) {
    var msgArray = message.split(/ +/).slice(1);
    if (msgArray.length == 0) {
        room.clearBans();
        room.sendAnnouncement(
            'âœ”ï¸ Bany usuniÄ™te!',
            player.id,
            announcementColor,
            'bold',
            null
        );
        timedBanTasks.forEach(function (record) {
            if (record && record.timeoutId) {
                clearTimeout(record.timeoutId);
            }
        });
        timedBanTasks.clear();
        banList = [];
        persistBanState();
        return;
    }
    if (msgArray.length !== 1) {
        room.sendAnnouncement(
            'Zla liczba argumentow. Wpisz "!help clearbans" po instrukcje.',
            player.id,
            errorColor,
            'bold',
            HaxNotification.CHAT
        );
        return;
    }
    var rawToken = msgArray[0];
    var resolvedKey = resolveBanKeyFromToken(rawToken);
    if (!resolvedKey) {
        room.sendAnnouncement(
            'Nie rozpoznano wskazania bana. Uzyj np. "#3" albo "@auth".',
            player.id,
            errorColor,
            'bold',
            HaxNotification.CHAT
        );
        return;
    }
    var unbannedName = null;
    var record = timedBanTasks.get(resolvedKey);
    if (record) {
        unbannedName = record.name;
        clearTimedBan(resolvedKey, { notify: false });
        if (record.id != null) {
            try { room.clearBan(record.id); } catch (_){ }
        }
    } else {
        var entry = null;
        for (let i = 0; i < banList.length; i++) {
            if (banList[i][1] === resolvedKey) {
                entry = banList[i];
                break;
            }
        }
        if (entry) {
            unbannedName = entry[0];
            banList = banList.filter((p) => p[1] !== resolvedKey);
            persistBanState();
            if (resolvedKey.startsWith(BAN_KEY_PREFIX_ID)) {
                var numericId = parseInt(resolvedKey.substring(BAN_KEY_PREFIX_ID.length), 10);
                if (!isNaN(numericId)) {
                    try { room.clearBan(numericId); } catch (_){ }
                }
            }
        } else {
            if (resolvedKey.startsWith(BAN_KEY_PREFIX_ID)) {
                var idNumeric = parseInt(resolvedKey.substring(BAN_KEY_PREFIX_ID.length), 10);
                if (!isNaN(idNumeric)) {
                    try { room.clearBan(idNumeric); } catch (_){ }
                }
            }
            room.sendAnnouncement(
                'To wskazanie nie ma aktywnego bana.',
                player.id,
                errorColor,
                'bold',
                HaxNotification.CHAT
            );
            return;
        }
    }
    room.sendAnnouncement(
        'âœ…  ZostaÅ‚ odbanowany!',
        player.id,
        announcementColor,
        'bold',
        null
    );
}


function banListCommand(player, message) {
    // JeÅ›li lista jest pusta
    if (banList.length == 0) {
        room.sendAnnouncement(
            'ðŸ“¢ Lista banÃ³w jest pusta.',
            player.id,
            announcementColor,
            'bold',
            null
        );
        return false;
    }

    // ObsÅ‚uga numeru strony z wiadomoÅ›ci (np. "!bans 2")
    var msgArray = message.split(/ +/);
    var page = 1;
    if (msgArray.length > 1 && !isNaN(parseInt(msgArray[1]))) {
        page = parseInt(msgArray[1]);
    }

    var itemsPerPage = 15; // IloÅ›Ä‡ nickÃ³w na jednÄ… stronÄ™ (moÅ¼esz zmieniÄ‡)
    var totalPages = Math.ceil(banList.length / itemsPerPage);

    // Zabezpieczenia zakresu stron
    if (page < 1) page = 1;
    if (page > totalPages) page = totalPages;

    var start = (page - 1) * itemsPerPage;
    var end = Math.min(start + itemsPerPage, banList.length);

    // NagÅ‚Ã³wek z numerem strony
    room.sendAnnouncement(
        `ðŸ“¢ Ban lista (Strona ${page}/${totalPages}):`,
        player.id,
        announcementColor,
        'bold',
        null
    );

    // Budowanie listy nickÃ³w
    var cstm = '';
    for (var i = start; i < end; i++) {
        var ban = banList[i];
        // WyÅ›wietlamy: "Indeks. Nick", ban[0] to nazwa, ban[1] to ID (ktÃ³re ukrywamy)
        cstm += `${i + 1}. ${ban[0]}, `;
    }

    // Usuwanie ostatniego przecinka
    if (cstm.length > 0) {
        cstm = cstm.substring(0, cstm.length - 2) + '.';
    }

    // WyÅ›wietlenie listy (styl 'small' pozwala zmieÅ›ciÄ‡ wiÄ™cej tekstu)
    room.sendAnnouncement(
        cstm,
        player.id,
        announcementColor,
        'small',
        null
    );

    // Info o nastÄ™pnej stronie, jeÅ›li istnieje
    if (page < totalPages) {
        room.sendAnnouncement(
            `Wpisz "!bans ${page + 1}" aby zobaczyÄ‡ kolejnÄ… stronÄ™.`,
            player.id,
            infoColor,
            'small',
            null
        );
    }
}

function adminListCommand(player, message) {
    if (adminList.length == 0) {
        room.sendAnnouncement(
            "ðŸ“¢ Nie ma nikogo na liÅ›cie adminÃ³w",
            player.id,
            announcementColor,
            'bold',
            null
        );
        return false;
    }
    var cstm = 'ðŸ“¢ Admin lista : ';
    for (let i = 0; i < adminList.length; i++) {
        cstm += adminList[i][1] + `[${i}], `;
    }
    cstm = cstm.substring(0, cstm.length - 2) + '.';
    room.sendAnnouncement(
        cstm,
        player.id,
        announcementColor,
        'bold',
        null
    );
}

function setAdminCommand(player, message) {
    var msgArray = message.split(/ +/).slice(1);
    if (msgArray.length > 0) {
        if (msgArray[0].length > 0 && msgArray[0][0] == '#') {
            msgArray[0] = msgArray[0].substring(1, msgArray[0].length);
            if (room.getPlayer(parseInt(msgArray[0])) != null) {
                var playerAdmin = room.getPlayer(parseInt(msgArray[0]));

                if (!adminList.map((a) => a[0]).includes(authArray[playerAdmin.id][0])) {
                    if (!masterList.includes(authArray[playerAdmin.id][0])) {
                        room.setPlayerAdmin(playerAdmin.id, true);
                        adminList.push([authArray[playerAdmin.id][0], playerAdmin.name]);
                        persistAdminList();
                        room.sendAnnouncement(
                            `${playerAdmin.name} Jest teraz room adminem!`,
                            player.id,
                            announcementColor,
                            'bold',
                            HaxNotification.CHAT
                        );
                    } else {
                        room.sendAnnouncement(
                            `Jest juÅ¼ adminem!`,
                            player.id,
                            errorColor,
                            'bold',
                            HaxNotification.CHAT
                        );
                    }
                } else {
                    room.sendAnnouncement(
                        `Gracz jest juÅ¼ wiecznym adminem!`,
                        player.id,
                        errorColor,
                        'bold',
                        HaxNotification.CHAT
                    );
                }
            } else {
                room.sendAnnouncement(
                    `Nie ma gracza o takim ID. Wpisz `,
                    player.id,
                    errorColor,
                    'bold',
                    HaxNotification.CHAT
                );
            }
        } else {
            room.sendAnnouncement(
                `ZÅ‚y format dla twojego argumentu. Wpisz "!help setadmin" po instrukcje.`,
                player.id,
                errorColor,
                'bold',
                HaxNotification.CHAT
            );
        }
    } else {
        room.sendAnnouncement(
            `ZÅ‚a liczba argumentÃ³w. Wpisz "!help setadmin" po instrukcje.`,
            player.id,
            errorColor,
            'bold',
            HaxNotification.CHAT
        );
    }
}

function removeAdminCommand(player, message) {
    var msgArray = message.split(/ +/).slice(1);
    if (msgArray.length > 0) {
        if (msgArray[0].length > 0 && msgArray[0][0] == '#') {
            msgArray[0] = msgArray[0].substring(1, msgArray[0].length);
            if (room.getPlayer(parseInt(msgArray[0])) != null) {
                var playerAdmin = room.getPlayer(parseInt(msgArray[0]));

                if (adminList.map((a) => a[0]).includes(authArray[playerAdmin.id][0])) {
                    room.setPlayerAdmin(playerAdmin.id, false);
                    adminList = adminList.filter((a) => a[0] != authArray[playerAdmin.id][0]);
                    persistAdminList();
                    room.sendAnnouncement(
                        `${playerAdmin.name} Nie jest room adminem juÅ¼!`,
                        player.id,
                        announcementColor,
                        'bold',
                        HaxNotification.CHAT
                    );
                } else {
                    room.sendAnnouncement(
                        `Nie jest wiecznym adminem!`,
                        player.id,
                        errorColor,
                        'bold',
                        HaxNotification.CHAT
                    );
                }
            } else {
                room.sendAnnouncement(
                    `Nie ma gracza o takim ID na roomie. Wpisz "!help removeadmin" po wiecej informacji.`,
                    player.id,
                    errorColor,
                    'bold',
                    HaxNotification.CHAT
                );
            }
        } else if (msgArray[0].length > 0 && parseInt(msgArray[0]) < adminList.length) {
            var index = parseInt(msgArray[0]);
            var playerAdmin = adminList[index];
            if (playersAll.findIndex((p) => authArray[p.id][0] == playerAdmin[0]) != -1) {
                // check if there is the removed admin in the room
                var indexRem = playersAll.findIndex((p) => authArray[p.id][0] == playerAdmin[0]);
                room.setPlayerAdmin(playersAll[indexRem].id, false);
            }
            adminList.splice(index);
            persistAdminList();
            room.sendAnnouncement(
                `${playerAdmin[1]} juÅ¼ nie jest rooom adminem!`,
                player.id,
                announcementColor,
                'bold',
                HaxNotification.CHAT
            );
        } else {
            room.sendAnnouncement(
                `ZÅ‚y format dla twojego argumentu. Wpisz "!help removeadmin" po wiÄ™cej informacji`,
                player.id,
                errorColor,
                'bold',
                HaxNotification.CHAT
            );
        }
    } else {
        room.sendAnnouncement(
            `ZÅ‚a liczba argumentÃ³w. Wpisz "!help removeadmin" Po wiÄ™cej informacji`,
            player.id,
            errorColor,
            'bold',
            HaxNotification.CHAT
        );
    }
}

function passwordCommand(player, message) {
    var msgArray = message.split(/ +/).slice(1);
    if (msgArray.length > 0) {
        if (msgArray.length == 1 && msgArray[0] == '') {
            roomPassword = '';
            room.setPassword(null);
            room.sendAnnouncement(
                `HasÅ‚o rooma usuniÄ™te`,
                player.id,
                announcementColor,
                'bold',
                HaxNotification.CHAT
            );
        }
        roomPassword = msgArray.join(' ');
        room.setPassword(roomPassword);
        room.sendAnnouncement(
            `HasÅ‚o rooma ustawione na:  ${roomPassword}`,
            player.id,
            announcementColor,
            'bold',
            HaxNotification.CHAT
        );
    } else {
        if (roomPassword != '') {
            roomPassword = '';
            room.setPassword(null);
            room.sendAnnouncement(
                `HasÅ‚o rooma usuniÄ™te`,
                player.id,
                announcementColor,
                'bold',
                HaxNotification.CHAT
            );
        } else {
            room.sendAnnouncement(
                `Room nie ma hasÅ‚a.`,
                player.id,
                errorColor,
                'bold',
                HaxNotification.CHAT
            );
        }
    }
}

/* GAME FUNCTIONS */

function checkTime() {
  const scores = room.getScores();
  if (game !== undefined) game.scores = scores;

  // --- KONIEC CZASU REGULAMINOWEGO ---
  if (
    scores.timeLimit !== 0 &&
    playSituation === Situation.PLAY &&
    Math.abs(scores.time - scores.timeLimit) <= 0.01
  ) {
    if (!checkTimeVariable) {
      checkTimeVariable = true;
      setTimeout(() => { checkTimeVariable = false; }, 3000);

      if (scores.red > scores.blue) {
        endGame(Team.RED);
      } else if (scores.red < scores.blue) {
        endGame(Team.BLUE);
      } else {
        // REMIS
        if (drawTimeLimit && drawTimeLimit !== 0) {
          // wÅ‚Ä…czamy zÅ‚otego gola (dogrywka)
          goldenGoal = true;
          room.sendAnnouncement(
            'âš½ ZÅ‚oty gol! ZostaÅ‚a minuta do remisu!',
            null,                 // DO WSZYSTKICH â€“ nie ma tu player.id
            announcementColor,
            'bold',
            HaxNotification.CHAT
          );
          return; // gramy dalej do zÅ‚otego gola
        } else {
          // brak dogrywki -> remis
          endGame(Team.SPECTATORS);
        }
      }

      // zatrzymanie gry po ogÅ‚oszeniu wyniku (wygrana/przegrana lub remis bez dogrywki)
      stopTimeout = setTimeout(() => {
        try { room.stopGame(); } catch(_) {}
      }, 2000);
    }
    return;
  }

  // --- KONIEC DOGRYWKI (ZÅOTY GOL NIE PADÅ) ---
  // Uwaga: drawTimeLimit to minuty -> *60 w sekundach czasu meczu
  if (
    goldenGoal &&
    scores.timeLimit !== 0 &&
    Math.abs(scores.time - (scores.timeLimit + drawTimeLimit * 60)) <= 0.01
  ) {
    if (!checkTimeVariable) {
      checkTimeVariable = true;
      setTimeout(() => { checkTimeVariable = false; }, 10);
      endGame(Team.SPECTATORS); // remis
      try { room.stopGame(); } catch(_) {}
      goldenGoal = false;
    }
    return;
  }
}


function instantRestart() {
    room.stopGame();
    startTimeout = setTimeout(() => {
        room.startGame();
    }, 10);
}

function resumeGame() {
    startTimeout = setTimeout(() => {
        room.startGame();
    }, 1000);
    setTimeout(() => {
        room.pauseGame(false);
    }, 500);
}

function endGame(winner) {
    if (players.length >= 2 * teamSize - 1) activateChooseMode();
    const scores = room.getScores();
    game.scores = scores;
    lastWinner = winner;
    endGameVariable = true;
    if (winner == Team.RED) {
        streak++;
        room.sendAnnouncement(
            `âœ¨ Czerwoni wygrali. ${scores.red} - ${scores.blue} ! To: ${streak} wygrana z rzÄ™du!`, null,
            redColor,
            'small',
            HaxNotification.CHAT
        );
    } else if (winner == Team.BLUE) {
        streak = 1;
        room.sendAnnouncement(
            `âœ¨ Niebiescy wygrali ${scores.blue} - ${scores.red}! To: ${streak} wygrana z rzÄ™du!`, null,
            blueColor,
            'small',
            HaxNotification.CHAT
        );
    } else {
        streak = 0;
        room.sendAnnouncement(
            'ðŸ’¤ Czas na dobieranie minÄ…Å‚!', null,
            announcementColor,
            'bold',
            HaxNotification.CHAT
        );
    }
    let possessionRedPct = (possession[0] / (possession[0] + possession[1])) * 100;
    let possessionBluePct = 100 - possessionRedPct;
    let possessionString = `ðŸ”´ ${possessionRedPct.toFixed(0)}% - ${possessionBluePct.toFixed(0)}% ðŸ”µ`;
    let actionRedPct = (actionZoneHalf[0] / (actionZoneHalf[0] + actionZoneHalf[1])) * 100;
    let actionBluePct = 100 - actionRedPct;
    let actionString = `ðŸ”´ ${actionRedPct.toFixed(0)}% - ${actionBluePct.toFixed(0)}% ðŸ”µ`;
    let CSString = getCSString(scores);
    room.sendAnnouncement(
        `ðŸ“Š Posiadanie:${possessionString}\n` +
        `ðŸ“Š Presja:${actionString}\n` +
        `${CSString}`, null,
        announcementColor,
        'small',
        HaxNotification.NONE
    );
    updateStats();
}

/* CHOOSING FUNCTIONS */

function activateChooseMode() {
    chooseMode = true;
    slowMode = chooseModeSlowMode;
}

function deactivateChooseMode() {
    chooseMode = false;
    clearTimeout(timeOutCap);
    if (slowMode != defaultSlowMode) {
        slowMode = defaultSlowMode;
    }
    redCaptainChoice = '';
    blueCaptainChoice = '';
}

const fallbackRankTable = [
    { max: 850, label: 'GÃ³wienko' },
    { max: 950, label: 'Å»Ã³Å‚todziÃ³b' },
    { max: 1050, label: 'PoczÄ…tkujÄ…cy' },
    { max: 1199, label: 'Gracz' },
    { max: 1299, label: 'Kox' },
    { max: 1399, label: 'Mistrz' },
    { max: 1550, label: 'Legenda' },
    { max: Infinity, label: 'NieÅ›miertelny' },
];

const fallbackRankBadges = {
    'GÃ³wienko': 'ðŸ’©',
    'Å»Ã³Å‚todziÃ³b': 'ðŸ£',
    'PoczÄ…tkujÄ…cy': 'âšª',
    'Gracz': 'ðŸ¥‰',
    'Kox': 'ðŸ¥ˆ',
    'Mistrz': 'ðŸ¥‡',
    'Legenda': 'ðŸ‘‘',
    'NieÅ›miertelny': 'ðŸ”¥',
};

function fallbackClassLabelFromRating(rating) {
    var value = Number(rating);
    if (!isFinite(value)) value = 1000;
    for (var i = 0; i < fallbackRankTable.length; i++) {
        if (value <= fallbackRankTable[i].max) {
            return fallbackRankTable[i].label;
        }
    }
    return 'NieÅ›miertelny';
}

function fallbackBadgeFromLabel(label) {
    return fallbackRankBadges[label] || 'ðŸ˜¶';
}

function getRankEmojiForPlayer(player) {
    if (!player) return "";
    try {
        const isAfk = typeof AFKSet !== "undefined"
            && AFKSet instanceof Set
            && typeof player.id === "number"
            && AFKSet.has(player.id);
        if (isAfk) {
            return "ðŸ˜´";
        }
        const globalObj = (typeof globalThis !== "undefined") ? globalThis : (typeof window !== "undefined" ? window : {});
        const ensureProfileFn = typeof globalObj.ensureProfile === "function" ? globalObj.ensureProfile : null;
        const classLabelFn = typeof globalObj.classLabel === "function" ? globalObj.classLabel : null;
        const rankEmojiFn = typeof globalObj.rankEmoji === "function" ? globalObj.rankEmoji : null;
        const store = (globalObj && typeof globalObj.__eloStore === "object") ? globalObj.__eloStore : (typeof globalObj.eloStore === "object" ? globalObj.eloStore : null);
        const authId = getAuthIdByPlayer(player);
        if (!authId) return "";
        if (ensureProfileFn) {
            try { ensureProfileFn(authId, player && player.name ? player.name : undefined); } catch (_) {}
        }
        let rating = baseElo;
        if (store && store.ratings && store.ratings[authId] != null) {
            const numeric = Number(store.ratings[authId]);
            if (Number.isFinite(numeric)) rating = numeric;
        }
        let label = null;
        if (classLabelFn) {
            try { label = classLabelFn(rating); } catch (_) { label = null; }
        }
        if (!label) {
            label = fallbackClassLabelFromRating(rating);
        }
        let emoji = rankEmojiFn ? rankEmojiFn(label) : null;
        if (!emoji) {
            emoji = fallbackBadgeFromLabel(label);
        }
        return typeof emoji === "string" ? emoji : "";
    } catch (_) {
        return "";
    }
}

function getSpecList(player) {
    if (player == null) return null;
    const g = (typeof globalThis !== 'undefined') ? globalThis : (typeof window !== 'undefined' ? window : {});
    const ensureProfileFn = typeof g.ensureProfile === 'function' ? g.ensureProfile : null;
    const classLabelFn = typeof g.classLabel === 'function' ? g.classLabel : null;
    const rankEmojiFn = typeof g.rankEmoji === 'function' ? g.rankEmoji : null;
    var cstm = 'Gracze : ';
    for (var i = 0; i < teamSpec.length; i++) {
        var p = teamSpec[i];
        var badge = '';
        try {
            var aid = null;
            try { aid = getAuthIdByPlayer(p); } catch(e) {}
            if (!aid && typeof authArray !== 'undefined' && authArray[p.id] && authArray[p.id][0]) {
                aid = authArray[p.id][0];
            }
            if (aid) {
                // Upewnij siÄ™, Å¼e profil istnieje
                if (ensureProfileFn) {
                    try { ensureProfileFn(aid, p && p.name ? p.name : undefined); } catch(_e) {}
                }
                var store = (typeof globalThis !== 'undefined' && globalThis.__eloStore) ? globalThis.__eloStore : null;
                var ratings = store && store.ratings;
            var r = Number(ratings && ratings[aid] != null ? ratings[aid] : NaN);
            if (!isFinite(r)) r = 1000; // domyÅ›lnie 1000
            var lab = classLabelFn ? classLabelFn(r) : fallbackClassLabelFromRating(r);
            badge = rankEmojiFn && lab ? rankEmojiFn(lab) : fallbackBadgeFromLabel(lab);
            if (!badge || badge === 'ðŸ˜¶') {
                badge = fallbackBadgeFromLabel(lab);
            }
        } else {
            badge = "ðŸ˜¶";
        }
    } catch (e) {
        // W razie bÅ‚Ä™du nie psuj listy wyboru
        badge = "ðŸ˜¶";
    }
        if (!badge) {
            badge = "ðŸ˜¶";
        }
        const isAfk = (typeof AFKSet !== 'undefined' && AFKSet instanceof Set && AFKSet.has(p.id));
        const displayBadge = isAfk ? 'ðŸ˜´' : badge;
        cstm += (displayBadge ? (displayBadge + ' ') : '') + p.name + '[' + (i + 1) + '], ';
    }
    cstm = cstm.substring(0, cstm.length - 2) + '.';
    room.sendAnnouncement(
        cstm,
        player.id,
        infoColor,
        'bold',
        HaxNotification.CHAT
    );
}

function choosePlayer() {
    clearTimeout(timeOutCap);
    let captain;
    if (teamRed.length <= teamBlue.length && teamRed.length != 0) {
        captain = teamRed[0];
    } else if (teamBlue.length < teamRed.length && teamBlue.length != 0) {
        captain = teamBlue[0];
    }
    if (captain != null) {
        // ZMIANA: Zaktualizowany komunikat z nowymi opcjami
        room.sendAnnouncement(
            "Wybierz gracza wpisujÄ…c: numer, fragment nicku, 'best' (najlepsze ELO), 'top', 'random' lub 'bottom'.",
            captain.id,
            infoColor,
            'bold',
            HaxNotification.MENTION
        );
        timeOutCap = setTimeout(
            (player) => {
                room.sendAnnouncement(
                    `Szybciej ${player.name}, tylko ${Number.parseInt(String(chooseTime / 2))} sekund na wybÃ³r !`,
                    player.id,
                    warningColor,
                    'bold',
                    HaxNotification.MENTION
                );
                timeOutCap = setTimeout(
                    (player) => {
                        room.kickPlayer(
                            player.id,
                            "Nie wybraÅ‚eÅ› na czas",
                            false
                        );
                    },
                    chooseTime * 500,
                    captain
                );
            },
            chooseTime * 1000,
            captain
        );
    }
    if (teamRed.length != 0 && teamBlue.length != 0) {
        getSpecList(teamRed.length <= teamBlue.length ? teamRed[0] : teamBlue[0]);
    }
}
function chooseModeFunction(player, message) {
    var msgArray = message.split(/ +/);
    var arg = msgArray[0].toLowerCase();

    // === POMOCNICZE FUNKCJE WEWNÄ˜TRZNE ===

    // Funkcja do pobierania ELO (bezpieczna integracja z Twoim systemem ELO)
    const getEloRating = (p) => {
        let auth = typeof getPlayerAuth === "function" ? getPlayerAuth(p) : null;
        if (!auth && typeof getAuthIdByPlayer === "function") auth = getAuthIdByPlayer(p);
        
        // Pobieramy ze store'a ELO (zmienna globalna z Twojego skryptu)
        const store = (typeof globalThis !== "undefined") ? (globalThis.eloStore || globalThis.__eloStore) : null;
        if (auth && store && store.ratings && store.ratings[auth] != null) {
            return Number(store.ratings[auth]);
        }
        return 1000; // DomyÅ›lne ELO
    };

    // ZnajdÅº najlepszego gracza na specu
    const findBestPlayer = () => {
        let best = null;
        let maxElo = -Infinity;
        for (let p of teamSpec) {
            let rating = getEloRating(p);
            if (rating > maxElo) {
                maxElo = rating;
                best = p;
            }
        }
        return best;
    };

    // ZnajdÅº gracza po fragmencie nicku
    const findPlayerByNick = (text) => {
        return teamSpec.find(p => p.name.toLowerCase().includes(text));
    };

    // === GÅÃ“WNA LOGIKA ===

    if (player.id == teamRed[0].id || player.id == teamBlue[0].id) {
        // Sprawdzamy czyja jest tura
        let isRedTurn = (teamRed.length <= teamBlue.length && player.id == teamRed[0].id);
        let isBlueTurn = (teamRed.length > teamBlue.length && player.id == teamBlue[0].id);
        
        if (!isRedTurn && !isBlueTurn) return false; // To nie tura tego gracza

        let targetTeam = isRedTurn ? Team.RED : Team.BLUE;
        
        // 1. TOP / AUTO
        if (['top', 'auto'].includes(arg)) {
            room.setPlayerTeam(teamSpec[0].id, targetTeam);
            if (isRedTurn) redCaptainChoice = 'top'; else blueCaptainChoice = 'top';
            clearTimeout(timeOutCap);
            room.sendAnnouncement(`${player.name} wybiera gÃ³rÄ™!`, player.id, announcementColor, 'small', HaxNotification.CHAT);
            return true;
        }
        // 2. RANDOM / LOS
        else if (['random', 'rand', 'los'].includes(arg)) {
            var r = getRandomInt(teamSpec.length);
            room.setPlayerTeam(teamSpec[r].id, targetTeam);
            if (isRedTurn) redCaptainChoice = 'random'; else blueCaptainChoice = 'random';
            clearTimeout(timeOutCap);
            room.sendAnnouncement(`${player.name} wybiera losowo!`, player.id, announcementColor, 'small', HaxNotification.CHAT);
            return true;
        }
        // 3. BOTTOM / DÃ“Å
        else if (['bottom', 'bot', 'dol'].includes(arg)) {
            room.setPlayerTeam(teamSpec[teamSpec.length - 1].id, targetTeam);
            if (isRedTurn) redCaptainChoice = 'bottom'; else blueCaptainChoice = 'bottom';
            clearTimeout(timeOutCap);
            room.sendAnnouncement(`${player.name} wybiera dÃ³Å‚!`, player.id, announcementColor, 'small', HaxNotification.CHAT);
            return true;
        }
        // 4. BEST (Najlepsze ELO) - NOWA FUNKCJA
        else if (['best', 'najlepszy', 'elo', 'kox'].includes(arg)) {
            let bestP = findBestPlayer();
            if (bestP) {
                room.setPlayerTeam(bestP.id, targetTeam);
                clearTimeout(timeOutCap);
                let rating = getEloRating(bestP).toFixed(0);
                room.sendAnnouncement(`${player.name} dobiera najlepszego dostÄ™pnego: ${bestP.name} (ELO: ${rating})!`, player.id, announcementColor, 'small', HaxNotification.CHAT);
                return true;
            }
        }
        // 5. WYBÃ“R PO NUMERZE (1, 2, 3...)
        else if (!Number.isNaN(Number.parseInt(arg))) {
            let num = Number.parseInt(arg);
            if (num > teamSpec.length || num < 1) {
                room.sendAnnouncement(`TwÃ³j numer jest niewÅ‚aÅ›ciwy!`, player.id, errorColor, 'bold', HaxNotification.CHAT);
                return true; // Zatrzymujemy, Å¼eby nie spamowaÄ‡ czatu bÅ‚Ä™dem numeru
            } else {
                room.setPlayerTeam(teamSpec[num - 1].id, targetTeam);
                room.sendAnnouncement(`${player.name} wybraÅ‚ ${teamSpec[num - 1].name}!`, player.id, announcementColor, 'small', HaxNotification.CHAT);
                return true;
            }
        }
        // 6. WYBÃ“R PO NICKU
        else {
            let found = findPlayerByNick(arg);
            if (found) {
                room.setPlayerTeam(found.id, targetTeam);
                clearTimeout(timeOutCap);
                room.sendAnnouncement(`${player.name} dobiera gracza: ${found.name}!`, player.id, announcementColor, 'small', HaxNotification.CHAT);
                return true;
            }
            
            // 7. BRAK DOPASOWANIA -> CZAT
            // JeÅ›li nic nie znaleziono, zwracamy false.
            // DziÄ™ki temu onPlayerChat "przepuÅ›ci" tÄ™ wiadomoÅ›Ä‡ dalej jako zwykÅ‚y tekst.
            return false;
        }
    }
    return false;
}

function checkCaptainLeave(player) {
    if (
        (teamRed.findIndex((red) => red.id == player.id) == 0 && chooseMode && teamRed.length <= teamBlue.length) ||
        (teamBlue.findIndex((blue) => blue.id == player.id) == 0 && chooseMode && teamBlue.length < teamRed.length)
    ) {
        choosePlayer();
        capLeft = true;
        setTimeout(() => {
            capLeft = false;
        }, 10);
    }
}

function slowModeFunction(player, message) {
    if (!player.admin) {
        if (!SMSet.has(player.id)) {
            SMSet.add(player.id);
            setTimeout(
                (number) => {
                    SMSet.delete(number);
                },
                slowMode * 1000,
                player.id
            );
        } else {
            return true;
        }
    }
    return false;
}

/* PLAYER FUNCTIONS */

function updateTeams() {
    playersAll = room.getPlayerList();
    players = playersAll.filter((p) => !AFKSet.has(p.id));
    teamRed = players.filter((p) => p.team == Team.RED);
    teamBlue = players.filter((p) => p.team == Team.BLUE);
    teamSpec = players.filter((p) => p.team == Team.SPECTATORS);
}

function ensureAFKsAtSpecEnd() {
    try {
        const players = room.getPlayerList();
        if (!Array.isArray(players) || players.length === 0) return;
        const spectators = players.filter((p) => p.team === Team.SPECTATORS);
        if (spectators.length === 0) return;
        const afkIds = spectators.filter((p) => AFKSet.has(p.id)).map((p) => p.id);
        if (afkIds.length === 0) return;
        const activeIds = spectators.filter((p) => !AFKSet.has(p.id)).map((p) => p.id);
        const desiredSpecOrder = activeIds.concat(afkIds);
        const currentSpecOrder = spectators.map((p) => p.id);
        let changed = false;
        for (let i = 0; i < desiredSpecOrder.length; i++) {
            if (desiredSpecOrder[i] !== currentSpecOrder[i]) {
                changed = true;
                break;
            }
        }
        if (!changed) return;

        const specQueue = desiredSpecOrder.slice();
        const byId = new Map(players.map((p) => [p.id, p]));
        const newOrder = players.map((p) => {
            if (p.team === Team.SPECTATORS) {
                return specQueue.shift();
            }
            return p.id;
        });
        room.reorderPlayers(newOrder, true);
    } catch (err) {
        if (typeof debugMode !== 'undefined' && debugMode) {
            console.log('[ensureAFKsAtSpecEnd] failed', err);
        }
    }
}

function scheduleEnsureAFKsAtSpecEnd() {
    try {
        if (typeof ensureAFKsAtSpecEnd._timeout !== 'undefined' && ensureAFKsAtSpecEnd._timeout !== null) {
            clearTimeout(ensureAFKsAtSpecEnd._timeout);
        }
        ensureAFKsAtSpecEnd._timeout = setTimeout(() => {
            ensureAFKsAtSpecEnd._timeout = null;
            ensureAFKsAtSpecEnd();
        }, 0);
    } catch (err) {
        if (typeof debugMode !== 'undefined' && debugMode) {
            console.log('[scheduleEnsureAFKsAtSpecEnd] failed', err);
        }
    }
}

function movePlayerToQueueEnd(playerId) {
    try {
        const order = room.getPlayerList().map((p) => p.id);
        const index = order.indexOf(playerId);
        if (index === -1 || index === order.length - 1) {
            scheduleEnsureAFKsAtSpecEnd();
            return;
        }
        order.splice(index, 1);
        order.push(playerId);
        room.reorderPlayers(order, true);
        scheduleEnsureAFKsAtSpecEnd();
    } catch (_) {
        scheduleEnsureAFKsAtSpecEnd();
    }
}

function updateAdmins(excludedPlayerID = 0) {
    if (players.length != 0 && players.filter((p) => p.admin).length < maxAdmins) {
        let playerArray = players.filter((p) => p.id != excludedPlayerID && !p.admin);
        let arrayID = playerArray.map((player) => player.id);
        room.setPlayerAdmin(Math.min(...arrayID), true);
    }
}

function getRole(player) {
    return (
        !!masterList.find((a) => a == authArray[player.id][0]) * 2 +
        !!adminList.find((a) => a[0] == authArray[player.id][0]) * 1 +
        player.admin * 1
    );
}

function ghostKickHandle(oldP, newP) {
    var teamArrayId = getTeamArray(oldP.team, true).map((p) => p.id);
    teamArrayId.splice(teamArrayId.findIndex((id) => id == oldP.id), 1, newP.id);

    room.kickPlayer(oldP.id, 'kop ducha', false);
    room.setPlayerTeam(newP.id, oldP.team);
    room.setPlayerAdmin(newP.id, oldP.admin);
    room.reorderPlayers(teamArrayId, true);

    if (oldP.team != Team.SPECTATORS && playSituation != Situation.STOP) {
        var discProp = room.getPlayerDiscProperties(oldP.id);
        room.setPlayerDiscProperties(newP.id, discProp);
    }
}

/* ACTIVITY FUNCTIONS */

function handleActivityPlayer(player) {
    let pComp = getPlayerComp(player);
    if (pComp != null) {
        pComp.inactivityTicks++;
        if (pComp.inactivityTicks == 60 * ((2 / 3) * afkLimit)) {
            room.sendAnnouncement(
                `â›” ${player.name}, jeÅ›li nie dasz nam znaku Å¼ycia w ${Math.floor(afkLimit / 3)} sekund, wykopiÄ™ CiÄ™!`,
                player.id,
                warningColor,
                'small',
                HaxNotification.MENTION
            );
            return;
        }
        if (pComp.inactivityTicks >= 60 * afkLimit) {
            pComp.inactivityTicks = 0;
            if (game.scores.time <= afkLimit - 0.5) {
                setTimeout(() => {
                    !chooseMode ? instantRestart() : room.stopGame();
                }, 10);
            }
            room.kickPlayer(player.id, 'AFK', false);
        }
    }
}

function handleActivityPlayerTeamChange(changedPlayer) {
    if (changedPlayer.team == Team.SPECTATORS) {
        let pComp = getPlayerComp(changedPlayer);
        if (pComp != null) pComp.inactivityTicks = 0;
    }
}

function handleActivityStop() {
    for (let player of players) {
        let pComp = getPlayerComp(player);
        if (pComp != null) pComp.inactivityTicks = 0;
    }
}

function handleActivity() {
    if (gameState === State.PLAY && players.length > 1) {
        for (let player of teamRed) {
            handleActivityPlayer(player);
        }
        for (let player of teamBlue) {
            handleActivityPlayer(player);
        }
    }
}

function monitorAFKSet() {
    if (AFKSet.size === 0) return;
    const now = Date.now();
    AFKSet.forEach((playerId) => {
        const player = room.getPlayer(playerId);
        if (!player) {
            const storedKey = AFKCooldownKeyById.get(playerId);
            if (storedKey) {
                AFKCooldownUntilByKey.delete(storedKey);
                AFKCooldownKeyById.delete(playerId);
            }
            AFKCommandCooldownUntilById.delete(playerId);
            clearAFKTracking(playerId);
            return;
        }

        const cooldownKey = getAFKCooldownKey(player);
        if (!cooldownKey) return;
        AFKCooldownKeyById.set(playerId, cooldownKey);

        if (!AFKStartTimes.has(playerId)) {
            AFKStartTimes.set(playerId, now);
        }
        const startTime = AFKStartTimes.get(playerId);
        const elapsed = now - startTime;

        const maxDuration = (player && player.admin) ? AFK_ADMIN_MAX_DURATION_MS : AFK_MAX_DURATION_MS;
        const warnThreshold = maxDuration - AFK_WARN_BEFORE_MS;

        if (elapsed >= maxDuration) {
            clearAFKTracking(playerId);
            AFKCooldownUntilByKey.set(cooldownKey, now + AFK_COOLDOWN_MS);
            room.sendAnnouncement(
                `â° ${player.name} za dlugo siedzi na AFK i zostaje wyrzucony.`,
                null,
                warningColor,
                'small',
                HaxNotification.CHAT
            );
            try {
                const authKick = getPlayerAuth(player);
                const autoKey = authKick ? authKick : `id:${playerId}`;
                autoAfkKicked.add(autoKey);
            } catch (_){}
            const limitMinutes = Math.round(maxDuration / 60000);
            room.kickPlayer(playerId, `Za dlugo AFK (${limitMinutes} min).`, false);
            return;
        }

        if (elapsed >= warnThreshold && !AFKWarnedSet.has(playerId)) {
            const remainingSec = Math.max(0, Math.ceil((maxDuration - elapsed) / 1000));
            room.sendAnnouncement(
                `â° ${player.name}, za ${remainingSec}s wylecisz ze speca za zbyt dlugie AFK.`,
                player.id,
                warningColor,
                'small',
                HaxNotification.MENTION
            );
            AFKWarnedSet.add(playerId);
        }
    });
}

/* LINEUP FUNCTIONS */

function getStartingLineups() {
    var compositions = [[], []];
    for (let player of teamRed) {
        compositions[0].push(
            new PlayerComposition(player, authArray[player.id][0], [0], [])
        );
    }
    for (let player of teamBlue) {
        compositions[1].push(
            new PlayerComposition(player, authArray[player.id][0], [0], [])
        );
    }
    return compositions;
}

function handleLineupChangeTeamChange(changedPlayer) {
    if (gameState != State.STOP) {
        var playerLineup;
        if (changedPlayer.team == Team.RED) {
            // player gets in red team
            var redLineupAuth = game.playerComp[0].map((p) => p.auth);
            var ind = redLineupAuth.findIndex((auth) => auth == authArray[changedPlayer.id][0]);
            if (ind != -1) {
                // Player goes back in
                playerLineup = game.playerComp[0][ind];
                if (playerLineup.timeExit.includes(game.scores.time)) {
                    // gets subbed off then in at the exact same time -> no sub
                    playerLineup.timeExit = playerLineup.timeExit.filter((t) => t != game.scores.time);
                } else {
                    playerLineup.timeEntry.push(game.scores.time);
                }
            } else {
                playerLineup = new PlayerComposition(
                    changedPlayer,
                    authArray[changedPlayer.id][0],
                    [game.scores.time],
                    []
                );
                game.playerComp[0].push(playerLineup);
            }
        } else if (changedPlayer.team == Team.BLUE) {
            // player gets in blue team
            var blueLineupAuth = game.playerComp[1].map((p) => p.auth);
            var ind = blueLineupAuth.findIndex((auth) => auth == authArray[changedPlayer.id][0]);
            if (ind != -1) {
                // Player goes back in
                playerLineup = game.playerComp[1][ind];
                if (playerLineup.timeExit.includes(game.scores.time)) {
                    // gets subbed off then in at the exact same time -> no sub
                    playerLineup.timeExit = playerLineup.timeExit.filter((t) => t != game.scores.time);
                } else {
                    playerLineup.timeEntry.push(game.scores.time);
                }
            } else {
                playerLineup = new PlayerComposition(
                    changedPlayer,
                    authArray[changedPlayer.id][0],
                    [game.scores.time],
                    []
                );
                game.playerComp[1].push(playerLineup);
            }
        }
        if (teamRed.some((r) => r.id == changedPlayer.id)) {
            // player leaves red team
            var redLineupAuth = game.playerComp[0].map((p) => p.auth);
            var ind = redLineupAuth.findIndex((auth) => auth == authArray[changedPlayer.id][0]);
            playerLineup = game.playerComp[0][ind];
            if (playerLineup.timeEntry.includes(game.scores.time)) {
                // gets subbed off then in at the exact same time -> no sub
                if (game.scores.time == 0) {
                    game.playerComp[0].splice(ind, 1);
                } else {
                    playerLineup.timeEntry = playerLineup.timeEntry.filter((t) => t != game.scores.time);
                }
            } else {
                playerLineup.timeExit.push(game.scores.time);
            }
        } else if (teamBlue.some((r) => r.id == changedPlayer.id)) {
            // player leaves blue team
            var blueLineupAuth = game.playerComp[1].map((p) => p.auth);
            var ind = blueLineupAuth.findIndex((auth) => auth == authArray[changedPlayer.id][0]);
            playerLineup = game.playerComp[1][ind];
            if (playerLineup.timeEntry.includes(game.scores.time)) {
                // gets subbed off then in at the exact same time -> no sub
                if (game.scores.time == 0) {
                    game.playerComp[1].splice(ind, 1);
                } else {
                    playerLineup.timeEntry = playerLineup.timeEntry.filter((t) => t != game.scores.time);
                }
            } else {
                playerLineup.timeExit.push(game.scores.time);
            }
        }
    }
}

function handleLineupChangeLeave(player) {
    if (playSituation != Situation.STOP) {
        if (player.team == Team.RED) {
            // player gets in red team
            var redLineupAuth = game.playerComp[0].map((p) => p.auth);
            var ind = redLineupAuth.findIndex((auth) => auth == authArray[player.id][0]);
            var playerLineup = game.playerComp[0][ind];
            if (playerLineup.timeEntry.includes(game.scores.time)) {
                // gets subbed off then in at the exact same time -> no sub
                if (game.scores.time == 0) {
                    game.playerComp[0].splice(ind, 1);
                } else {
                    playerLineup.timeEntry = playerLineup.timeEntry.filter((t) => t != game.scores.time);
                }
            } else {
                playerLineup.timeExit.push(game.scores.time);
            }
        } else if (player.team == Team.BLUE) {
            // player gets in blue team
            var blueLineupAuth = game.playerComp[1].map((p) => p.auth);
            var ind = blueLineupAuth.findIndex((auth) => auth == authArray[player.id][0]);
            var playerLineup = game.playerComp[1][ind];
            if (playerLineup.timeEntry.includes(game.scores.time)) {
                // gets subbed off then in at the exact same time -> no sub
                if (game.scores.time == 0) {
                    game.playerComp[1].splice(ind, 1);
                } else {
                    playerLineup.timeEntry = playerLineup.timeEntry.filter((t) => t != game.scores.time);
                }
            } else {
                playerLineup.timeExit.push(game.scores.time);
            }
        }
    }
}

/* TEAM BALANCE FUNCTIONS */

function markMatchAsUnrankedForAutoRestart() {
    if (gameState !== State.STOP) {
        cancelGameVariable = true;
    }
    try {
        const eloState = globalThis && globalThis.__eloState;
        if (eloState) {
            eloState.ranked = false;
            eloState.settled = true;
            eloState.active = false;
        }
    } catch (_) {}
}

function tryAutoStartThreeVThree() {
    const teamsFull = teamRed.length === teamSize && teamBlue.length === teamSize;
    
    if (teamsFull) {
        // Zawsze wyÅ‚Ä…czamy tryb wybierania, jeÅ›li skÅ‚ady sÄ… peÅ‚ne
        if (chooseMode) {
            deactivateChooseMode();
            room.pauseGame(false); // Upewniamy siÄ™, Å¼e gra jest wznowiona
        }

        // LOGIKA STARTU / WZNOWIENIA
        // Restartujemy I zmieniamy mapÄ™ TYLKO JEÅšLI:
        // 1. Mapa nie jest ustawiona na 'big' (czyli gramy 2v2 na Classic i wchodzi 3v3)
        // 2. LUB gra jest caÅ‚kowicie zatrzymana (STOP) - wtedy trzeba jÄ… zaczÄ…Ä‡ od nowa
        if (currentStadium !== 'big' || gameState === State.STOP) {
            if (!fullTeamsAutoRestarted) {
                fullTeamsAutoRestarted = true;
                markMatchAsUnrankedForAutoRestart(); // Anulujemy poprzedni "mini-mecz"
                instantRestart(); // Resetujemy grÄ™
                
                // JeÅ›li mapa nie jest Big, zmieniamy jÄ…
                if (currentStadium !== 'big') {
                    setTimeout(() => {
                        stadiumCommand(emptyPlayer, `!big`);
                    }, 5);
                }
            }
        } else {
            // JEÅšLI MAPA TO 'BIG' I GRA TRWA (PAUSE/PLAY) -> WZNAWIAMY (RESUME)
            // DziÄ™ki temu zachowujemy wynik i dziaÅ‚a ochrona ELO dla nowego gracza
            if (!fullTeamsAutoRestarted) {
                fullTeamsAutoRestarted = true;
                room.sendAnnouncement("SkÅ‚ad uzupeÅ‚niony! Gramy dalej.", null, successColor, "bold", HaxNotification.CHAT);
                // Nie robimy restartu, gra toczy siÄ™ dalej
            }
        }
    } else {
        fullTeamsAutoRestarted = false;
    }
}
function balanceTeams() {
    if (!chooseMode) {
        if (players.length == 0) {
            room.stopGame();
            room.setScoreLimit(scoreLimit);
            room.setTimeLimit(timeLimit);
        } else if (players.length == 1 && teamRed.length == 0) {
            instantRestart();
            setTimeout(() => {
                stadiumCommand(emptyPlayer, `!training`);
            }, 5);
            room.setPlayerTeam(players[0].id, Team.RED);
        } else if (Math.abs(teamRed.length - teamBlue.length) == teamSpec.length && teamSpec.length > 0) {
            const n = Math.abs(teamRed.length - teamBlue.length);
            if (players.length == 2) {
                instantRestart();
                setTimeout(() => {
                    stadiumCommand(emptyPlayer, `!classic`);
                }, 5);
            }
            if (teamRed.length > teamBlue.length) {
                for (var i = 0; i < n; i++) {
                    room.setPlayerTeam(teamSpec[i].id, Team.BLUE);
                }
            } else {
                for (var i = 0; i < n; i++) {
                    room.setPlayerTeam(teamSpec[i].id, Team.RED);
                }
            }
        } else if (Math.abs(teamRed.length - teamBlue.length) > teamSpec.length) {
            const n = Math.abs(teamRed.length - teamBlue.length);
            if (players.length == 1) {
                instantRestart();
                setTimeout(() => {
                    stadiumCommand(emptyPlayer, `!training`);
                }, 5);
                room.setPlayerTeam(players[0].id, Team.RED);
                return;
            } else if (teamSize > 2 && players.length == 5) {
                instantRestart();
                setTimeout(() => {
                    stadiumCommand(emptyPlayer, `!classic`);
                }, 5);
            }
            if (players.length == teamSize * 2 - 1) {
                teamRedStats = [];
                teamBlueStats = [];
            }
            if (teamRed.length > teamBlue.length) {
                for (var i = 0; i < n; i++) {
                    room.setPlayerTeam(
                        teamRed[teamRed.length - 1 - i].id,
                        Team.SPECTATORS
                    );
                }
            } else {
                for (var i = 0; i < n; i++) {
                    room.setPlayerTeam(
                        teamBlue[teamBlue.length - 1 - i].id,
                        Team.SPECTATORS
                    );
                }
            }
    } else if (Math.abs(teamRed.length - teamBlue.length) < teamSpec.length && teamRed.length != teamBlue.length) {
        room.pauseGame(true);
        activateChooseMode();
        choosePlayer();
    } else if (teamSpec.length >= 2 && teamRed.length == teamBlue.length && teamRed.length < teamSize) {
        topButton();
    }
    if (!chooseMode && teamSpec.length > 0) {
        const canFillRed = teamRed.length < teamSize;
        const canFillBlue = teamBlue.length < teamSize;
        if (canFillRed || canFillBlue) {
            const targetTeam = (!canFillRed && canFillBlue)
                ? Team.BLUE
                : (!canFillBlue && canFillRed)
                    ? Team.RED
                    : (teamRed.length <= teamBlue.length ? Team.RED : Team.BLUE);
            const nextPlayer = teamSpec[0];
            if (nextPlayer) {
                room.setPlayerTeam(nextPlayer.id, targetTeam);
            }
            return;
        }
    }
    tryAutoStartThreeVThree();
}
}
function handlePlayersJoin() {
    // 1. Zmiana mapy na BIG przy 6 graczach (NiezaleÅ¼nie od trybu wybierania)
    if (teamSize > 2 && players.length == 6) {
        // Sprawdzamy czy mapa juÅ¼ nie jest big, Å¼eby nie spamowaÄ‡
        if (currentStadium !== 'big') {
            setTimeout(() => {
                stadiumCommand(emptyPlayer, `!big`);
            }, 5);
        }
    }

    // 2. ObsÅ‚uga trybu wybierania (Choose Mode)
    if (chooseMode) {
        getSpecList(teamRed.length <= teamBlue.length ? teamRed[0] : teamBlue[0]);
    }

    // 3. Balansowanie skÅ‚adÃ³w
    balanceTeams();
}
function handlePlayersLeave() {
    // 1. Zmiana mapy na CLASSIC przy spadku do 5 graczy (NiezaleÅ¼nie od trybu)
    // DziaÅ‚a przy wyjÅ›ciu z roomu ORAZ przy pÃ³jÅ›ciu na !afk
    if (teamSize > 2 && players.length == 5) {
        if (currentStadium !== 'classic') {
            setTimeout(() => {
                stadiumCommand(emptyPlayer, `!classic`);
            }, 5);
        }
    }

    if (gameState != State.STOP) {
        // Ragequit auto-detection disabled
    }

    if (chooseMode) {
        // (UsuniÄ™to stÄ…d wewnÄ™trzny warunek zmiany mapy, bo jest teraz na gÃ³rze funkcji)
        
        if (teamRed.length == 0 || teamBlue.length == 0) {
            room.setPlayerTeam(teamSpec[0].id, teamRed.length == 0 ? Team.RED : Team.BLUE);
            return;
        }
        if (Math.abs(teamRed.length - teamBlue.length) == teamSpec.length) {
            deactivateChooseMode();
            resumeGame();
            var b = teamSpec.length;
            if (teamRed.length > teamBlue.length) {
                for (var i = 0; i < b; i++) {
                    clearTimeout(insertingTimeout);
                    insertingPlayers = true;
                    setTimeout(() => {
                        room.setPlayerTeam(teamSpec[0].id, Team.BLUE);
                    }, 5 * i);
                }
                insertingTimeout = setTimeout(() => {
                    insertingPlayers = false;
                }, 5 * b);
            } else {
                for (var i = 0; i < b; i++) {
                    clearTimeout(insertingTimeout);
                    insertingPlayers = true;
                    setTimeout(() => {
                        room.setPlayerTeam(teamSpec[0].id, Team.RED);
                    }, 5 * i);
                }
                insertingTimeout = setTimeout(() => {
                    insertingPlayers = false;
                }, 5 * b);
            }
            return;
        }
        if (streak == 0 && gameState == State.STOP) {
            if (Math.abs(teamRed.length - teamBlue.length) == 2) {
                var teamIn = teamRed.length > teamBlue.length ? teamRed : teamBlue;
                room.setPlayerTeam(teamIn[teamIn.length - 1].id, Team.SPECTATORS)
            }
        }
        if (teamRed.length == teamBlue.length && teamSpec.length < 2) {
            deactivateChooseMode();
            resumeGame();
            return;
        }

        if (capLeft) {
            choosePlayer();
        } else {
            getSpecList(teamRed.length <= teamBlue.length ? teamRed[0] : teamBlue[0]);
        }
    }
    balanceTeams();
}

function handlePlayersTeamChange(byPlayer) {
    if (chooseMode && !removingPlayers && byPlayer == null) {
        if (Math.abs(teamRed.length - teamBlue.length) == teamSpec.length) {
            deactivateChooseMode();
            resumeGame();
            var b = teamSpec.length;
            if (teamRed.length > teamBlue.length) {
                for (var i = 0; i < b; i++) {
                    clearTimeout(insertingTimeout);
                    insertingPlayers = true;
                    setTimeout(() => {
                        room.setPlayerTeam(teamSpec[0].id, Team.BLUE);
                    }, 5 * i);
                }
                insertingTimeout = setTimeout(() => {
                    insertingPlayers = false;
                }, 5 * b);
            } else {
                for (var i = 0; i < b; i++) {
                    clearTimeout(insertingTimeout);
                    insertingPlayers = true;
                    setTimeout(() => {
                        room.setPlayerTeam(teamSpec[0].id, Team.RED);
                    }, 5 * i);
                }
                insertingTimeout = setTimeout(() => {
                    insertingPlayers = false;
                }, 5 * b);
            }
            return;
        } else if (
            (teamRed.length == teamSize && teamBlue.length == teamSize) ||
            (teamRed.length == teamBlue.length && teamSpec.length < 2)
        ) {
            deactivateChooseMode();
            resumeGame();
        } else if (teamRed.length <= teamBlue.length && redCaptainChoice != '') {
            if (redCaptainChoice == 'top') {
                room.setPlayerTeam(teamSpec[0].id, Team.RED);
            } else if (redCaptainChoice == 'random') {
                var r = getRandomInt(teamSpec.length);
                room.setPlayerTeam(teamSpec[r].id, Team.RED);
            } else {
                room.setPlayerTeam(teamSpec[teamSpec.length - 1].id, Team.RED);
            }
            return;
        } else if (teamBlue.length < teamRed.length && blueCaptainChoice != '') {
            if (blueCaptainChoice == 'top') {
                room.setPlayerTeam(teamSpec[0].id, Team.BLUE);
            } else if (blueCaptainChoice == 'random') {
                var r = getRandomInt(teamSpec.length);
                room.setPlayerTeam(teamSpec[r].id, Team.BLUE);
            } else {
                room.setPlayerTeam(teamSpec[teamSpec.length - 1].id, Team.BLUE);
            }
            return;
        } else {
            choosePlayer();
        }
    }
}

function handlePlayersStop(byPlayer) {
    if (byPlayer == null && endGameVariable) {
        if (chooseMode) {
            if (players.length == 2 * teamSize) {
                chooseMode = false;
                resetButton();
                for (var i = 0; i < teamSize; i++) {
                    clearTimeout(insertingTimeout);
                    insertingPlayers = true;
                    setTimeout(() => {
                        randomButton();
                    }, 200 * i);
                }
                insertingTimeout = setTimeout(() => {
                    insertingPlayers = false;
                }, 200 * teamSize);
                startTimeout = setTimeout(() => {
                    room.startGame();
                }, 2000);
            } else {
                if (lastWinner == Team.RED) {
                    blueToSpecButton();
                } else if (lastWinner == Team.BLUE) {
                    redToSpecButton();
                    setTimeout(() => {
                        swapButton();
                    }, 10);
                } else {
                    resetButton();
                }
                clearTimeout(insertingTimeout);
                insertingPlayers = true;
                setTimeout(() => {
                    topButton();
                }, 300);
                insertingTimeout = setTimeout(() => {
                    insertingPlayers = false;
                }, 300);
            }
        } else {
            if (players.length == 2) {
                if (lastWinner == Team.BLUE) {
                    swapButton();
                }
                startTimeout = setTimeout(() => {
                    room.startGame();
                }, 2000);
            } else if (players.length == 3 || players.length >= 2 * teamSize + 1) {
                if (lastWinner == Team.RED) {
                    blueToSpecButton();
                } else {
                    redToSpecButton();
                    setTimeout(() => {
                        swapButton();
                    }, 5);
                }
                clearTimeout(insertingTimeout);
                insertingPlayers = true;
                setTimeout(() => {
                    topButton();
                }, 200);
                insertingTimeout = setTimeout(() => {
                    insertingPlayers = false;
                }, 300);
                startTimeout = setTimeout(() => {
                    room.startGame();
                }, 2000);
            } else if (players.length == 4) {
                resetButton();
                clearTimeout(insertingTimeout);
                insertingPlayers = true;
                setTimeout(() => {
                    randomButton();
                    setTimeout(() => {
                        randomButton();
                    }, 500);
                }, 500);
                insertingTimeout = setTimeout(() => {
                    insertingPlayers = false;
                }, 2000);
                startTimeout = setTimeout(() => {
                    room.startGame();
                }, 2000);
            } else if (players.length == 5 || players.length >= 2 * teamSize + 1) {
                if (lastWinner == Team.RED) {
                    blueToSpecButton();
                } else {
                    redToSpecButton();
                    setTimeout(() => {
                        swapButton();
                    }, 5);
                }
                clearTimeout(insertingTimeout);
                insertingPlayers = true;
                insertingTimeout = setTimeout(() => {
                    insertingPlayers = false;
                }, 200);
                setTimeout(() => {
                    topButton();
                }, 200);
                activateChooseMode();
            } else if (players.length == 6) {
                resetButton();
                clearTimeout(insertingTimeout);
                insertingPlayers = true;
                insertingTimeout = setTimeout(() => {
                    insertingPlayers = false;
                }, 1500);
                setTimeout(() => {
                    randomButton();
                    setTimeout(() => {
                        randomButton();
                        setTimeout(() => {
                            randomButton();
                        }, 500);
                    }, 500);
                }, 500);
                startTimeout = setTimeout(() => {
                    room.startGame();
                }, 2000);
            }
        }
    }
}

/* STATS FUNCTIONS */

/* GK FUNCTIONS */

function handleGKTeam(team) {
    if (team == Team.SPECTATORS) {
        return null;
    }
    let teamArray = team == Team.RED ? teamRed : teamBlue;
    let playerGK = teamArray.reduce((prev, current) => {
        if (team == Team.RED) {
            return (prev?.position.x < current.position.x) ? prev : current
        } else {
            return (prev?.position.x > current.position.x) ? prev : current
        }
    }, null);
    let playerCompGK = getPlayerComp(playerGK);
    return playerCompGK;
}

function handleGK() {
    let redGK = handleGKTeam(Team.RED);
    if (redGK != null) {
        redGK.GKTicks++;
    }
    let blueGK = handleGKTeam(Team.BLUE);
    if (blueGK != null) {
        blueGK.GKTicks++;
    }
}

function getGK(team) {
    if (team == Team.SPECTATORS) {
        return null;
    }
    let teamArray = team == Team.RED ? game.playerComp[0] : game.playerComp[1];
    let playerGK = teamArray.reduce((prev, current) => {
        return (prev?.GKTicks > current.GKTicks) ? prev : current
    }, null);
    return playerGK;
}

function getCS(scores) {
    let playersNameCS = [];
    let redGK = getGK(Team.RED);
    let blueGK = getGK(Team.BLUE);
    if (redGK != null && scores.blue == 0) {
        playersNameCS.push(redGK.player.name);
    }
    if (blueGK != null && scores.red == 0) {
        playersNameCS.push(blueGK.player.name);
    }
    return playersNameCS;
}

function getCSString(scores) {
    let playersCS = getCS(scores);
    if (playersCS.length == 0) {
        return "ðŸ¥… Brak cs ";
    } else if (playersCS.length == 1) {
        return `ðŸ¥… ${playersCS[0]} ma czyste konto!`;
    } else {
        return `ðŸ¥… ${playersCS[0]} i ${playersCS[1]} majÄ… czyste konta!`;
    }
}

/* GLOBAL STATS FUNCTIONS */

function getLastTouchOfTheBall() {
    const ballPosition = room.getBallPosition();
    updateTeams();
    let playerArray = [];
    for (let player of players) {
        if (player.position != null) {
            var distanceToBall = pointDistance(player.position, ballPosition);
            if (distanceToBall < triggerDistance) {
                if (playSituation == Situation.KICKOFF) playSituation = Situation.PLAY;
                playerArray.push([player, distanceToBall]);
            }
        }
    }
    if (playerArray.length != 0) {
        let playerTouch = playerArray.sort((a, b) => a[1] - b[1])[0][0];
        if (lastTeamTouched == playerTouch.team || lastTeamTouched == Team.SPECTATORS) {
            if (lastTouches[0] == null || (lastTouches[0] != null && lastTouches[0].player.id != playerTouch.id)) {
                game.touchArray.push(
                    new BallTouch(
                        playerTouch,
                        game.scores.time,
                        getGoalGame(),
                        ballPosition
                    )
                );
                lastTouches[0] = checkGoalKickTouch(
                    game.touchArray,
                    game.touchArray.length - 1,
                    getGoalGame()
                );
                lastTouches[1] = checkGoalKickTouch(
                    game.touchArray,
                    game.touchArray.length - 2,
                    getGoalGame()
                );
            }
        }
        lastTeamTouched = playerTouch.team;
    }
}

function getBallSpeed() {
    var ballProp = ballProps();
    return Math.sqrt(ballProp.xspeed ** 2 + ballProp.yspeed ** 2) * speedCoefficient;
}

function getGameStats() {
    if (playSituation == Situation.PLAY && gameState == State.PLAY) {
        lastTeamTouched == Team.RED ? possession[0]++ : possession[1]++;
        var ballPosition = room.getBallPosition();
        ballPosition.x < 0 ? actionZoneHalf[0]++ : actionZoneHalf[1]++;
        handleGK();
    }
}

/* GOAL ATTRIBUTION FUNCTIONS */

function getGoalAttribution(team) {
    var goalAttribution = Array(2).fill(null);
    if (lastTouches[0] != null) {
        if (lastTouches[0].player.team == team) {
            // Direct goal scored by player
            if (lastTouches[1] != null && lastTouches[1].player.team == team) {
                goalAttribution = [lastTouches[0].player, lastTouches[1].player];
            } else {
                goalAttribution = [lastTouches[0].player, null];
            }
        } else {
            // Own goal
            goalAttribution = [lastTouches[0].player, null];
        }
    }
    return goalAttribution;
}

function getGoalString(team) {
    var goalString;
    var scores = game.scores;
    var goalAttribution = getGoalAttribution(team);
    if (goalAttribution[0] != null) {
        if (goalAttribution[0].team == team) {
            if (goalAttribution[1] != null && goalAttribution[1].team == team) {
                goalString = `âš½ ${getTimeGame(scores.time)} Gola strzeliÅ‚  ${goalAttribution[0].name} ! AsystowaÅ‚ ${goalAttribution[1].name}. PrÄ™dkoÅ›Ä‡ piÅ‚ki : ${ballSpeed.toFixed(2)}km/h.`;
                game.goals.push(
                    new Goal(
                        scores.time,
                        team,
                        goalAttribution[0],
                        goalAttribution[1]
                    )
                );
            } else {
                goalString = `âš½ ${getTimeGame(scores.time)} Gola strzeliÅ‚ ${goalAttribution[0].name} ! PrÄ™dkoÅ›Ä‡ piÅ‚ki : ${ballSpeed.toFixed(2)}km/h.`;
                game.goals.push(
                    new Goal(scores.time, team, goalAttribution[0], null)
                );
            }
        } else {
            goalString = `ðŸ˜‚ ${getTimeGame(scores.time)} SamobÃ³ja strzeliÅ‚: ${goalAttribution[0].name} ! PrÄ™dkoÅ›Ä‡ piÅ‚ki : ${ballSpeed.toFixed(2)}km/h.`;
            game.goals.push(
                new Goal(scores.time, team, goalAttribution[0], null)
            );
        }
    } else {
        goalString = `âš½ ${getTimeGame(scores.time)} Gol dla ${team == Team.RED ? 'red' : 'blue'} druÅ¼yny! PrÄ™dkoÅ›Ä‡ piÅ‚ki : ${ballSpeed.toFixed(2)}km/h.`;
        game.goals.push(
            new Goal(scores.time, team, null, null)
        );
    }

    return goalString;
}

/* ROOM STATS FUNCTIONS */

function updatePlayerStats(player, teamStats) {
    var stats = new HaxStatistics(player.name);
    var pComp = getPlayerComp(player);
    var storageKey = authArray[player.id][0];
    
    if (storageKey && localStorage.getItem(storageKey)) {
        try {
            var parsed = JSON.parse(localStorage.getItem(storageKey));
            if (parsed && typeof parsed === 'object') Object.assign(stats, parsed);
        } catch (_) {}
    }

    stats.games = Number(stats.games) || 0;
    stats.wins = Number(stats.wins) || 0;
    stats.losses = Number(stats.losses) || 0;
    stats.games++;
    
    // --- SYSTEM MONET (POPRAWIONY) ---
    var earnedCoins = 0;
    
    if (lastWinner == teamStats) {
        stats.wins++;
        earnedCoins += COIN_RATES.WIN;
    } else if (lastWinner !== Team.SPECTATORS) {
        stats.losses++;
        earnedCoins += COIN_RATES.LOSS;
    }
    
    var g = getGoalsPlayer(pComp);
    var a = getAssistsPlayer(pComp);
    var cs = getCSPlayer(pComp);
    var minutes = getGametimePlayer(pComp) / 60;

    stats.winrate = ((100 * stats.wins) / (stats.games || 1)).toFixed(1) + `%`;
    stats.goals += g;
    stats.assists += a;
    stats.ownGoals += getOwnGoalsPlayer(pComp);
    stats.CS += cs;
    stats.playtime += getGametimePlayer(pComp);
    
    // Bonusy
    earnedCoins += (g * COIN_RATES.GOAL);
    earnedCoins += (a * COIN_RATES.ASSIST);
    earnedCoins += (cs * COIN_RATES.CS);
    earnedCoins += Math.floor(minutes * COIN_RATES.PLAYTIME_PER_MIN);

    if (earnedCoins > 0) {
        addCoins(player, earnedCoins);
        // Komunikat dla gracza o zarobku
        room.sendAnnouncement(`ðŸ’° ZarobiÅ‚eÅ› ${earnedCoins} monet za ten mecz!`, player.id, 0xFFD700, 'small', HaxNotification.NONE);
    }
    // --------------------

    localStorage.setItem(storageKey, JSON.stringify(stats));
}

function updateStats() {
    // ZMIANA: Odpalamy statystyki i monety, jeÅ›li jest min. 2 graczy (1v1)
    if (
        players.length >= 2 && 
        (
            game.scores.time >= (5 / 6) * game.scores.timeLimit ||
            game.scores.red == game.scores.scoreLimit ||
            game.scores.blue == game.scores.scoreLimit
        ) &&
        teamRedStats.length >= 1 && teamBlueStats.length >= 1
    ) {
        for (let player of teamRedStats) {
            updatePlayerStats(player, Team.RED);
        }
        for (let player of teamBlueStats) {
            updatePlayerStats(player, Team.BLUE);
        }
    }
}

function printRankings(statKey, id = 0) {
    var leaderboard = [];
    statKey = (statKey == "cs") ? "CS" : statKey;

    for (var i = 0; i < localStorage.length; i++) {
        var k = localStorage.key(i);
        try {
            var raw = localStorage.getItem(k);
            if (!raw) continue;
            var obj = JSON.parse(raw);
            if (!obj || typeof obj !== 'object') continue;
            if (typeof obj.playerName !== 'string') continue;
            var val = obj[statKey];
            if (statKey === 'losses') {
                val = Number(val);
                if (isNaN(val)) val = 0;
            }
            if (val == null || isNaN(Number(val))) continue;
            leaderboard.push([obj.playerName, Number(val)]);
        } catch (e) {
            // ignore non-JSON entries
        }
    }

    if (leaderboard.length === 0) {
        room.sendAnnouncement('Nie ma grajcÃ³w!', id || null, errorColor, 'small', HaxNotification.CHAT);
        return;
    }

    leaderboard.sort(function(a,b){ return b[1] - a[1]; });
    var limit = Math.min(5, leaderboard.length);

    var rankingString = statKey.toUpperCase() + ': ';
    for (let i = 0; i < limit; i++) {
        let playerName = leaderboard[i][0];
        let playerStat = leaderboard[i][1];
        if (statKey === 'playtime') playerStat = getTimeStats(playerStat);
        rankingString += `#${i + 1} ${playerName} : ${playerStat}, `;
    }
    rankingString = rankingString.substring(0, rankingString.length - 2);

    room.sendAnnouncement(rankingString, id || null, infoColor, 'small', HaxNotification.CHAT);
}

/* GET STATS FUNCTIONS */

function getGamePlayerStats(player) {
    var stats = new HaxStatistics(player.name);
    var pComp = getPlayerComp(player);
    stats.goals += getGoalsPlayer(pComp);
    stats.assists += getAssistsPlayer(pComp);
    stats.ownGoals += getOwnGoalsPlayer(pComp);
    stats.playtime += getGametimePlayer(pComp);
    stats.CS += getCSPlayer(pComp);
    return stats;
}

function getGametimePlayer(pComp) {
    if (pComp == null) return 0;
    var timePlayer = 0;
    for (let j = 0; j < pComp.timeEntry.length; j++) {
        if (pComp.timeExit.length < j + 1) {
            timePlayer += game.scores.time - pComp.timeEntry[j];
        } else {
            timePlayer += pComp.timeExit[j] - pComp.timeEntry[j];
        }
    }
    return Math.floor(timePlayer);
}

function getGoalsPlayer(pComp) {
    if (pComp == null) return 0;
    var goalPlayer = 0;
    for (let goal of game.goals) {
        if (goal.striker != null && goal.team === pComp.player.team) {
            if (authArray[goal.striker.id][0] == pComp.auth) {
                goalPlayer++;
            }
        }
    }
    return goalPlayer;
}

function getOwnGoalsPlayer(pComp) {
    if (pComp == null) return 0;
    var goalPlayer = 0;
    for (let goal of game.goals) {
        if (goal.striker != null && goal.team !== pComp.player.team) {
            if (authArray[goal.striker.id][0] == pComp.auth) {
                goalPlayer++;
            }
        }
    }
    return goalPlayer;
}

function getAssistsPlayer(pComp) {
    if (pComp == null) return 0;
    var assistPlayer = 0;
    for (let goal of game.goals) {
        if (goal.assist != null) {
            if (authArray[goal.assist.id][0] == pComp.auth) {
                assistPlayer++;
            }
        }
    }
    return assistPlayer;
}

function getGKPlayer(pComp) {
    if (pComp == null) return 0;
    let GKRed = getGK(Team.RED);
    if (pComp.auth == GKRed?.auth) {
        return Team.RED;
    }
    let GKBlue = getGK(Team.BLUE);
    if (pComp.auth == GKBlue?.auth) {
        return Team.BLUE;
    }
    return Team.SPECTATORS;
}

function getCSPlayer(pComp) {
    if (pComp == null || game.scores == null) return 0;
    if (getGKPlayer(pComp) == Team.RED && game.scores.blue == 0) {
        return 1;
    } else if (getGKPlayer(pComp) == Team.BLUE && game.scores.red == 0) {
        return 1;
    }
    return 0;
}

function actionReportCountTeam(goals, team) {
    let playerActionSummaryTeam = [];
    let indexTeam = team == Team.RED ? 0 : 1;
    let indexOtherTeam = team == Team.RED ? 1 : 0;
    for (let goal of goals[indexTeam]) {
        if (goal[0] != null) {
            if (playerActionSummaryTeam.find(a => a[0].id == goal[0].id)) {
                let index = playerActionSummaryTeam.findIndex(a => a[0].id == goal[0].id);
                playerActionSummaryTeam[index][1]++;
            } else {
                playerActionSummaryTeam.push([goal[0], 1, 0, 0]);
            }
            if (goal[1] != null) {
                if (playerActionSummaryTeam.find(a => a[0].id == goal[1].id)) {
                    let index = playerActionSummaryTeam.findIndex(a => a[0].id == goal[1].id);
                    playerActionSummaryTeam[index][2]++;
                } else {
                    playerActionSummaryTeam.push([goal[1], 0, 1, 0]);
                }
            }
        }
    }
    if (goals[indexOtherTeam].length == 0) {
        let playerCS = getGK(team)?.player;
        if (playerCS != null) {
            if (playerActionSummaryTeam.find(a => a[0].id == playerCS.id)) {
                let index = playerActionSummaryTeam.findIndex(a => a[0].id == playerCS.id);
                playerActionSummaryTeam[index][3]++;
            } else {
                playerActionSummaryTeam.push([playerCS, 0, 0, 1]);
            }
        }
    }

    playerActionSummaryTeam.sort((a, b) => (a[1] + a[2] + a[3]) - (b[1] + b[2] + b[3]));
    return playerActionSummaryTeam;
}

/* PRINT FUNCTIONS */

function printPlayerStats(stats) {
    let statsString = '';
    for (let [key, value] of Object.entries(stats)) {
        if (key == 'playerName') statsString += `${value}: `;
        else {
            if (key == 'playtime') value = getTimeStats(value);
            let reCamelCase = /([A-Z](?=[a-z]+)|[A-Z]+(?![a-z]))/g;
            let statName = key.replaceAll(reCamelCase, ' $1').trim();
            statsString += `${statName.charAt(0).toUpperCase() + statName.slice(1)}: ${value}, `;
        }
    }
    statsString = statsString.substring(0, statsString.length - 2);
    return statsString;
}

/* FETCH FUNCTIONS */

function fetchGametimeReport(game) {
    var fieldGametimeRed = {
        name: 'ðŸ”´        **Statystki Czerwonych**',
        value: 'âŒ› __**Czas gry:**__\n\n',
        inline: true,
    };
    var fieldGametimeBlue = {
        name: 'ðŸ”µ       **Statystyki Niebieskich**',
        value: 'âŒ› __**Czas gry:**__\n\n',
        inline: true,
    };
    var redTeamTimes = game.playerComp[0].map((p) => [p.player, getGametimePlayer(p)]);
    var blueTeamTimes = game.playerComp[1].map((p) => [p.player, getGametimePlayer(p)]);

    for (let time of redTeamTimes) {
        var minutes = getMinutesReport(time[1]);
        var seconds = getSecondsReport(time[1]);
        fieldGametimeRed.value += `> **${time[0].name}:** ${minutes > 0 ? `${minutes}m` : ''}` +
            `${seconds > 0 || minutes == 0 ? `${seconds}s` : ''}\n`;
    }
    fieldGametimeRed.value += `\n${blueTeamTimes.length - redTeamTimes.length > 0 ? '\n'.repeat(blueTeamTimes.length - redTeamTimes.length) : ''
        }`;
    fieldGametimeRed.value += '=====================';

    for (let time of blueTeamTimes) {
        var minutes = getMinutesReport(time[1]);
        var seconds = getSecondsReport(time[1]);
        fieldGametimeBlue.value += `> **${time[0].name}:** ${minutes > 0 ? `${minutes}m` : ''}` +
            `${seconds > 0 || minutes == 0 ? `${seconds}s` : ''}\n`;
    }
    fieldGametimeBlue.value += `\n${redTeamTimes.length - blueTeamTimes.length > 0 ? '\n'.repeat(redTeamTimes.length - blueTeamTimes.length) : ''
        }`;
    fieldGametimeBlue.value += '=====================';

    return [fieldGametimeRed, fieldGametimeBlue];
}

function fetchActionsSummaryReport(game) {
    var fieldReportRed = {
        name: 'ðŸ”´        **Statystki Czerwonych**',
        value: 'ðŸ“Š __**Statystki grajcÃ³w:**__\n\n',
        inline: true,
    };
    var fieldReportBlue = {
        name: 'ðŸ”µ       **Statystki Niebieskich**',
        value: 'ðŸ“Š __**Statystyki grajcÃ³w**__\n\n',
        inline: true,
    };
    var goals = [[], []];
    for (let i = 0; i < game.goals.length; i++) {
        goals[game.goals[i].team - 1].push([game.goals[i].striker, game.goals[i].assist]);
    }
    var redActions = actionReportCountTeam(goals, Team.RED);
    if (redActions.length > 0) {
        for (let act of redActions) {
            fieldReportRed.value += `> **${act[0].team != Team.RED ? '[OG] ' : ''}${act[0].name}:**` +
                `${act[1] > 0 ? ` ${act[1]}G` : ''}` +
                `${act[2] > 0 ? ` ${act[2]}A` : ''}` +
                `${act[3] > 0 ? ` ${act[3]}CS` : ''}\n`;
        }
    }
    var blueActions = actionReportCountTeam(goals, Team.BLUE);
    if (blueActions.length > 0) {
        for (let act of blueActions) {
            fieldReportBlue.value += `> **${act[0].team != Team.BLUE ? '[OG] ' : ''}${act[0].name}:**` +
                `${act[1] > 0 ? ` ${act[1]}G` : ''}` +
                `${act[2] > 0 ? ` ${act[2]}A` : ''}` +
                `${act[3] > 0 ? ` ${act[3]}CS` : ''}\n`;
        }
    }

    fieldReportRed.value += `\n${blueActions.length - redActions.length > 0 ? '\n'.repeat(blueActions.length - redActions.length) : ''
        }`;
    fieldReportRed.value += '=====================';

    fieldReportBlue.value += `\n${redActions.length - blueActions.length > 0 ? '\n'.repeat(redActions.length - blueActions.length) : ''
        }`;
    fieldReportBlue.value += '=====================';

    return [fieldReportRed, fieldReportBlue];
}

function fetchSummaryEmbed(game) {
    var fetchEndgame = [fetchGametimeReport, fetchActionsSummaryReport];
    var logChannel = gameWebhook;
    var fields = [
        {
            name: 'ðŸ”´        **Statystki Czerwonych**',
            value: '=====================\n\n',
            inline: true,
        },
        {
            name: 'ðŸ”µ       **Statystki Niebieskich**',
            value: '=====================\n\n',
            inline: true,
        },
    ];
    for (let i = 0; i < fetchEndgame.length; i++) {
        var fieldsReport = fetchEndgame[i](game);
        fields[0].value += fieldsReport[0].value + '\n\n';
        fields[1].value += fieldsReport[1].value + '\n\n';
    }
    fields[0].value = fields[0].value.substring(0, fields[0].value.length - 2);
    fields[1].value = fields[1].value.substring(0, fields[1].value.length - 2);

    var possR = possession[0] / (possession[0] + possession[1]);
    var possB = 1 - possR;
    var possRString = (possR * 100).toFixed(0).toString();
    var possBString = (possB * 100).toFixed(0).toString();
    var zoneR = actionZoneHalf[0] / (actionZoneHalf[0] + actionZoneHalf[1]);
    var zoneB = 1 - zoneR;
    var zoneRString = (zoneR * 100).toFixed(0).toString();
    var zoneBString = (zoneB * 100).toFixed(0).toString();
    var win = (game.scores.red > game.scores.blue) * 1 + (game.scores.blue > game.scores.red) * 2;
    var objectBodyWebhook = {
        embeds: [
            {
                title: `ðŸ“ MATCH REPORT #${getIdReport()}`,
                description:
                    `**${getTimeEmbed(game.scores.time)}** ` +
                    (win == 1 ? '**Red Team** ' : 'Red Team ') + game.scores.red +
                    ' - ' +
                    game.scores.blue + (win == 2 ? ' **Blue Team**' : ' Blue Team') +
                    '\n```c\nPossession: ' + possRString + '% - ' + possBString + '%' +
                    '\nAction Zone: ' + zoneRString + '% - ' + zoneBString + '%\n```\n\n',
                color: 9567999,
                fields: fields,
                footer: {
                    text: `Recording: ${getRecordingName(game)}`,
                },
                timestamp: new Date().toISOString(),
            },
        ],
        username: roomName
    };
    if (logChannel != '') {
        safeFetch(logChannel, {
            method: 'POST',
            body: JSON.stringify(objectBodyWebhook),
            headers: {
                'Content-Type': 'application/json',
            },
        });
    }
}
/* NOWE FUNKCJE DISCORD */

/* --- ZAAWANSOWANY SYSTEM DISCORD (AUTO-EDYCJA) --- */

// GÅ‚Ã³wna funkcja: WysyÅ‚a nowÄ… wiadomoÅ›Ä‡ LUB edytuje starÄ…, jeÅ›li istnieje
async function sendOrUpdateWebhook(webhookUrl, payload, storageKey) {
    if (!webhookUrl || !webhookUrl.startsWith("http")) return;

    // Pobieramy ID ostatniej wiadomoÅ›ci z pamiÄ™ci
    let lastMessageId = localStorage.getItem(storageKey);

    // 1. PRÃ“BA EDYCJI (PATCH)
    if (lastMessageId) {
        const editUrl = `${webhookUrl}/messages/${lastMessageId}`;
        try {
            const res = await fetch(editUrl, {
                method: 'PATCH',
                body: JSON.stringify(payload),
                headers: { 'Content-Type': 'application/json' }
            });

            if (res.ok) {
                return; // UdaÅ‚o siÄ™ edytowaÄ‡, koÅ„czymy
            } else if (res.status === 404) {
                // WiadomoÅ›Ä‡ zostaÅ‚a usuniÄ™ta na Discordzie -> czyÅ›cimy ID i wyÅ›lemy nowÄ…
                console.log(`[Discord] WiadomoÅ›Ä‡ ${storageKey} nie istnieje (404). TworzÄ™ nowÄ….`);
                localStorage.removeItem(storageKey);
            } else {
                console.log(`[Discord] BÅ‚Ä…d edycji ${res.status}: ${res.statusText}`);
                // Inne bÅ‚Ä™dy (np. brak uprawnieÅ„) - nie robimy nic, Å¼eby nie spamowaÄ‡
                return; 
            }
        } catch (e) {
            console.log(`[Discord] BÅ‚Ä…d poÅ‚Ä…czenia przy edycji: ${e}`);
            return;
        }
    }

    // 2. WYSÅANIE NOWEJ (POST) - jeÅ›li nie byÅ‚o ID lub edycja siÄ™ nie udaÅ‚a (404)
    try {
        // Dodajemy ?wait=true, aby Discord zwrÃ³ciÅ‚ nam ID nowej wiadomoÅ›ci
        const res = await fetch(webhookUrl + "?wait=true", {
            method: 'POST',
            body: JSON.stringify(payload),
            headers: { 'Content-Type': 'application/json' }
        });

        if (res.ok) {
            const data = await res.json();
            if (data && data.id) {
                localStorage.setItem(storageKey, data.id); // Zapisujemy ID na przyszÅ‚oÅ›Ä‡
                console.log(`[Discord] Utworzono nowÄ… wiadomoÅ›Ä‡ dla ${storageKey}: ${data.id}`);
            }
        } else {
            console.log(`[Discord] BÅ‚Ä…d wysyÅ‚ania nowej wiadomoÅ›ci ${res.status}: ${res.statusText}`);
        }
    } catch (e) {
        console.log(`[Discord] BÅ‚Ä…d poÅ‚Ä…czenia przy wysyÅ‚aniu: ${e}`);
    }
}

// --- RANKING (Top 15) ---
function sendRankingToDiscord() {
    var store = globalThis.eloStore;
    if (!store || !store.ratings) return;

    var entries = Object.entries(store.ratings).map(([auth, rating]) => {
        let name = (store.names && store.names[auth]) ? store.names[auth] : auth;
        return { name: name, rating: Number(rating) };
    });
    
    entries.sort((a, b) => b.rating - a.rating);
    var top = entries.slice(0, 15);
    if (top.length === 0) return;

    var description = "";
    var medals = ["ðŸ¥‡", "ðŸ¥ˆ", "ðŸ¥‰"];

    for (var i = 0; i < top.length; i++) {
        let prefix = i < 3 ? medals[i] : `${i + 1}.`;
        let rClass = typeof classLabel === "function" ? classLabel(top[i].rating) : "";
        // Formatowanie linii rankingu
        description += `**${prefix}** ${top[i].name} â€” **${top[i].rating.toFixed(0)}** ${rClass ? `(${rClass})` : ""}\n`;
    }

    var embed = {
        title: "ðŸ† Aktualny Ranking ELO (Top 15)",
        description: description,
        color: 0xFFD700, // ZÅ‚oty
        footer: { text: "Ranking odÅ›wieÅ¼a siÄ™ automatycznie w tej wiadomoÅ›ci" },
        timestamp: new Date().toISOString()
    };

    // UÅ¼ywamy klucza "__discord_ranking_msg_id" do zapamiÄ™tania wiadomoÅ›ci
    sendOrUpdateWebhook(rankingWebhook, { embeds: [embed] }, "__discord_ranking_msg_id");
}

// --- STATUS ROOMU (Lista graczy) ---
var statusTimeout = null;

function scheduleStatusUpdate() {
    if (statusTimeout) clearTimeout(statusTimeout);
    statusTimeout = setTimeout(sendStatusToDiscord, 4000); // 4s opÃ³Åºnienia
}

function sendStatusToDiscord() {
    var players = room.getPlayerList();
    
    var redP = players.filter(p => p.team == 1).map(p => p.name).join(", ");
    var blueP = players.filter(p => p.team == 2).map(p => p.name).join(", ");
    var specP = players.filter(p => p.team == 0).map(p => p.name).join(", ");

    if (redP === "") redP = "pusto";
    if (blueP === "") blueP = "pusto";
    if (specP === "") specP = "pusto";

    var totalPlayers = players.length;
    
    var embed = {
        title: `ðŸŸï¸ Status Pokoju | Graczy: ${totalPlayers}/${maxPlayers}`,
        color: 0x00ff00, // Zielony
        fields: [
            { name: "ðŸ”´ Red Team", value: "```" + redP + "```", inline: false },
            { name: "ðŸ”µ Blue Team", value: "```" + blueP + "```", inline: false },
            { name: "ðŸ‘€ Spectators", value: "```" + specP + "```", inline: false }
        ],
        footer: { text: "Ta wiadomoÅ›Ä‡ aktualizuje siÄ™ na Å¼ywo" },
        timestamp: new Date().toISOString()
    };
    
    // JeÅ›li masz hasÅ‚o na pokoju, warto o tym wspomnieÄ‡ w tytule lub stopce
    if (roomPassword && roomPassword !== "") {
        embed.footer.text += " | Room ma hasÅ‚o!";
    }

    // UÅ¼ywamy klucza "__discord_status_msg_id" do zapamiÄ™tania wiadomoÅ›ci
    sendOrUpdateWebhook(statusWebhook, { embeds: [embed] }, "__discord_status_msg_id");
}
/* EVENTS */

/* PLAYER MOVEMENT */

room.onPlayerJoin = function (player) {
    authArray[player.id] = [player.auth, player.conn];
    ensureIgnoreCacheForPlayer(player);
    recordKnownPlayer(player);
if (enforceActiveBanOnJoin(player)) {
        return;
    }
    // OPTYMALIZACJA: Dodajemy do bufora zamiast wysyÅ‚aÄ‡ od razu
    if (typeof chatLogBuffer !== 'undefined') {
        chatLogBuffer.push(`[${getDate()}] ðŸŸ¢ JOIN (${playersAll.length + 1}/${maxPlayers}) **${player.name}** [${authArray[player.id][0]}] {${authArray[player.id][1]}}`);
    }
    room.sendAnnouncement(
        `ðŸ‘‹ Witaj ${player.name}!\nWpisz "t" Å¼eby pisaÄ‡ do swojej druÅ¼yny, lub "@@<nazwa gracza>".`,
        player.id,
        welcomeColor,
        'small',
        HaxNotification.CHAT
    );
    room.sendAnnouncement(
        `Zapraszamy na discord! https://discord.gg/HBabx8b93k`,
        player.id,
        discordColor,
        'small',
        HaxNotification.CHAT
    );
    updateTeams();
    updateAdmins();
    var sameAuthCheck = playersAll.filter((p) => p.id != player.id && authArray[p.id][0] == player.auth);
    if (sameAuthCheck.length > 0 && !debugMode) {
        var oldPlayerArray = playersAll.filter((p) => p.id != player.id && authArray[p.id][0] == player.auth);
        for (let oldPlayer of oldPlayerArray) {
            ghostKickHandle(oldPlayer, player);
        }
    }
    handlePlayersJoin();
    tryAutoStartThreeVThree();
    scheduleStatusUpdate();
};

room.onPlayerTeamChange = function (changedPlayer, byPlayer) {
    handleLineupChangeTeamChange(changedPlayer);
    if (AFKSet.has(changedPlayer.id) && changedPlayer.team != Team.SPECTATORS) {
        room.setPlayerTeam(changedPlayer.id, Team.SPECTATORS);
        movePlayerToQueueEnd(changedPlayer.id);
        room.sendAnnouncement(
            `${changedPlayer.name} jest afk!`,
            changedPlayer.id,
            errorColor,
            'small',
            HaxNotification.CHAT
        );
        return;
    }
    if (changedPlayer.team == Team.SPECTATORS && AFKSet.has(changedPlayer.id)) {
        movePlayerToQueueEnd(changedPlayer.id);
    }
    updateTeams();
    if (gameState != State.STOP) {
        if (changedPlayer.team != Team.SPECTATORS && game.scores.time <= (3 / 4) * game.scores.timeLimit && Math.abs(game.scores.blue - game.scores.red) < 2) {
            changedPlayer.team == Team.RED ? teamRedStats.push(changedPlayer) : teamBlueStats.push(changedPlayer);
        }
    }
    handleActivityPlayerTeamChange(changedPlayer);
    handlePlayersTeamChange(byPlayer);
    scheduleEnsureAFKsAtSpecEnd();
    tryAutoStartThreeVThree();
    scheduleStatusUpdate();
};

room.onPlayerLeave = function (player) {
    recordKnownPlayer(player);
    voluntaryLeaveIds.delete(player.id);
setTimeout(() => {
        if (!kickFetchVariable) {
            // OPTYMALIZACJA: Dodajemy do bufora zamiast wysyÅ‚aÄ‡ od razu
            if (typeof chatLogBuffer !== 'undefined') {
                chatLogBuffer.push(`[${getDate()}] ðŸ”´ LEAVE (${playersAll.length}/${maxPlayers}) **${player.name}** [${authArray[player.id][0]}] {${authArray[player.id][1]}}`);
            }
        } else kickFetchVariable = false;
    }, 10);
    clearAFKTracking(player.id);
    const cooldownKey = getAFKCooldownKey(player);
    if (cooldownKey) {
        AFKCooldownUntilByKey.delete(cooldownKey);
    }
    AFKCooldownKeyById.delete(player.id);
    AFKCommandCooldownUntilById.delete(player.id);
    handleLineupChangeLeave(player);
    checkCaptainLeave(player);
    updateTeams();
    updateAdmins();
    handlePlayersLeave();
    tryAutoStartThreeVThree();
    scheduleStatusUpdate();
    performDiskSave();
};

room.onPlayerKicked = function (kickedPlayer, reason, ban, byPlayer) {
    kickFetchVariable = true;
    const isVoluntary = voluntaryLeaveIds.has(kickedPlayer.id);
    if (isVoluntary) {
        voluntaryLeaveIds.delete(kickedPlayer.id);
        if (roomWebhook != '') {
            var voluntaryContent = `[${getDate()}] LEAVE (${playersAll.length}/${maxPlayers})\n` +
                `**${kickedPlayer.name}** [${authArray[kickedPlayer.id][0]}] {${authArray[kickedPlayer.id][1]}} dobrowolnie opuscil pokoj (!bb).`;
            safeFetch(roomWebhook, {
                method: 'POST',
                body: JSON.stringify({
                    content: voluntaryContent,
                    username: roomName,
                }),
                headers: {
                    'Content-Type': 'application/json',
                },
            });
        }
        return;
    }
    if (roomWebhook != '') {
        var stringContent = `[${getDate()}] ${ban ? 'BAN' : 'KICK'} (${playersAll.length}/${maxPlayers})\n` +
            `**${kickedPlayer.name}** [${authArray[kickedPlayer.id][0]}] {${authArray[kickedPlayer.id][1]}} zostaï¿½ ${ban ? 'zbanowany' : 'wykopany'}` +
            `${byPlayer != null ? ' dziï¿½ki **' + byPlayer.name + '** [' + authArray[byPlayer.id][0] + '] {' + authArray[byPlayer.id][1] + '}' : ''}`;
        safeFetch(roomWebhook, {
            method: 'POST',
            body: JSON.stringify({
                content: stringContent,
                username: roomName,
            }),
            headers: {
                'Content-Type': 'application/json',
            },
        });
    }
    if ((ban && ((byPlayer != null &&
        (byPlayer.id == kickedPlayer.id || getRole(byPlayer) < Role.ADMIN_PERM)) || getRole(kickedPlayer) == Role.MASTER)) || disableBans
    ) {
        room.clearBan(kickedPlayer.id);
        return;
    }
    if (byPlayer != null && getRole(byPlayer) < Role.ADMIN_PERM) {
        room.sendAnnouncement(
            'Nie masz prawa wykopywaÄ‡ stÄ…d ludzi!',
            byPlayer.id,
            errorColor,
            'bold',
            HaxNotification.CHAT
        );
        room.setPlayerAdmin(byPlayer.id, false);
        return;
    }
    if (ban) {
        var kickedAuth = null;
        try {
            kickedAuth = getPlayerAuth(kickedPlayer);
        } catch (_){ }
        var banKey = kickedAuth ? banKeyFromAuth(kickedAuth) : banKeyFromId(kickedPlayer.id);
        if (banKey) {
            var exists = false;
            for (let i = 0; i < banList.length; i++) {
                if (banList[i][1] === banKey) {
                    exists = true;
                    banList[i][0] = kickedPlayer.name;
                    break;
                }
            }
            if (!exists) {
                banList.push([kickedPlayer.name, banKey]);
            }
            persistBanState();
        }
    }
};

/* PLAYER ACTIVITY */

room.onPlayerChat = function (player, message) {
    if (gameState !== State.STOP && player.team != Team.SPECTATORS) {
        let pComp = getPlayerComp(player);
        if (pComp != null) pComp.inactivityTicks = 0;
    }
    let msgArray = message.split(/ +/);
if (!hideClaimMessage || msgArray[0] != '!claim') {
        // Zamiast wysyÅ‚aÄ‡ od razu, dodajemy do kolejki
        var logEntry = `[${getDate()}] ðŸ’¬ **${player.name}**: ${message.replace('@', '@ ')}`;
        chatLogBuffer.push(logEntry);
    }
    if (msgArray[0][0] == '!') {
        let command = getCommand(msgArray[0].slice(1).toLowerCase());
        console.log(msgArray, command);
        console.log(getRole(player));
        if (command != false && commands[command].roles <= getRole(player)) commands[command].function(player, message);
        else
            room.sendAnnouncement(
                `Nie ma takiej komendy. UÅ¼yj '!help'`,
                player.id,
                errorColor,
                'bold',
                HaxNotification.CHAT
            );
        return false;
    }
    if (msgArray[0].toLowerCase() == 't') {
        teamChat(player, message);
        return false;
    }
    if (msgArray[0].substring(0, 2) === '@@') {
        playerChat(player, message);
        return false;
    }
    if (chooseMode && teamRed.length * teamBlue.length != 0) {
        var choosingMessageCheck = chooseModeFunction(player, message);
        if (choosingMessageCheck) return false;
    }
    if (slowMode > 0) {
        var filter = slowModeFunction(player, message);
        if (filter) return false;
    }
    if (!player.admin && muteArray.getByAuth(authArray[player.id][0]) != null) {
        room.sendAnnouncement(
            `Nikt ciÄ™ nie chce sÅ‚uchaÄ‡!`,
            player.id,
            errorColor,
            'bold',
            HaxNotification.CHAT
        );
        return false;
    }
    const prefixEmoji = getChatEmojiForPlayer(player);
    var chatLine = `${prefixEmoji ? prefixEmoji + ' ' : ''}${player.name}: ${message}`;
// DomyÅ›lny kolor
    var chatColor = player.team == Team.RED ? redChatColor : player.team == Team.BLUE ? blueChatColor : defaultColor;

    // --- KOLORY Z EKWIPUNKU (POPRAWIONE) ---
    try {
        var auth = getAuthIdByPlayer(player);
        
        // 1. Sprawdzamy czy gracz ma wybrany aktywny kolor
        if (coinStore.activeColor && coinStore.activeColor[auth]) {
            var activeVal = coinStore.activeColor[auth];
            var userColors = coinStore.ownedColors[auth] || [];
            
            // 2. Szukamy tego koloru w jego ekwipunku, Å¼eby sprawdziÄ‡ czy nie wygasÅ‚
            var validColor = userColors.find(c => c.value === activeVal);
            
            if (validColor) {
                if (validColor.expires > Date.now()) {
                    // Kolor jest waÅ¼ny -> ustawiamy go
                    chatColor = validColor.value;
                } else {
                    // Kolor wygasÅ‚ -> usuwamy go z aktywnych
                    delete coinStore.activeColor[auth];
                    saveCoinStore();
                    room.sendAnnouncement(`âŒ TwÃ³j wybrany kolor wygasÅ‚! Wybierz inny w !kolory lub kup w !sklep.`, player.id, infoColor, 'small', HaxNotification.CHAT);
                }
            } else {
                // MiaÅ‚ ustawiony aktywny, ale nie ma go w ekwipunku (np. bÅ‚Ä…d danych) -> czyÅ›cimy
                delete coinStore.activeColor[auth];
                saveCoinStore();
            }
        }
    } catch (e) {}
    // ------------------------
    try {
        recipients = room.getPlayerList();
    } catch (_) {
        recipients = [];
    }
    var deliveredToSender = false;
    for (let recipient of recipients) {
        if (!recipient) continue;
        if (recipient.id !== player.id && recipientIgnoresSender(recipient, player.name)) continue;
        room.sendAnnouncement(chatLine, recipient.id, chatColor, 'normal', HaxNotification.CHAT);
        if (recipient.id === player.id) deliveredToSender = true;
    }
    if (!deliveredToSender) {
        room.sendAnnouncement(chatLine, player.id, chatColor, 'normal', HaxNotification.CHAT);
    }
    return false;
};

room.onPlayerActivity = function (player) {
    if (gameState !== State.STOP) {
        let pComp = getPlayerComp(player);
        if (pComp != null) pComp.inactivityTicks = 0;
    }
};

room.onPlayerBallKick = function (player) {
    if (playSituation != Situation.GOAL) {
        var ballPosition = room.getBallPosition();
        if (game.touchArray.length == 0 || player.id != game.touchArray[game.touchArray.length - 1].player.id) {
            if (playSituation == Situation.KICKOFF) playSituation = Situation.PLAY;
            lastTeamTouched = player.team;
            game.touchArray.push(
                new BallTouch(
                    player,
                    game.scores.time,
                    getGoalGame(),
                    ballPosition
                )
            );
            lastTouches[0] = checkGoalKickTouch(
                game.touchArray,
                game.touchArray.length - 1,
                getGoalGame()
            );
            lastTouches[1] = checkGoalKickTouch(
                game.touchArray,
                game.touchArray.length - 2,
                getGoalGame()
            );
        }
    }
};

/* GAME MANAGEMENT */

room.onGameStart = function (byPlayer) {
    clearTimeout(startTimeout);
    if (byPlayer != null) clearTimeout(stopTimeout);
    game = new Game();
    possession = [0, 0];
    actionZoneHalf = [0, 0];
    gameState = State.PLAY;
    endGameVariable = false;
    goldenGoal = false;
    playSituation = Situation.KICKOFF;
    lastTouches = Array(2).fill(null);
    lastTeamTouched = Team.SPECTATORS;
    teamRedStats = [];
teamBlueStats = [];
    
    // ZMIANA: Rejestrujemy graczy do statystyk, jeÅ›li w obu druÅ¼ynach jest chociaÅ¼ 1 osoba
    if (teamRed.length > 0 && teamBlue.length > 0) {
        for (let p of teamRed) teamRedStats.push(p);
        for (let p of teamBlue) teamBlueStats.push(p);
    }
    
    calculateStadiumVariables();
    setTimeout(refreshDiscIndexes, 50);
};

room.onGameStop = function (byPlayer) {
    clearTimeout(stopTimeout);
    clearTimeout(unpauseTimeout);
    if (byPlayer != null) clearTimeout(startTimeout);
    game.rec = room.stopRecording();
    if (
        !cancelGameVariable && game.playerComp[0].length + game.playerComp[1].length > 0 &&
        (
            (game.scores.timeLimit != 0 &&
                ((game.scores.time >= 0.5 * game.scores.timeLimit &&
                    game.scores.time < 0.75 * game.scores.timeLimit &&
                    game.scores.red != game.scores.blue) ||
                    game.scores.time >= 0.75 * game.scores.timeLimit)
            ) ||
            endGameVariable
        )
    ) {
        fetchSummaryEmbed(game);
        if (fetchRecordingVariable) {
            setTimeout((gameEnd) => { fetchRecording(gameEnd); }, 500, game);
        }
    }
    cancelGameVariable = false;
    gameState = State.STOP;
    playSituation = Situation.STOP;
    updateTeams();
    handlePlayersStop(byPlayer);
    handleActivityStop();
    resetBallDiscIndex();
};

room.onGamePause = function (byPlayer) {
    if (mentionPlayersUnpause && gameState == State.PAUSE) {
        const pauseMsg = byPlayer != null
            ? `Gra zatrzymana przez ${byPlayer.name}!`
            : `Gra zatrzymana!`;
        room.sendAnnouncement(
            pauseMsg,
            null,
            defaultColor,
            'bold',
            HaxNotification.NONE
        );
    }
    clearTimeout(unpauseTimeout);
    gameState = State.PAUSE;
};

room.onGameUnpause = function (byPlayer) {
    unpauseTimeout = setTimeout(() => {
        gameState = State.PLAY;
    }, 2000);
    if (mentionPlayersUnpause) {
        const unpauseMsg = byPlayer != null
            ? `Gra wznowiona przez ${byPlayer.name}!`
            : `Gra wznowiona!`;
        room.sendAnnouncement(
            unpauseMsg,
            null,
            defaultColor,
            'small',
            HaxNotification.NONE
        );
    }
    if (
        (teamRed.length == teamSize && teamBlue.length == teamSize && chooseMode) ||
        (teamRed.length == teamBlue.length && teamSpec.length < 2 && chooseMode)
    ) {
        deactivateChooseMode();
    }
};

room.onTeamGoal = function (team) {
    const scores = room.getScores();
    game.scores = scores;
    playSituation = Situation.GOAL;
    ballSpeed = getBallSpeed();
    var goalString = getGoalString(team);
    for (let player of teamRed) {
        var playerComp = getPlayerComp(player);
        if (!playerComp) continue;
        if (team == Team.RED) playerComp.goalsScoredTeam++;
        else playerComp.goalsConcededTeam++;
    }
    for (let player of teamBlue) {
        var playerComp = getPlayerComp(player);
        if (!playerComp) continue;
        if (team == Team.BLUE) playerComp.goalsScoredTeam++;
        else playerComp.goalsConcededTeam++;
    }
    room.sendAnnouncement(
        goalString,
        null,
        team == Team.RED ? redColor : blueColor,
        null,
        HaxNotification.CHAT
    );
    if (roomWebhook != '') {
        safeFetch(roomWebhook, {
            method: 'POST',
            body: JSON.stringify({
                                content: `[${getDate()}] ${goalString}`,
                username: roomName,
            }),
            headers: {
                'Content-Type': 'application/json',
            },
        });
    }
    if ((scores.scoreLimit != 0 && (scores.red == scores.scoreLimit || scores.blue == scores.scoreLimit)) || goldenGoal) {
        endGame(team);
        goldenGoal = false;
        stopTimeout = setTimeout(() => {
            room.stopGame();
        }, 1000);
    }
};

room.onPositionsReset = function () {
    lastTouches = Array(2).fill(null);
    lastTeamTouched = Team.SPECTATORS;
    playSituation = Situation.KICKOFF;
};

/* MISCELLANEOUS */

room.onRoomLink = function (url) {
    console.log(`${url}\nmasterPassword : ${masterPassword}`);
    if (roomWebhook != '') {
        safeFetch(roomWebhook, {
            method: 'POST',
            body: JSON.stringify({
                                content: `[${getDate()}] LINK ${url}\nmasterPassword : ${masterPassword}`,
                username: roomName,
            }),
            headers: {
                'Content-Type': 'application/json',
            },
        });
    }
};

room.onPlayerAdminChange = function (changedPlayer, byPlayer) {
    updateTeams();
    if (!changedPlayer.admin && getRole(changedPlayer) >= Role.ADMIN_TEMP) {
        room.setPlayerAdmin(changedPlayer.id, true);
        return;
    }
    updateAdmins(byPlayer != null && !changedPlayer.admin && changedPlayer.id == byPlayer.id ? changedPlayer.id : 0);
};

room.onKickRateLimitSet = function (min, rate, burst, byPlayer) {
    if (byPlayer != null) {
        room.sendAnnouncement(
            `It is not allowed to change the kickrate limit. It must stay at "6-0-0".`,
            player.id,
            errorColor,
            'bold',
            HaxNotification.CHAT
        );
        room.setKickRateLimit(6, 0, 0);
    }
};

room.onStadiumChange = function (newStadiumName, byPlayer) {
    if (byPlayer !== null) {
        if (getRole(byPlayer) < Role.MASTER && currentStadium != 'other') {
            room.sendAnnouncement(
                `Nie mozna rÄ™cznie zmieniaÄ‡ mapek bo sie serwer krzaczy! Tylko komendy:( `,
                byPlayer.id,
                errorColor,
                'bold',
                HaxNotification.CHAT
            );
            stadiumCommand(emptyPlayer, `!${currentStadium}`);
        } else {
            room.sendAnnouncement(
                `Mapka zmieniona, ale gdy skoÅ„czysz zabawÄ™ z tÄ… mapkÄ…, proszÄ™, przywrÃ³c komendami wÅ‚asciwÄ… mapkÄ™.`,
                byPlayer.id,
                infoColor,
                'bold',
                HaxNotification.CHAT
            );
            currentStadium = 'other';
        }
    }
    checkStadiumVariable = true;
    resetBallDiscIndex();
    setTimeout(refreshDiscIndexes, 50);
    scheduleIndicatorDiscovery();
};

// Globalny licznik klatek do optymalizacji
var tickCounter = 0;

room.onGameTick = function () {
    checkTime();
    getLastTouchOfTheBall();
    getGameStats();
    
    // --- OPTYMALIZACJA: Aktualizacja kulek co 4 klatki (15 FPS zamiast 60 FPS) ---
    tickCounter++;
    if (tickCounter % 4 === 0) {
        updateIndicatorDiscs();
    }
    // -----------------------------------------------------------------------------

    handleActivity();
    monitorAFKSet();
};

/* =========================
   ELO 3v3 â€” LEAN IMPLEMENTATION + AFK handling (per user spec)
   - R0 = 1000
   - K = 40 for first 20 games per user, else 24
   - Start buffer: 25s
   - Draws: standard ELO (weaker gains, stronger loses)
   - Leave after 25s: leaver gets -30 ELO; if match ends as walkover due to this leave,
     then leaver's TEAM (excluding the leaver) gets a WIN, opponent gets a LOSS, leaver gets only -30
   - Matches < 25s:
     * If ended naturally: count normally.
     * If ended as walkover: ignore (no ELO changes, no penalties).
   - Only players present at the end of the match are considered for ELO updates (except special walkover rule).
   - No time weighting.
   - "!afk" during an active match is treated as a leave-equivalent with the same rules.
   ========================= */
(function(){
  if (typeof room === "undefined" || !room) { return; }

  const ELO_R0 = 1000;
  const ELO_K_PROV = 64;
  const ELO_K_NORM = 32;
  const ELO_PROV_GAMES = 12;
  const START_BUFFER_MS = 25_000;
  const LEAVE_PENALTY = 30;
  const ELO_RESET_COOLDOWN_MS = 30 * 24 * 60 * 60 * 1000;

  const ELO_STORAGE_KEY = "__eloStore";

  function makeEmptyEloStore(){
    return {
      ratings: Object.create(null),
      games: Object.create(null),
      names: Object.create(null),
      resets: Object.create(null)
    };
  }

  function reviveEloStore(rawObj){
    const store = makeEmptyEloStore();
    if (!rawObj || typeof rawObj !== "object") return store;

    if (rawObj.ratings && typeof rawObj.ratings === "object"){
      for (const [key, value] of Object.entries(rawObj.ratings)){
        if (value != null) store.ratings[key] = Number(value);
      }
    }
    if (rawObj.games && typeof rawObj.games === "object"){
      for (const [key, value] of Object.entries(rawObj.games)){
        if (value != null) store.games[key] = Number(value);
      }
    }
    if (rawObj.names && typeof rawObj.names === "object"){
      for (const [key, value] of Object.entries(rawObj.names)){
        if (typeof value === "string") store.names[key] = value;
      }
    }
    if (rawObj.resets && typeof rawObj.resets === "object"){
      for (const [key, value] of Object.entries(rawObj.resets)){
        const numeric = Number(value);
        if (Number.isFinite(numeric)) store.resets[key] = numeric;
      }
    }
    return store;
  }

  function loadEloStore(){
    try{
      const raw = localStorage.getItem(ELO_STORAGE_KEY);
      if (!raw) return null;
      return reviveEloStore(JSON.parse(raw));
    }catch(_){
      return null;
    }
  }

  const persistedStore = loadEloStore();
  if (!globalThis.__eloStore){
    globalThis.__eloStore = persistedStore || makeEmptyEloStore();
  } else if (persistedStore){
    // Merge persisted data into existing store (keep live references).
    for (const [key, value] of Object.entries(persistedStore.ratings)){
      globalThis.__eloStore.ratings[key] = value;
    }
    for (const [key, value] of Object.entries(persistedStore.games)){
      globalThis.__eloStore.games[key] = value;
    }
    for (const [key, value] of Object.entries(persistedStore.names)){
      globalThis.__eloStore.names[key] = value;
    }
    for (const [key, value] of Object.entries(persistedStore.resets || {})){
      globalThis.__eloStore.resets[key] = value;
    }
  }

  const elo = globalThis.__eloStore;
  if (!elo.ratings) elo.ratings = Object.create(null);
  if (!elo.games) elo.games = Object.create(null);
  if (!elo.names) elo.names = Object.create(null);
  if (!elo.resets) elo.resets = Object.create(null);
  globalThis.eloStore = elo;

function saveEloStore(){
    // Zamiast zapisu, ustawiamy flagÄ™ globalnÄ….
    globalThis.eloStoreDirty = true;
  }

  // Match state
  const state = globalThis.__eloState || (globalThis.__eloState = {
    active: false,
    kickoffAt: 0,
    score: { red: 0, blue: 0 },
    settled: false,
    ranked: false,
    walkoverResolved: false
  });
  if (typeof state.ranked !== "boolean") state.ranked = false;
  if (typeof state.walkoverResolved !== "boolean") state.walkoverResolved = false;
  // track who triggered potential walkover (leave/afk) to resolve on onGameStop if needed
  const pendingWalkover = globalThis.__eloPendingWalkover || (globalThis.__eloPendingWalkover = {
    authId: null,
    teamId: 0,
    ts: 0
  });
  // Track last known team per authId (to detect transitions 1/2 -> 0)
  const lastTeam = globalThis.__eloLastTeam || (globalThis.__eloLastTeam = Object.create(null));
  // Track who already got -30 this match to avoid double penalties (AFK -> leave)
  const penalizedThisMatch = globalThis.__eloPenalizedThisMatch || (globalThis.__eloPenalizedThisMatch = new Set());
  const joinedWhileTrailing = globalThis.__eloJoinedTrailing || (globalThis.__eloJoinedTrailing = Object.create(null));
  const autoAfkKicked = globalThis.__eloAutoAfkKicked || (globalThis.__eloAutoAfkKicked = new Set());

  // Track AFK intents (just utility space)
  const afkIntent = globalThis.__eloAfkIntent || (globalThis.__eloAfkIntent = Object.create(null));

  // ---- helpers ----
  function getAuthIdByPlayer(player){
    if (!player){
      return "?";
    }
    try{
      if (typeof authArray !== "undefined" && authArray[player.id]){
        const arrEntry = authArray[player.id];
        if (Array.isArray(arrEntry) && arrEntry.length > 0){
          return arrEntry[0];
        }
      }
    }catch(_){}
    if (player.auth){
      return player.auth;
    }
    if (player.conn){
      return player.conn;
    }
    return String(player.id ?? "?");
  }
  function ensureProfile(authId, name){
    let changed = false;
    if (!(authId in elo.ratings)){
      elo.ratings[authId] = ELO_R0;
      changed = true;
    }
    if (!(authId in elo.games)){
      elo.games[authId] = 0;
      changed = true;
    }
    if (name && elo.names[authId] !== name){
      elo.names[authId] = name;
      changed = true;
    }
    if (changed) saveEloStore();
  }
  function kFactor(authId){
    const g = elo.games[authId] || 0;
    return g < ELO_PROV_GAMES ? ELO_K_PROV : ELO_K_NORM;
  }
  function getTeamPlayers(teamId){
    try{
      return room.getPlayerList().filter(p => p.team === teamId);
    }catch(_){ return []; }
  }
  function isThreeVThreeNow(){
    try{
      const rc = room.getPlayerList().filter(p=>p.team===Team.RED).length;
      const bc = room.getPlayerList().filter(p=>p.team===Team.BLUE).length;
      return rc===teamSize && bc===teamSize;
    }catch(_){ return false; }
  }
  function spectatorCount(excludeAuthId){
    try{
      const specs = getTeamPlayers(Team.SPECTATORS);
      if (!Array.isArray(specs)) return 0;
      let count = 0;
      for (const spec of specs){
        try{
          if (excludeAuthId != null && getAuthIdByPlayer(spec) === excludeAuthId) continue;
        }catch(_){}
        count += 1;
      }
      return count;
    }catch(_){ return 0; }
  }
  function hasSpectatorAvailable(excludeAuthId){
    return spectatorCount(excludeAuthId) > 0;
  }
  function shouldDeclareWalkover(teamId, excludeAuthId){
    // Ragequit walkover detection disabled.
    return false;
  }
  function isLateRageQuitWindow(teamId){
    if (teamId !== Team.RED && teamId !== Team.BLUE) return false;
    try{
      const scores = room.getScores && room.getScores();
      if (!scores || typeof scores !== "object") return false;
      const timeNow = typeof scores.time === "number" ? scores.time : null;
      const timeLimit = (typeof game !== "undefined" && game && game.scores && typeof game.scores.timeLimit === "number")
        ? game.scores.timeLimit
        : null;
      if (timeLimit == null || !Number.isFinite(timeLimit) || timeLimit <= 0) return false;
      if (timeNow == null || timeNow < (5/6) * timeLimit) return false;
      const red = typeof scores.red === "number" ? scores.red : state.score.red;
      const blue = typeof scores.blue === "number" ? scores.blue : state.score.blue;
      if (teamId === Team.RED){
        return (blue - red) >= 2;
      }
      if (teamId === Team.BLUE){
        return (red - blue) >= 2;
      }
    }catch(_){}
    return false;
  }
  function shouldPenalizeLeave(authId, teamId, elapsedOverride, forcePenalty){
    if (!state.active || !state.ranked) return false;
    if (teamId !== Team.RED && teamId !== Team.BLUE) return false;
    const elapsed = (typeof elapsedOverride === "number") ? elapsedOverride : elapsedMsSinceKickoff();
    if (!forcePenalty && elapsed < START_BUFFER_MS) return false;
    return true;
  }
  function resetJoinedTrailing(){
    for (const key in joinedWhileTrailing){
      if (Object.prototype.hasOwnProperty.call(joinedWhileTrailing, key)){
        delete joinedWhileTrailing[key];
      }
    }
  }
  function markJoinedWhileTrailing(authId, teamId){
    if (!authId) return;
    if (teamId !== Team.RED && teamId !== Team.BLUE) return;
    if (!state.active) return;
    try{
      let scores = room.getScores && room.getScores();
      let redScore = null, blueScore = null;
      if (scores && typeof scores.red === "number" && typeof scores.blue === "number"){
        redScore = scores.red;
        blueScore = scores.blue;
      } else {
        redScore = state?.score?.red;
        blueScore = state?.score?.blue;
      }
      if (!Number.isFinite(redScore) || !Number.isFinite(blueScore)) return;
      const trailing = teamId === Team.RED ? (redScore < blueScore) : (blueScore < redScore);
      if (trailing){
        joinedWhileTrailing[authId] = true;
      }
    }catch(_){}
  }
  function inferActiveTeamFromLineup(authId){
    if (!authId) return Team.SPECTATORS;
    try{
      if (typeof game === "undefined" || !game || !Array.isArray(game.playerComp)) return Team.SPECTATORS;
      for (let t=0; t<2; t++){
        const arr = game.playerComp[t];
        if (!Array.isArray(arr)) continue;
        for (const comp of arr){
          if (!comp || comp.auth !== authId) continue;
          const entries = Array.isArray(comp.timeEntry) ? comp.timeEntry.length : 0;
          const exits = Array.isArray(comp.timeExit) ? comp.timeExit.length : 0;
          if (entries > exits){
            return t === 0 ? Team.RED : Team.BLUE;
          }
        }
      }
    }catch(_){}
    return Team.SPECTATORS;
  }
  function resolvePenaltyName(authId, fallbackName, reason){
    if (typeof fallbackName === "string" && fallbackName.trim().length > 0){
      return fallbackName.trim();
    }
    if (elo.names && typeof elo.names[authId] === "string" && elo.names[authId].trim().length > 0){
      return elo.names[authId].trim();
    }
    if (reason === "LEAVE") return "nieznany gracz";
    return "gracz";
  }
  function attemptLeavePenalty(authId, teamId, reason, fallbackName, forcePenalty){
    if (!authId) return false;
    if (penalizedThisMatch.has(authId)) return false;
    const elapsed = elapsedMsSinceKickoff();
    const should = shouldPenalizeLeave(authId, teamId, elapsed, !!forcePenalty);
    if (!should) return false;
    ensureProfile(authId, fallbackName);
    if (!Number.isFinite(elo.ratings[authId])) elo.ratings[authId] = 0;
    elo.ratings[authId] = Math.max(0, elo.ratings[authId] - LEAVE_PENALTY);
    saveEloStore();
    penalizedThisMatch.add(authId);
    const penaltyName = resolvePenaltyName(authId, fallbackName, reason);
    const msg = (reason === "LEAVE")
      ? `âŒ Kara za wyjscie po 25s dla ${penaltyName}: -${LEAVE_PENALTY} ELO`
      : `âŒ Kara za AFK po 25s dla ${penaltyName}: -${LEAVE_PENALTY} ELO`;
    try { room.sendAnnouncement(msg, null, 0xd50350, 'small', HaxNotification.CHAT); } catch(_){ try { room.sendAnnouncement(msg, null); } catch(__){} }
    return true;
  }
  function handleResetCommand(player, message){
    const auth = getAuthIdByPlayer(player);
    if (!auth){
      room.sendAnnouncement("Ta komenda wymaga zalogowania przez auth.", player.id, errorColor, 'bold', HaxNotification.CHAT);
      return false;
    }
    ensureProfile(auth, player?.name);
    const now = Date.now();
    const lastRaw = elo.resets && elo.resets[auth];
    const lastTs = Number(lastRaw);
    if (Number.isFinite(lastTs) && now - lastTs < ELO_RESET_COOLDOWN_MS){
      const remainingMs = (lastTs + ELO_RESET_COOLDOWN_MS) - now;
      const dayMs = 24 * 60 * 60 * 1000;
      const hourMs = 60 * 60 * 1000;
      const minuteMs = 60 * 1000;
      let remaining = remainingMs;
      const parts = [];
      const wholeDays = Math.floor(remaining / dayMs);
      if (wholeDays > 0){
        parts.push(`${wholeDays}d`);
        remaining -= wholeDays * dayMs;
      }
      const wholeHours = Math.floor(remaining / hourMs);
      if (wholeHours > 0 && parts.length < 2){
        parts.push(`${wholeHours}h`);
        remaining -= wholeHours * hourMs;
      }
      const wholeMinutes = Math.ceil(remaining / minuteMs);
      if (parts.length === 0 && wholeMinutes > 0){
        parts.push(`${wholeMinutes}m`);
      }
      const formatted = parts.length > 0 ? parts.join(" ") : "kilka sekund";
      room.sendAnnouncement(`âŒ› Komendy !resetelo moÅ¼na uÅ¼yÄ‡ raz na 30 dni. NastÄ™pny reset dostÄ™pny za ${formatted}.`, player.id, warningColor, 'bold', HaxNotification.CHAT);
      return false;
    }
    const prevRatingRaw = Number(elo.ratings[auth]);
    const prevRating = Number.isFinite(prevRatingRaw) ? prevRatingRaw : null;
    const resetValue = ELO_R0;
    elo.ratings[auth] = resetValue;
    elo.resets[auth] = now;
    try { saveEloStore(); } catch(_){}
    const prevSegment = prevRating != null ? ` (wczeÅ›niej ${prevRating.toFixed(1)})` : "";
    room.sendAnnouncement(`âœ… Twoje ELO zostaÅ‚o zresetowane do ${resetValue}${prevSegment}. Komenda ponownie dostÄ™pna bÄ™dzie za 30 dni.`, player.id, successColor, 'bold', HaxNotification.CHAT);
    return false;
  }
  function teamAuthsAtEnd(teamId){
    return getTeamPlayers(teamId).map(p => getAuthIdByPlayer(p));
  }
  function teamAvgRating(authIds){
    if (authIds.length === 0) return ELO_R0;
    let sum = 0;
    for (const a of authIds){
      ensureProfile(a);
      sum += elo.ratings[a];
    }
    return sum / authIds.length;
  }
  function expectedScore(rA, rB){
    return 1 / (1 + Math.pow(10, (rB - rA)/400));
  }
  function announcePreMatchOdds(){
    try{
      const redPlayers = getTeamPlayers(Team.RED);
      const bluePlayers = getTeamPlayers(Team.BLUE);
      if (!Array.isArray(redPlayers) || !Array.isArray(bluePlayers)) return;
      if (redPlayers.length === 0 || bluePlayers.length === 0) return;

      const redAuths = [];
      for (const p of redPlayers){
        const aid = getAuthIdByPlayer(p);
        if (!aid) continue;
        ensureProfile(aid, p?.name);
        redAuths.push(aid);
      }

      const blueAuths = [];
      for (const p of bluePlayers){
        const aid = getAuthIdByPlayer(p);
        if (!aid) continue;
        ensureProfile(aid, p?.name);
        blueAuths.push(aid);
      }

      if (redAuths.length === 0 || blueAuths.length === 0) return;

      const avgRed = teamAvgRating(redAuths);
      const avgBlue = teamAvgRating(blueAuths);
      const expRed = expectedScore(avgRed, avgBlue);
      if (!Number.isFinite(expRed)) return;

      const pctRed = Math.round(expRed * 100);
      const pctBlue = Math.max(0, Math.min(100, 100 - pctRed));
      const msg = `Szanse: ðŸ”´${pctRed}% ðŸ”µ${pctBlue}%`;
      room.sendAnnouncement(msg, null, announcementColor, 'small', HaxNotification.CHAT);
    }catch(_){}
  }
  function elapsedMsSinceKickoff(){
    try{
      const scores = room.getScores && room.getScores();
      if (scores && typeof scores.time === "number") return Math.floor(scores.time * 1000);
    }catch(_){}
    if (state.active){
      const now = Date.now();
      return now - (state.kickoffAt || now);
    }
    return 0;
  }

  function updateEloForTeams(params){
  const exclude = params.excludeAuths || new Set();
  const A = params.teamAAuths.filter(a => !exclude.has(a));
  const B = params.teamBAuths.filter(a => !exclude.has(a));
  const rA = teamAvgRating(A);
  const rB = teamAvgRating(B);
  const eA = expectedScore(rA, rB);
  const eB = 1 - eA;
  const sA = params.scoreA;
  const sB = params.scoreB;
    const displayScore = (typeof params.displayScore === 'string' && params.displayScore.length > 0)
      ? params.displayScore
      : null;

    const avgK = (arr) => {
      if (arr.length === 0) return 0;
      let sum = 0;
      for (const id of arr){
        sum += kFactor(id);
      }
      return sum / arr.length;
    };
    const deltaTeamA = avgK(A) * (sA - eA);
    const deltaTeamB = avgK(B) * (sB - eB);

  const oldElo = Object.create(null);
  const remember = (arr) => {
    for (const a of arr){
      ensureProfile(a);
      oldElo[a] = Number(elo.ratings[a] ?? ELO_R0);
    }
  };
    remember(A);
    remember(B);

  // --- zaktualizuj ELO i liczbÄ™ gier (jak dotychczas) ---
  for (const a of A){
    ensureProfile(a);
      elo.ratings[a] += deltaTeamA;
    elo.games[a] += 1;
  }
  for (const b of B){
    ensureProfile(b);
      elo.ratings[b] += deltaTeamB;
    elo.games[b] += 1;
  }
  saveEloStore();

    const Aset = new Set(A);
    const Bset = new Set(B);
    const winnerSide = (sA === sB) ? 'draw' : (sA > sB ? 'A' : 'B');

    const findPlayerIdByAuth = (authId) => {
    try{
      const list = room.getPlayerList();
      const p = list.find(pl => {
        try { return getAuthIdByPlayer(pl) === authId; } catch(_) { return false; }
      });
      return p ? p.id : null;
      }catch(_){
        return null;
  }
    };

    const outcomeLabelForAuth = (authId) => {
      if (winnerSide === 'draw') return 'ZremisowaÅ‚eÅ›';
  const inA = Aset.has(authId);
  const inB = Bset.has(authId);
  const won = (winnerSide === "A" && inA) || (winnerSide === "B" && inB);
  return won ? "WygraÅ‚eÅ›" : "PrzegraÅ‚eÅ›";
}
    const scoreText = displayScore ? ` ${displayScore}` : '';

const notify = (authId) => {
  const prev  = Number(oldElo[authId] ?? ELO_R0);
  const now   = Number(elo.ratings[authId] ?? prev);
  const delta = now - prev;
  const sign  = delta > 0 ? '+' : '';
  const label = outcomeLabelForAuth(authId);
  const formattedDelta = delta >= 0 ? `+${delta.toFixed(1)}` : delta.toFixed(1);
  const msgParts = [label];
  if (scoreText) {
    msgParts.push(scoreText.trim());
  }
  msgParts.push(`Nowe ELO: ${now.toFixed(1)} (${formattedDelta})`);
  const msg = msgParts.join(' | ');
  const col = rankColor(classLabel(now));
  const pid = findPlayerIdByAuth(authId);

  // 1. WyÅ›wietlenie info o zmianie ELO
  if (pid != null){
    try { room.sendAnnouncement(msg, pid, col, 'small', HaxNotification.CHAT); }
    catch { room.sendAnnouncement(msg, pid); }
  }

  // 2. OSTRZEÅ»ENIE (800 - 849 ELO)
  if (now >= 800 && now < 850 && pid != null) {
      setTimeout(() => {
          room.sendAnnouncement(`âš ï¸ OSTRZEÅ»ENIE! Twoje ELO (${now.toFixed(0)}) jest w strefie zagroÅ¼enia (GÃ³wienko).`, pid, warningColor, 'bold', HaxNotification.CHAT);
          room.sendAnnouncement(`Spadek poniÅ¼ej 800 ELO = BAN 48h + Reset!`, pid, errorColor, 'bold', HaxNotification.MENTION);
      }, 1500);
  }

  // 3. BAN ZA ELO (< 800)
  if (now < 800) {
      // Reset ELO do 1000
      elo.ratings[authId] = 1000;
      saveEloStore();

      // Szukamy gracza (online lub nazwa z bazy)
      const targetPlayer = pid ? room.getPlayer(pid) : null;
      const targetName = targetPlayer ? targetPlayer.name : (elo.names[authId] || "Gracz");

      // OgÅ‚oszenie dla wszystkich
      room.sendAnnouncement(`ðŸ“‰ ${targetName} spadÅ‚ poniÅ¼ej 800 ELO! Kara: Ban na 48h i reset rankingu.`, null, errorColor, 'bold', HaxNotification.CHAT);

      // NaÅ‚oÅ¼enie Bana (korzystamy z funkcji globalnych)
      if (typeof getBanDurationInfo === 'function' && typeof registerTimedBan === 'function') {
          const durInfo = getBanDurationInfo('48h');
          if (durInfo) {
              // "System ELO" jako admin banujÄ…cy
              registerTimedBan(targetPlayer, {name: "ðŸ“‰ System ELO"}, durInfo, "Spadek poniÅ¼ej 800 pkt", {
                  targetAuth: authId,
                  targetName: targetName
              });
          }
      }

      // Wyrzucenie z pokoju (jeÅ›li online)
      if (targetPlayer) {
          room.kickPlayer(targetPlayer.id, "SpadÅ‚eÅ› poniÅ¼ej 800 ELO. Wracaj za 2 dni z czystÄ… kartÄ…!", false);
      }
  }
};

  for (const a of A) notify(a);
  for (const b of B) notify(b);
}

function classLabel(r){
  r = Number(r);
  if (!isFinite(r)) r = 1000;
  if (r <= 850)  return "GÃ³wienko";
  if (r <= 950)  return "Å»Ã³Å‚todziÃ³b";
  if (r <= 1050) return "PoczÄ…tkujÄ…cy";
  if (r <= 1199) return "Gracz";
  if (r <= 1299) return "Kox";
  if (r <= 1399) return "Mistrz";
  if (r <= 1550) return "Legenda";
  return "NieÅ›miertelny";
}

  // ---- Rank â†’ Avatar mapping (emoji demo) ----
const RANK_AVATARS = {
  "GÃ³wienko":      "ðŸ’©",
  "Å»Ã³Å‚todziÃ³b":    "ðŸ£",
  "PoczÄ…tkujÄ…cy":  "âšª",
  "Gracz":         "ðŸ¥‰",
  "Kox":           "ðŸ¥ˆ",
  "Mistrz":        "ðŸ¥‡",
  "Legenda":       "ðŸ‘‘",
  "NieÅ›miertelny": "ðŸ”¥"
};


  // Emoji for text (same mapping as avatars)
  function rankEmoji(label){
    if (label === undefined || label === null) return "ðŸ˜¶";
    return RANK_AVATARS.hasOwnProperty(label) ? RANK_AVATARS[label] : "ðŸ˜¶";
  }
  // Pretty chat color for a given rank label
function rankColor(label){
  switch(label){
    case "GÃ³wienko":      return 0x8B4513; // brÄ…z
    case "Å»Ã³Å‚todziÃ³b":    return 0xffff99; // Å¼Ã³Å‚ty pastel
    case "PoczÄ…tkujÄ…cy":  return 0xD0D0D0; // biaÅ‚y
    case "Gracz":         return 0xFFCB62; // niebieskawy
    case "Kox":           return 0xFFFFFF; // zÅ‚oty
    case "Mistrz":        return 0xFFD700; // zieleÅ„
    case "Legenda":       return 0x7d3cff; // fiolet
    case "NieÅ›miertelny": return 0xff4500; // pomaraÅ„cz-czerwony
    default:              return infoColor;
  }
}



// === Unified stats printer ===
function formatWinrate(wins, games){
  if (!games) return "0.0%";
  return (Math.round((wins/games)*1000)/10).toFixed(1) + "%";
}
function formatPlaytime(minutes){
  minutes = Math.max(0, Math.floor(Number(minutes)||0));
  const h = Math.floor(minutes/60), m = minutes%60;
  return (h>0? `${h}h`:"") + `${m}m`;
}
function printUnifiedStatsLine(targetPlayer){
  try{
    const auth = getAuthIdByPlayer(targetPlayer);
    ensureProfile(auth, targetPlayer?.name);

    // Klucz do storage: preferuj authArray[player.id][0] jeÅ›li jest, inaczej auth
    let key = auth;
    try{
      const storedAuth = getPlayerAuth(targetPlayer);
      if (storedAuth) {
        key = storedAuth;
      }
    }catch(_){}

    // Wczytaj staty bezpiecznie
    let st = new HaxStatistics(targetPlayer?.name || "");
    try{
      if (typeof localStorage !== "undefined" && localStorage.getItem) {
        const raw = localStorage.getItem(String(key));
        if (raw) {
          const data = JSON.parse(raw);
          if (data && typeof data === "object") Object.assign(st, data);
        }
      }
    }catch(_){/* ignoruj uszkodzone JSON */}

    // Pola
    const games   = Number(st.games)    || 0;
    const wins    = Number(st.wins)     || 0;
    const losses = Number(st.losses) || 0;
    const goals   = Number(st.goals)    || 0;
    const assists = Number(st.assists)  || 0;
    const cs      = Number(st.CS)       || 0;
    const og      = Number(st.ownGoals) || 0;

    // Winrate i czas
    const winrate = (games > 0) ? ( (wins * 100 / games).toFixed(1) + '%' ) : '0.0%';
    const pt      = (typeof getTimeStats === "function") ? getTimeStats(Number(st.playtime)||0)
                                                         : ( () => {
                                                              const mins = Math.floor((Number(st.playtime)||0)/60);
                                                              const h = Math.floor(mins/60), m = mins%60;
                                                              return (h>0? `${h}h` : '0h') + `${m}m`;
                                                            })();

    // ELO i ranga
    const eloVal = (elo && elo.ratings && elo.ratings[auth] != null) ? elo.ratings[auth] : baseElo;
    const lab = classLabel(eloVal);
    const nick = (elo && elo.names && elo.names[auth]) ? elo.names[auth] : (targetPlayer.name || auth);

    const line = `${nick}: Games: ${games}, Wins: ${wins}, Losses: ${losses}, Winrate: ${winrate}, ` +
                 `Playtime: ${pt}, Goals: ${goals}, Assists: ${assists}, CS: ${cs}, Own Goals: ${og} ` +
                 `ELO: ${Number(eloVal||baseElo).toFixed(1)}${lab ? ` | ${lab}` : ""}`;

    const col = rankColor(lab);
    return { line, col };
  }catch(e){
    return { line: "Nie udaÅ‚o siÄ™ wyÅ›wietliÄ‡ statystyk.", col: errorColor };
  }
}

function pickAvatarByRankLabel(label){
    if (!label && label !== "") return "";
    return RANK_AVATARS.hasOwnProperty(label) ? RANK_AVATARS[label] : "";
  }

  function applyRankAvatarsOnKickoff(){
    try{
      if (typeof room.setPlayerAvatar !== "function") return;
      const changed = new Set();
      const players = room.getPlayerList().filter(p => p.team===1 || p.team===2);
      for (const p of players){
        const aid = getAuthIdByPlayer(p);
        ensureProfile(aid, p?.name);
        const r = elo.ratings[aid];
        const lab = classLabel(r);
        const avatarId = pickAvatarByRankLabel(lab);
        if (avatarId){
          try{ room.setPlayerAvatar(p.id, avatarId); changed.add(p.id); }catch(_){}
        }
      }
      setTimeout(function(){
        if (typeof room.setPlayerAvatar !== "function") return;
        for (const id of changed){
          try{ room.setPlayerAvatar(id, null); }catch(_){
            try{ room.setPlayerAvatar(id, ""); }catch(__){}
          }
        }
      }, 12_000);
    }catch(_){}
  }

 function finalizeNaturalMatch(){
   // Only rank if the match ends as a true 3v3 (both teams exactly 3 players).
   if (!state.ranked) {
     return;
   }
   if (!isThreeVThreeNow()) {
     return;
   }
   const redAuths = teamAuthsAtEnd(1);
   const blueAuths = teamAuthsAtEnd(2);
  // UÅ¼yj finalnej tablicy wynikÃ³w z silnika, a lokalne liczniki tylko jako fallback.
  let scoresFinal = null;
  try { scoresFinal = room.getScores && room.getScores(); } catch(_){}
  const ra = (scoresFinal && typeof scoresFinal.red === "number")  ? scoresFinal.red  : state.score.red;
  const rb = (scoresFinal && typeof scoresFinal.blue === "number") ? scoresFinal.blue : state.score.blue;
  // Remis: S = 0.5 dla obu; inaczej klasycznie 1/0.
  let sRed = 0.5, sBlue = 0.5;
  if (ra > rb){ sRed = 1; sBlue = 0; }
  else if (ra < rb){ sRed = 0; sBlue = 1; }
  const exclude = new Set();
  if (sRed < sBlue){
    for (const auth of redAuths){
      if (joinedWhileTrailing[auth]) exclude.add(auth);
    }
  } else if (sBlue < sRed){
    for (const auth of blueAuths){
      if (joinedWhileTrailing[auth]) exclude.add(auth);
    }
  }
 
   updateEloForTeams({
     teamAAuths: redAuths,
     teamBAuths: blueAuths,
     scoreA: sRed,
     scoreB: sBlue,
      excludeAuths: exclude,
      displayScore: `${ra}:${rb}`
   });
 }


  function finalizeWalkoverDueToLeave(leaverAuth, leaverTeamId, options){
    // Walkover handling disabled; only reset pending state.
    pendingWalkover.authId = null;
    pendingWalkover.teamId = 0;
    pendingWalkover.ts = 0;
  }

  function scheduleWalkoverResolution(leaverAuth, leaverTeamId, options){
    // Nothing to resolve while ragequit handling is disabled.
    if (pendingWalkover.authId === leaverAuth){
      pendingWalkover.authId = null;
      pendingWalkover.teamId = 0;
      pendingWalkover.ts = 0;
    }
  }

  function forceImmediateWalkover(leaverAuth, leaverTeamId){
    scheduleWalkoverResolution(leaverAuth, leaverTeamId, { delayMs: 0, maxAttempts: 1, force: true });
  }

  function handleAfkTransition(authId, oldTeamId){
    // Called shortly after user's !afk is processed by existing handlers (so team likely = 0)
    try{
      const pl = room.getPlayerList().find(p => getAuthIdByPlayer(p) === authId);
      const nowTeam = pl ? pl.team : Team.SPECTATORS;
      const elapsed = elapsedMsSinceKickoff();
      if (nowTeam === Team.SPECTATORS){
        attemptLeavePenalty(authId, oldTeamId, "AFK", pl && pl.name ? pl.name : undefined, false);
      }
    }catch(_){}
    try{
      if (afkIntent && authId && afkIntent[authId]) delete afkIntent[authId];
    }catch(_){}
  }

  // ---- event wrapping ----
  const prev_onGameStart = room.onGameStart;
  room.onGameStart = function(byPlayer){
    try{
      penalizedThisMatch.clear();
      resetJoinedTrailing();
      // snapshot last team for all players at kickoff
      const pls = room.getPlayerList();
      for (const p of pls){
        const aid = getAuthIdByPlayer(p);
        lastTeam[aid] = p.team;
      }
    }catch(_){}

    try{
      state.active = true;
      state.kickoffAt = Date.now();
      state.score.red = 0;
      state.score.blue = 0;
      state.settled = false;
      state.walkoverResolved = false;
      try{
        const redCount = getTeamPlayers(Team.RED).length;
        const blueCount = getTeamPlayers(Team.BLUE).length;
        state.ranked = (redCount === teamSize && blueCount === teamSize);
      }catch(_){
        state.ranked = false;
      }
      pendingWalkover.authId = null;
      pendingWalkover.teamId = 0;
      pendingWalkover.ts = 0;
      announcePreMatchOdds();
    }catch(_){}
    if (typeof prev_onGameStart === "function") prev_onGameStart(byPlayer);
    try{ applyRankAvatarsOnKickoff(); }catch(_){}
    try{ setTimeout(refreshDiscIndexes, 50); }catch(_){ try{ refreshDiscIndexes(); }catch(__){} }

  };

  const prev_onTeamGoal = room.onTeamGoal;
  room.onTeamGoal = function(teamId){
    try{
      if (teamId === 1) state.score.red += 1;
      else if (teamId === 2) state.score.blue += 1;
    }catch(_){}
    if (typeof prev_onTeamGoal === "function") prev_onTeamGoal(teamId);
  };

  const prev_onGameStop = room.onGameStop;
  room.onGameStop = function(byPlayer){
    try{ penalizedThisMatch.clear(); }catch(_){}
    try{
      if (!state.settled){
        if (isThreeVThreeNow() && state.ranked){
          finalizeNaturalMatch();
          state.settled = true;
        }
      }
      pendingWalkover.authId = null;
      pendingWalkover.teamId = 0;
      pendingWalkover.ts = 0;
    }catch(_){}
    finally{
      state.active = false;
      state.ranked = false;
      try{ resetJoinedTrailing(); }catch(_){}
    }
    if (typeof prev_onGameStop === "function") prev_onGameStop(byPlayer);
    resetBallDiscIndex();
// DODAJ TO: WyÅ›lij ranking po meczu (jeÅ›li mecz byÅ‚ rankingowy)
    // Sprawdzamy czy mecz siÄ™ "odbyÅ‚" (nie byÅ‚ anulowany natychmiast)
    if (state.settled || (game.scores && game.scores.time > 10)) { 
        setTimeout(sendRankingToDiscord, 2000); // MaÅ‚e opÃ³Åºnienie, Å¼eby ELO zdÄ…Å¼yÅ‚o siÄ™ zapisaÄ‡
    }
    performDiskSave(); // Zapisz wszystko na dysk teraz, gdy gra stoi.
};
  const prev_onPlayerJoin = room.onPlayerJoin;
  room.onPlayerJoin = function(player){
    try{
      const aid2 = getAuthIdByPlayer(player);
      lastTeam[aid2] = player.team;
    }catch(_){}

    try{
      const a = getAuthIdByPlayer(player);
      ensureProfile(a, player?.name);
      if (a) {
        try { autoAfkKicked.delete(a); } catch (_){}
      }
      try { autoAfkKicked.delete(`id:${player.id}`); } catch (_){}
    }catch(_){}
    if (typeof prev_onPlayerJoin === "function") prev_onPlayerJoin(player);
  };

  const prev_onPlayerLeave = room.onPlayerLeave;
  room.onPlayerLeave = function(player){
    let lastTeamBefore = Team.SPECTATORS;
    let authLeave = null;
    try{
      authLeave = getAuthIdByPlayer(player);
      if (authLeave != null && authLeave in lastTeam && typeof lastTeam[authLeave] === "number"){
        lastTeamBefore = lastTeam[authLeave];
      } else if (typeof player?.team === "number"){
        lastTeamBefore = player.team;
      }
      if (authLeave != null){
        delete lastTeam[authLeave];
      }
    }catch(_){}

    let lastAuthUsed = null;
    const leftAsSpectator = player.team === Team.SPECTATORS;
    try{
      const a = authLeave != null ? authLeave : getAuthIdByPlayer(player);
      lastAuthUsed = a;
      const autoKey = a ? a : `id:${player.id}`;
      const skipPenalty = autoAfkKicked.has(autoKey);
      if (skipPenalty) autoAfkKicked.delete(autoKey);
      if (a) ensureProfile(a, player?.name);

      let teamForPenalty = (typeof lastTeamBefore === "number") ? lastTeamBefore : player.team;
      if (teamForPenalty !== Team.RED && teamForPenalty !== Team.BLUE){
        teamForPenalty = inferActiveTeamFromLineup(a);
      }
      if (!skipPenalty && !leftAsSpectator && (teamForPenalty === Team.RED || teamForPenalty === Team.BLUE)){
        attemptLeavePenalty(a, teamForPenalty, "LEAVE", player && player.name ? player.name : undefined, false);
      }
    }catch(_){}
    try{
      if (afkIntent && lastAuthUsed && afkIntent[lastAuthUsed]) delete afkIntent[lastAuthUsed];
    }catch(_){}
    if (typeof prev_onPlayerLeave === "function") prev_onPlayerLeave(player);
  };

  const prev_onPlayerTeamChange = room.onPlayerTeamChange;
  room.onPlayerTeamChange = function(player, byPlayer){
    try{
      const aid = getAuthIdByPlayer(player);
      ensureProfile(aid, player?.name);
      const newTeam = player.team;
      const oldTeam = (aid in lastTeam) ? lastTeam[aid] : Team.SPECTATORS;
      if ((newTeam === Team.RED || newTeam === Team.BLUE) && newTeam !== oldTeam){
        markJoinedWhileTrailing(aid, newTeam);
      }
         // Detect transition from playing (1/2) to SPECT (0) during active match
      if (state.active && state.ranked && (oldTeam === Team.RED || oldTeam === Team.BLUE) && newTeam === Team.SPECTATORS){
        const elapsed = elapsedMsSinceKickoff();
        if (elapsed >= START_BUFFER_MS){
          const penalize = shouldPenalizeLeave(aid, oldTeam, elapsed, false);
          if (penalize){
            attemptLeavePenalty(aid, oldTeam, "AFK", player && player.name ? player.name : undefined, false);
          }

        }
      }
      // update lastTeam after processing
      lastTeam[aid] = newTeam;
      if (afkIntent && afkIntent[aid]) delete afkIntent[aid];

      // Promote match to ranked once both sides field full teams (even if start was uneven)
      try {
        if (state.active && !state.settled && !state.walkoverResolved) {
          const redCountNow = getTeamPlayers(Team.RED).length;
          const blueCountNow = getTeamPlayers(Team.BLUE).length;
          if (!state.ranked && redCountNow === teamSize && blueCountNow === teamSize) {
            state.ranked = true;
          }
        }
      } catch (_) {}
    }catch(_){}
    if (typeof prev_onPlayerTeamChange === "function") prev_onPlayerTeamChange(player, byPlayer);
  };
  // ---- Chat commands (minimal) ----
  const prev_onPlayerChat = room.onPlayerChat;
  room.onPlayerChat = function(player, message){
    const msg = (message || "").trim();
    const lower = msg.toLowerCase();
    const originalTeamBeforeChat = player.team;
    const authBeforeChat = getAuthIdByPlayer(player);
    try{
              if (lower === "!elo"){
          const auth = getAuthIdByPlayer(player);
          ensureProfile(auth, player?.name);
          const r = elo.ratings[auth];
          const lab = classLabel(r);
          const games = elo.games[auth] || 0;
          let kNow = 0;
          try { kNow = kFactor(auth); } catch(_){}
          const line = `ELO: ${r.toFixed(1)}${lab?` | ${lab}`:""} | gry: ${games} | K=${kNow}`;
          room.sendAnnouncement(line, player.id, rankColor(lab), 'bold', HaxNotification.CHAT);
          return false;
                }
      
                  if (lower.startsWith("!ranking")){
        // Pagination: !ranking [page] | !ranking me
        const parts = msg.trim().split(/\s+/);
        const PAGE_SIZE = 10;
        const items = Object.entries(elo.ratings).sort((a,b)=>{
          const br = Number(b[1]);
          const ar = Number(a[1]);
          const bVal = Number.isFinite(br) ? br : baseElo;
          const aVal = Number.isFinite(ar) ? ar : baseElo;
          return bVal - aVal;
        });
        const total = items.length;
        if (total === 0){
          const emptyMsg = `Ranking jest jeszcze pusty - rozegraj mecz, aby siÄ™ pojawiÄ‡.`;
          try {
            room.sendAnnouncement(emptyMsg, player.id, infoColor, 'bold', HaxNotification.CHAT);
          } catch(_){
            try { room.sendAnnouncement(emptyMsg, player.id); } catch(__) {}
          }
          try {
            room.sendAnnouncement(`PodpowiedÅº: uÅ¼yj "!ranking {nr}" albo "!ranking me"`, player.id, infoColor, 'bold', HaxNotification.CHAT);
          } catch(_){}
          return false;
        }
        const totalPages = Math.max(1, Math.ceil(total / PAGE_SIZE));

        let page = 1;
        if (parts.length >= 2){
          const arg = parts[1].toLowerCase();
          if (arg === "me"){
            const auth = getAuthIdByPlayer(player);
            const idx = items.findIndex(([aid,_r])=> aid===auth);
            page = (idx < 0) ? 1 : Math.floor(idx / PAGE_SIZE) + 1;
          } else {
            const num = parseInt(arg, 10);
            if (!isNaN(num) && num >= 1) page = num;
          }
        }
        if (page > totalPages) page = totalPages;

        const startIdx = (page - 1) * PAGE_SIZE;
        const endIdx = Math.min(total, startIdx + PAGE_SIZE);
        const slice = items.slice(startIdx, endIdx);

        // Header
        try {
          room.sendAnnouncement(`ðŸ“Š Ranking â€” strona ${page}/${totalPages} (pozycje ${startIdx+1}â€“${endIdx} z ${total})`, player.id, infoColor, 'bold', HaxNotification.CHAT);
        } catch(_){}

        for (let i=0; i<slice.length; i++){
          const [aid, r] = slice[i];
          const pos = startIdx + i + 1;
          const name = (elo.names && elo.names[aid]) ? elo.names[aid] : aid;
          const ratingRaw = Number(r);
          const rating = Number.isFinite(ratingRaw) ? ratingRaw : baseElo;
          const lab = classLabel(rating);
          const emoji = rankEmoji(lab);
          const line = `#${pos} ${emoji} ${name}: ${rating.toFixed(1)} ${lab ? `| ${lab}` : ""}`;
          const col = rankColor(lab);
          try { room.sendAnnouncement(line, player.id, col, 'bold', HaxNotification.CHAT); }
          catch(_){ try { room.sendAnnouncement(line, player.id); } catch(__) {} }
        }

        // Footer with hints + your position
        const auth = getAuthIdByPlayer(player);
        const idx = items.findIndex(([aid,_r])=> aid===auth);
        if (idx >= 0){
          const myRatingRaw = Number(elo.ratings[auth]);
          const myR = Number.isFinite(myRatingRaw) ? myRatingRaw : baseElo;
          const myLab = classLabel(myR);
          const myEmoji = rankEmoji(myLab);
          const myCol = rankColor(myLab);
          const meLine = `â€¢ Twoja pozycja: #${idx+1} â€” ${myEmoji} ${player.name} | ${myR.toFixed(1)} ${myLab ? `| ${myLab}` : ""}`;
          try { room.sendAnnouncement(meLine, player.id, myCol, 'bold', HaxNotification.CHAT); }
          catch(_){ try { room.sendAnnouncement(meLine, player.id); } catch(__) {} }
        } else {
          try { room.sendAnnouncement(`â€¢ Brak pozycji (brak gier)`, player.id, infoColor, 'bold', HaxNotification.CHAT); } catch(_){}
        }

        try {
          room.sendAnnouncement(`PodpowiedÅº: uÅ¼yj "!ranking {nr}" albo "!ranking me"`, player.id, infoColor, 'bold', HaxNotification.CHAT);
        } catch(_){}

        return false;
      }


        // ZAMIANA starego: if (lower.startsWith("!stats")) { ...tylko ELO... }
// NA:
if (
  lower === "!stats" || lower.startsWith("!stats ") ||
  lower === "!staty" || lower.startsWith("!staty ") ||
  lower === "!stat"  || lower.startsWith("!stat ")  ||
  lower === "!me"    || lower.startsWith("!me ")
){
  const parts = msg.trim().split(/\s+/);
  let target = player;
  if (parts.length >= 2){
    const name = parts.slice(1).join(" ").toLowerCase();
    const found = (room.getPlayerList && room.getPlayerList())?.find(
      p => (p.name || "").toLowerCase() === name
    );
    if (found) target = found;
  }
  try{
    const { line, col } = printUnifiedStatsLine(target);
    try {
      room.sendAnnouncement(line, player.id, col, 'bold', HaxNotification.CHAT);
    } catch(_) {
      room.sendAnnouncement(line, player.id);
    }
  }catch(e){
    try {
      room.sendAnnouncement("Nie udaÅ‚o siÄ™ wyÅ›wietliÄ‡ statystyk.", player.id, errorColor, 'bold', HaxNotification.CHAT);
    } catch(_) {
      try { room.sendAnnouncement("Nie udaÅ‚o siÄ™ wyÅ›wietliÄ‡ statystyk.", player.id); } catch(__) {}
    }
  }
  return false; // zjadamy komendÄ™, Å¼eby nie dublowaÄ‡ wyjÅ›cia
}


      // Detect user's AFK command; don't block original handling; schedule post-check
      if (lower === "!afk" || lower.startsWith("!afk ")){
        if (authBeforeChat && (originalTeamBeforeChat === Team.RED || originalTeamBeforeChat === Team.BLUE)){
          try {
            afkIntent[authBeforeChat] = { team: originalTeamBeforeChat, ts: Date.now() };
          } catch (_){}
        }
        setTimeout(function(){
          handleAfkTransition(authBeforeChat, originalTeamBeforeChat);
        }, 60);
      }
    }catch(_){}
    if (typeof prev_onPlayerChat === "function") return prev_onPlayerChat(player, message);
    return true;
  };

  

  // Expose selected helpers for code defined outside this IIFE.
  try {
    const setGlobalFn = (name, fn) => {
      if (typeof fn === "function" && typeof globalThis[name] !== "function") {
        globalThis[name] = fn;
      }
    };
    setGlobalFn("getAuthIdByPlayer", getAuthIdByPlayer);
    setGlobalFn("ensureProfile", ensureProfile);
    setGlobalFn("classLabel", classLabel);
    setGlobalFn("rankEmoji", rankEmoji);
    setGlobalFn("rankColor", rankColor);
    setGlobalFn("printUnifiedStatsLine", printUnifiedStatsLine);
    setGlobalFn("forceImmediateWalkover", forceImmediateWalkover);
    setGlobalFn("__eloResetCommand", handleResetCommand);
    setGlobalFn("__eloApplyAfkPenalty", function(authId, teamId, fallbackName, force){
      return attemptLeavePenalty(authId, teamId, "AFK", fallbackName, !!force);
    });
  } catch (_) {
    // Ignore export errors in non-browser runtimes.
  }
}
)();
/* === Command: !rangi â€” progi ELO, nazwy i emoji === */
function rangiCommand(player, message){
    try{
        var lines = [
            "Progi ELO i rangi:",
            "< 850 â€” GÃ³wienko ðŸ’©",
            "850â€“950 â€” Å»Ã³Å‚todziÃ³b ðŸ£",
            "951 â€” 1050 PoczÄ…tkujÄ…cy âšª",
            "1051â€“1199 â€” Gracz ðŸ¥‰",
            "1200â€“1299 â€” Kox ðŸ¥ˆ",
            "1300â€“1399 â€” Mistrz ðŸ¥‡",
            "1400â€“1550 â€” Legenda ðŸ‘‘",
            "> 1550 â€” NieÅ›miertelny ðŸ”¥"
        ];
        for (var i=0;i<lines.length;i++){
            room.sendAnnouncement(lines[i], player.id, infoColor, 'bold', HaxNotification.CHAT);
        }
    } catch(e){
        room.sendAnnouncement("Nie udaÅ‚o siÄ™ wyÅ›wietliÄ‡ tabeli rang.", player.id, errorColor, 'bold', HaxNotification.CHAT);
    }
}


// === Commands: !stats / !staty / !stat â€” unified ===
function unifiedStatsCommand(player, message){
  try{
    const parts = (message||"").trim().split(/\s+/);
    let target = player;
    if (parts.length>=2){
      const name = parts.slice(1).join(" ").toLowerCase();
      const found = room.getPlayerList().find(p => (p.name||"").toLowerCase() === name);
      if (found) target = found;
    }
    const {line, col} = printUnifiedStatsLine(target);
    room.sendAnnouncement(line, player.id, col, 'bold', HaxNotification.CHAT);
  }catch(e){
    try{ room.sendAnnouncement("Nie udaÅ‚o siÄ™ wyÅ›wietliÄ‡ statystyk.", player.id, errorColor, 'bold', HaxNotification.CHAT); }catch(_){}
  }
  return false;
}
/* ================= SYSTEM EKONOMII (MONETY + SKLEP CZASOWY) ================= */

const COIN_STORAGE_KEY = "__coinStore_v2"; 
const COIN_RATES = {
    WIN: 30,
    LOSS: 10,
    GOAL: 10,
    ASSIST: 5,
    CS: 15, 
    PLAYTIME_PER_MIN: 2
};
const MIN_BET = 100; // Minimalna stawka do gier losowych

// Baza danych
var coinStore = {
    balances: {}, 
    ownedColors: {}, 
    activeColor: {}, 
    inventory: {} 
};

// Åadowanie
function loadCoinStore() {
    try {
        var raw = localStorage.getItem(COIN_STORAGE_KEY);
        if (raw) {
            var data = JSON.parse(raw);
            if (data.balances) coinStore.balances = data.balances;
            
            // Migracja starego systemu (pojedynczy kolor) na nowy (lista)
            if (data.colors && !data.ownedColors) {
                coinStore.ownedColors = {};
                coinStore.activeColor = {};
            } else {
                if (data.ownedColors) coinStore.ownedColors = data.ownedColors;
                if (data.activeColor) coinStore.activeColor = data.activeColor;
            }
            
            if (data.inventory) coinStore.inventory = data.inventory;
        }
    } catch (e) {}
}
loadCoinStore();

function saveCoinStore() {
    // Przed zapisem czyÅ›cimy wygasÅ‚e kolory, Å¼eby nie Å›mieciÄ‡ w bazie
    cleanExpiredColors(); 
    localStorage.setItem(COIN_STORAGE_KEY, JSON.stringify(coinStore));
}

// Funkcja czyszczÄ…ca wygasÅ‚e kolory
function cleanExpiredColors() {
    var now = Date.now();
    for (var auth in coinStore.ownedColors) {
        if (coinStore.ownedColors[auth]) {
            coinStore.ownedColors[auth] = coinStore.ownedColors[auth].filter(c => c.expires > now);
            
            // JeÅ›li aktywny kolor wygasÅ‚, usuÅ„ go z aktywnych
            if (coinStore.activeColor[auth]) {
                var stillHasIt = coinStore.ownedColors[auth].find(c => c.value === coinStore.activeColor[auth]);
                if (!stillHasIt) delete coinStore.activeColor[auth];
            }
        }
    }
}

function getCoins(player) {
    var auth = getPlayerAuth(player); // Zmiana na bezpieczniejszÄ… funkcjÄ™
    if (!auth) return 0;
    return coinStore.balances[auth] || 0;
}

function addCoins(player, amount) {
    var auth = getPlayerAuth(player); // Zmiana na bezpieczniejszÄ… funkcjÄ™
    if (!auth) return;
    if (!coinStore.balances[auth]) coinStore.balances[auth] = 0;
    coinStore.balances[auth] += Math.floor(amount);
    saveCoinStore();
}

function removeCoins(player, amount) {
    var auth = getPlayerAuth(player); // Zmiana na bezpieczniejszÄ… funkcjÄ™
    if (!auth) return false;
    if ((coinStore.balances[auth] || 0) < amount) return false;
    coinStore.balances[auth] -= amount;
    saveCoinStore();
    return true;
}

// --- KOMENDY GRACZA ---

function balanceCommand(player, message) {
    var amount = getCoins(player);
    room.sendAnnouncement(`ðŸ’° Stan konta: ${amount} monet.`, player.id, 0xFFD700, 'bold', HaxNotification.CHAT);
}
function moneyLeaderboardCommand(player, message) {
    if (!coinStore.balances) {
        room.sendAnnouncement("Brak danych o monetach.", player.id, errorColor, 'bold', HaxNotification.CHAT);
        return;
    }

    // Konwersja na tablicÄ™ i sortowanie
    var entries = Object.entries(coinStore.balances);
    entries.sort((a, b) => b[1] - a[1]); // Sortuj malejÄ…co

    var top = entries.slice(0, 5); // Pobierz Top 5
    if (top.length === 0) {
        room.sendAnnouncement("Ranking bogaczy jest pusty.", player.id, infoColor, 'bold', HaxNotification.CHAT);
        return;
    }

    room.sendAnnouncement(`ðŸ’° TOP 5 NAJBOGATSZYCH GRACZY ðŸ’°`, player.id, 0xFFD700, 'bold', HaxNotification.CHAT);

    for (var i = 0; i < top.length; i++) {
        var auth = top[i][0];
        var amount = top[i][1];
        var name = "Nieznany"; 

        // PrÃ³ba pobrania nicku z bazy ELO (jeÅ›li dostÄ™pna)
        if (globalThis.eloStore && globalThis.eloStore.names && globalThis.eloStore.names[auth]) {
            name = globalThis.eloStore.names[auth];
        } else if (knownPlayersByAuth && knownPlayersByAuth[auth]) {
             name = knownPlayersByAuth[auth].name;
        }

        room.sendAnnouncement(`${i + 1}. ${name}: ${amount} monet`, player.id, 0x00FF00, 'small', HaxNotification.CHAT);
    }
}
function transferCommand(player, message) {
    var msgArray = message.split(/ +/);
    if (msgArray.length < 3) {
        room.sendAnnouncement(`ðŸ’¸ Przelew. UÅ¼ycie: !przelew #ID <kwota>`, player.id, infoColor, 'bold', HaxNotification.CHAT);
        return;
    }
    var targetId = parseInt(msgArray[1].replace('#', ''));
    var amount = parseInt(msgArray[2]);
    var target = room.getPlayer(targetId);
    
    if (!target || target.id == player.id || isNaN(amount) || amount <= 0) {
        room.sendAnnouncement(`BÅ‚Ä…d transakcji. SprawdÅº ID i kwotÄ™.`, player.id, errorColor, 'bold', HaxNotification.CHAT);
        return;
    }

    if (removeCoins(player, amount)) {
        addCoins(target, amount);
        room.sendAnnouncement(`ðŸ’¸ Przelano ${amount} monet do ${target.name}.`, player.id, successColor, 'bold', HaxNotification.CHAT);
        room.sendAnnouncement(`ðŸ’¸ OtrzymaÅ‚eÅ› ${amount} monet od ${player.name}.`, target.id, successColor, 'bold', HaxNotification.CHAT);
    } else {
        room.sendAnnouncement(`Brak wystarczajÄ…cych Å›rodkÃ³w!`, player.id, errorColor, 'bold', HaxNotification.CHAT);
    }
}

function rouletteCommand(player, message) {
    var msgArray = message.split(/ +/);
    if (msgArray.length < 2) {
        room.sendAnnouncement(`ðŸŽ° Ruletka (50/50). UÅ¼ycie: !ruletka <kwota> (min. ${MIN_BET})`, player.id, infoColor, 'bold', HaxNotification.CHAT);
        return;
    }
    
    var currentBalance = getCoins(player);
    var amount = 0;

    if (['all', 'max', 'wszystko'].includes(msgArray[1].toLowerCase())) amount = currentBalance;
    else amount = parseInt(msgArray[1]);

    if (isNaN(amount) || amount <= 0) return;

    if (amount < MIN_BET) {
        room.sendAnnouncement(`âŒ Minimalna stawka to ${MIN_BET} monet!`, player.id, errorColor, 'bold', HaxNotification.CHAT);
        return;
    }

    if (amount > currentBalance) {
        room.sendAnnouncement(`Nie masz tyle monet!`, player.id, errorColor, 'bold', HaxNotification.CHAT);
        return;
    }

    var win = Math.random() > 0.5;
    if (win) {
        addCoins(player, amount);
        room.sendAnnouncement(`ðŸŽ° WYGRANA! +${amount} monet!`, player.id, 0x00FF00, 'bold', HaxNotification.CHAT);
    } else {
        removeCoins(player, amount);
        room.sendAnnouncement(`ðŸŽ° PrzegraÅ‚eÅ› ${amount} monet...`, player.id, 0xFF0000, 'bold', HaxNotification.CHAT);
    }
}

function numberGameCommand(player, message) {
    var msgArray = message.split(/ +/);
    // Oczekujemy: !liczba <twoja_liczba> <stawka>
    if (msgArray.length < 3) {
        room.sendAnnouncement(`ðŸŽ² Zgadnij liczbÄ™ (1-10). Wygrana x10!`, player.id, infoColor, 'bold', HaxNotification.CHAT);
        room.sendAnnouncement(`UÅ¼ycie: !liczba <1-10> <stawka> (min. ${MIN_BET})`, player.id, infoColor, 'small', HaxNotification.CHAT);
        return;
    }

    var pick = parseInt(msgArray[1]);
    var amount = 0;
    var balance = getCoins(player);

    // ObsÅ‚uga stawki (all/kwota)
    if (['all', 'max', 'wszystko', 'vabanque'].includes(msgArray[2].toLowerCase())) {
        amount = balance;
    } else {
        amount = parseInt(msgArray[2]);
    }

    // Walidacja
    if (isNaN(pick) || pick < 1 || pick > 10) {
        room.sendAnnouncement(`âŒ Wybierz liczbÄ™ z zakresu 1-10.`, player.id, errorColor, 'bold', HaxNotification.CHAT);
        return;
    }
    if (isNaN(amount) || amount <= 0) {
        room.sendAnnouncement(`âŒ Podaj poprawnÄ… stawkÄ™.`, player.id, errorColor, 'bold', HaxNotification.CHAT);
        return;
    }
    if (amount < MIN_BET) {
        room.sendAnnouncement(`âŒ Minimalna stawka to ${MIN_BET} monet!`, player.id, errorColor, 'bold', HaxNotification.CHAT);
        return;
    }
    if (amount > balance) {
        room.sendAnnouncement(`âŒ Nie masz tyle siana! Masz: ${balance}`, player.id, errorColor, 'bold', HaxNotification.CHAT);
        return;
    }

    // Pobranie kasy
    removeCoins(player, amount);

    // Losowanie
    var draw = Math.floor(Math.random() * 10) + 1; // 1 do 10

    // Efekt wizualny na czacie
    if (draw === pick) {
        var winAmount = amount * 10;
        addCoins(player, winAmount);
        room.sendAnnouncement(`ðŸŽ² [GRA 1-10] Obstawiono: ${pick} | Wylosowano: ðŸŸ¢ ${draw} ðŸŸ¢`, null, successColor, 'bold', HaxNotification.CHAT);
        room.sendAnnouncement(`ðŸŽ‰ ${player.name} TRAFIA JACKPOTA! Wygrywa ${winAmount} monet!`, null, 0xFFD700, 'bold', HaxNotification.CHAT);
    } else {
        room.sendAnnouncement(`ðŸŽ² [GRA 1-10] Obstawiono: ${pick} | Wylosowano: ðŸ”´ ${draw} ðŸ”´`, player.id, errorColor, 'bold', HaxNotification.CHAT);
        room.sendAnnouncement(`Niestety, tracisz ${amount} monet.`, player.id, infoColor, 'small', HaxNotification.CHAT);
    }
}

const SLOT_SYMBOLS = ['ðŸ’', 'ðŸ‹', 'ðŸ‡', 'ðŸŠ', 'ðŸ’Ž', '7ï¸âƒ£'];

function slotsCommand(player, message) {
    var msgArray = message.split(/ +/);
    if (msgArray.length < 2) {
        room.sendAnnouncement(`ðŸŽ° JednorÄ™ki Bandyta. UÅ¼ycie: !slots <stawka> (min. ${MIN_BET})`, player.id, infoColor, 'bold', HaxNotification.CHAT);
        return;
    }

    var amount = 0;
    var balance = getCoins(player);

    if (['all', 'max', 'wszystko'].includes(msgArray[1].toLowerCase())) amount = balance;
    else amount = parseInt(msgArray[1]);

    if (isNaN(amount) || amount <= 0) return;

    if (amount < MIN_BET) {
        room.sendAnnouncement(`âŒ Minimalna stawka to ${MIN_BET} monet!`, player.id, errorColor, 'bold', HaxNotification.CHAT);
        return;
    }

    if (amount > balance) {
        room.sendAnnouncement(`âŒ Brak Å›rodkÃ³w. Masz: ${balance}`, player.id, errorColor, 'bold', HaxNotification.CHAT);
        return;
    }

    removeCoins(player, amount);

    // Losowanie 3 bÄ™bnÃ³w
    var r1 = SLOT_SYMBOLS[Math.floor(Math.random() * SLOT_SYMBOLS.length)];
    var r2 = SLOT_SYMBOLS[Math.floor(Math.random() * SLOT_SYMBOLS.length)];
    var r3 = SLOT_SYMBOLS[Math.floor(Math.random() * SLOT_SYMBOLS.length)];

    // Budowanie wyglÄ…du
    var spinVisual = `ðŸŽ° | ${r1} | ${r2} | ${r3} | ðŸŽ°`;
    
    // Logika wygranych
    var multiplier = 0;
    var winMessage = "";

    // 3 SiÃ³demki (Jackpot)
    if (r1 === '7ï¸âƒ£' && r2 === '7ï¸âƒ£' && r3 === '7ï¸âƒ£') {
        multiplier = 50;
        winMessage = "JACKPOT!!! 50x!";
    }
    // 3 Diamenty
    else if (r1 === 'ðŸ’Ž' && r2 === 'ðŸ’Ž' && r3 === 'ðŸ’Ž') {
        multiplier = 30;
        winMessage = "DIAMENTY! 30x!";
    }
    // 3 Takie same (inne)
    else if (r1 === r2 && r2 === r3) {
        multiplier = 10;
        winMessage = "TRÃ“JKA! 10x!";
    }
    // 2 Takie same (para)
    else if (r1 === r2 || r2 === r3 || r1 === r3) {
        multiplier = 2;
        winMessage = "Para! 2x";
    }

    // WyÅ›wietlanie wyniku
    if (multiplier > 0) {
        var winAmount = amount * multiplier;
        addCoins(player, winAmount);
        // Kolorowy pasek dla wszystkich przy duÅ¼ej wygranej
        if (multiplier >= 10) {
            room.sendAnnouncement(spinVisual, null, 0xFFD700, 'bold', HaxNotification.CHAT);
            room.sendAnnouncement(`ðŸŽ‰ ${player.name} wygrywa ${winAmount} monet! (${winMessage})`, null, successColor, 'bold', HaxNotification.CHAT);
        } else {
            // Mniejsza wygrana tylko dla gracza
            room.sendAnnouncement(spinVisual, player.id, 0xFFFF00, 'bold', HaxNotification.CHAT);
            room.sendAnnouncement(`âœ… WygraÅ‚eÅ› ${winAmount} monet! (${winMessage})`, player.id, successColor, 'small', HaxNotification.CHAT);
        }
    } else {
        // Przegrana
        room.sendAnnouncement(spinVisual, player.id, errorColor, 'bold', HaxNotification.CHAT);
        room.sendAnnouncement(`âŒ SprÃ³buj szczÄ™Å›cia ponownie...`, player.id, infoColor, 'small', HaxNotification.CHAT);
    }
}

// --- SKLEP ---

const SHOP_ITEMS = {
    'zloty': { name: 'Kolor ZÅ‚oty (7 dni)', cost: 10000, type: 'color', value: 0xFFD700 },
    'neon': { name: 'Kolor Neonowy (7 dni)', cost: 6000, type: 'color', value: 0x00FF00 },
    'roz': { name: 'Kolor RÃ³Å¼owy (7 dni)', cost: 6000, type: 'color', value: 0xFF69B4 },
    'czarny': { name: 'Kolor Czarny (7 dni)', cost: 20000, type: 'color', value: 0x000000 },
    'ucisz': { name: 'Ucisz gracza (5 min)', cost: 1000, type: 'action_mute' },
    'megafon': { name: 'Megafon (!shout)', cost: 400, type: 'action_shout' }
};

function shopCommand(player, message) {
    var msgArray = message.split(/ +/);
    
    // --- Nowe kolory do designu ---
    const GOLD = 0xFFD700;
    const PINK = 0xFF69B4;

    if (msgArray.length < 2) {
        // --- NAGÅÃ“WEK W RAMCE ASCII ---
        room.sendAnnouncement(`â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—`, player.id, GOLD, 'bold', HaxNotification.CHAT);
        room.sendAnnouncement(`â•‘          ðŸ›’ S K L E P ðŸ’°           â•‘`, player.id, GOLD, 'bold', HaxNotification.CHAT);
        room.sendAnnouncement(`â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•`, player.id, GOLD, 'bold', HaxNotification.CHAT);

        room.sendAnnouncement(`Twoje saldo: ${getCoins(player)} monet.`, player.id, GOLD, 'small', HaxNotification.CHAT);
        room.sendAnnouncement(`[KOD | NAZWA | CENA | WAÅ»NOÅšÄ†]`, player.id, infoColor, 'small', HaxNotification.CHAT);
        
        for (var key in SHOP_ITEMS) {
            var item = SHOP_ITEMS[key];
            var itemLine = `ðŸ”¸ !sklep ${key} â€” ${item.name} (${item.cost} monet)`;
            room.sendAnnouncement(itemLine, player.id, PINK, 'small', HaxNotification.CHAT); // UÅ¼ywamy PINK dla wizualnego wyrÃ³Å¼nienia
        }
        
        room.sendAnnouncement(`(UÅ¼yj !sklep <kod> aby kupiÄ‡ | Mute wymaga #ID gracza)`, player.id, infoColor, 'small', HaxNotification.CHAT);
        return;
    }
    // --- KONIEC WYSWIETLANIA ---

    var itemKey = msgArray[1].toLowerCase();
    var item = SHOP_ITEMS[itemKey];

    if (!item) {
        room.sendAnnouncement(`Nieznany przedmiot.`, player.id, errorColor, 'bold', HaxNotification.CHAT);
        return;
    }

    if (item.type === 'color') {
        if (removeCoins(player, item.cost)) {
            var auth = getAuthIdByPlayer(player);
            var now = Date.now();
            var durationMs = 7 * 24 * 60 * 60 * 1000; // 7 dni

            if (!coinStore.ownedColors[auth]) coinStore.ownedColors[auth] = [];

            var existingItem = coinStore.ownedColors[auth].find(c => c.id === itemKey);

            if (existingItem) {
                if (existingItem.expires > now) {
                    existingItem.expires += durationMs;
                } else {
                    existingItem.expires = now + durationMs;
                }
                room.sendAnnouncement(`ðŸ›’ PrzedÅ‚uÅ¼ono waÅ¼noÅ›Ä‡ koloru ${item.name} o 7 dni!`, player.id, successColor, 'bold', HaxNotification.CHAT);
            } else {
                coinStore.ownedColors[auth].push({
                    id: itemKey,
                    name: item.name,
                    value: item.value,
                    expires: now + durationMs
                });
                coinStore.activeColor[auth] = item.value;
                room.sendAnnouncement(`ðŸ›’ Kupiono ${item.name}! ZostaÅ‚ automatycznie wybrany.`, player.id, successColor, 'bold', HaxNotification.CHAT);
            }
            saveCoinStore();
        } else {
            room.sendAnnouncement(`Brakuje Ci ${item.cost - getCoins(player)} monet!`, player.id, errorColor, 'bold', HaxNotification.CHAT);
        }
    }
    else if (item.type === 'action_mute') {
        var targetId = parseInt(msgArray[2] ? msgArray[2].replace('#', '') : '0');
        var target = room.getPlayer(targetId);
        if (!target || target.admin || target.id == player.id) {
            room.sendAnnouncement(`BÅ‚Ä™dny cel uciszenia.`, player.id, errorColor, 'bold', HaxNotification.CHAT);
            return;
        }
        if (removeCoins(player, item.cost)) {
            if (typeof MutePlayer !== 'undefined') {
                 var muteAuth = getPlayerAuth(target);
                 var muteObj = new MutePlayer(target.name, target.id, muteAuth);
                 muteObj.setDuration(5);
                 room.sendAnnouncement(`ðŸ™Š ${target.name} zostaÅ‚ uciszony za monety przez ${player.name}!`, null, 0xFFFF00, 'bold', HaxNotification.CHAT);
            }
        } else {
            room.sendAnnouncement(`Za maÅ‚o monet!`, player.id, errorColor, 'bold', HaxNotification.CHAT);
        }
    }
    else if (item.type === 'action_shout') {
         var text = msgArray.slice(2).join(' ');
         if (text.length < 2) return;
         if (removeCoins(player, item.cost)) {
             room.sendAnnouncement(`ðŸ“¢ [MEGAFON] ${player.name}: ${text}`, null, 0xFF00FF, 'bold', HaxNotification.CHAT);
         } else {
            room.sendAnnouncement(`Za maÅ‚o monet!`, player.id, errorColor, 'bold', HaxNotification.CHAT);
         }
    }
}

/* --- ZARZÄ„DZANIE KOLORAMI --- */

function myColorsCommand(player, message) {
    var auth = getAuthIdByPlayer(player);
    var list = coinStore.ownedColors[auth] || [];
    var now = Date.now();

    // Filtrujemy wygasÅ‚e (tylko do wyÅ›wietlania)
    list = list.filter(c => c.expires > now);

    var activeVal = coinStore.activeColor[auth];
    // Sprawdzamy czy gracz uÅ¼ywa domyÅ›lnego (brak wpisu w activeColor)
    var isDefaultActive = (activeVal === undefined || activeVal === null);

    room.sendAnnouncement(`ðŸŽ¨ Twoje kolory (wpisz "!wybierz <numer>"):`, player.id, announcementColor, 'bold', HaxNotification.CHAT);
    
    // --- ZMIANA: Dodano opcjÄ™ 0 na szczycie listy ---
    var statusDefault = isDefaultActive ? " [AKTYWNY] âœ…" : "";
    room.sendAnnouncement(`0. DomyÅ›lny (Red/Blue)${statusDefault}`, player.id, infoColor, 'small', HaxNotification.CHAT);

    if (list.length === 0) {
        room.sendAnnouncement(`(Brak kupionych kolorÃ³w specjalnych)`, player.id, infoColor, 'small', HaxNotification.CHAT);
        return;
    }

    for (var i = 0; i < list.length; i++) {
        var c = list[i];
        var daysLeft = ((c.expires - now) / (24 * 60 * 60 * 1000)).toFixed(1);
        var status = (activeVal === c.value) ? " [AKTYWNY] âœ…" : "";
        
        room.sendAnnouncement(`${i + 1}. ${c.name} (pozostaÅ‚o: ${daysLeft} dni)${status}`, player.id, c.value, 'bold', HaxNotification.CHAT);
    }
}
function equipColorCommand(player, message) {
    var msgArray = message.split(/ +/);
    
    // Informacja o uÅ¼yciu
    if (msgArray.length < 2) {
        room.sendAnnouncement(`UÅ¼ycie: !wybierz <numer> (lub !wybierz reset)`, player.id, errorColor, 'bold', HaxNotification.CHAT);
        return;
    }

    var arg = msgArray[1].toLowerCase();
    var auth = getAuthIdByPlayer(player);

    // 1. Opcja RESETU (Przywracanie domyÅ›lnego)
    if (['reset', 'off', 'default', '0', 'brak', 'usun'].includes(arg)) {
        if (coinStore.activeColor && coinStore.activeColor[auth]) {
            delete coinStore.activeColor[auth];
            saveCoinStore();
            room.sendAnnouncement(`ðŸŽ¨ PrzywrÃ³cono domyÅ›lny kolor druÅ¼yny (Red/Blue)!`, player.id, successColor, 'bold', HaxNotification.CHAT);
        } else {
            room.sendAnnouncement(`ðŸŽ¨ JuÅ¼ uÅ¼ywasz domyÅ›lnego koloru.`, player.id, infoColor, 'small', HaxNotification.CHAT);
        }
        return;
    }

    // 2. Standardowe wybieranie numerem z listy
    var index = parseInt(arg) - 1;
    var list = coinStore.ownedColors[auth] || [];
    var now = Date.now();

    // Upewniamy siÄ™, Å¼e lista jest aktualna (filtrujemy wygasÅ‚e)
    list = list.filter(c => c.expires > now);

    if (index >= 0 && index < list.length) {
        var selected = list[index];
        coinStore.activeColor[auth] = selected.value;
        saveCoinStore();
        room.sendAnnouncement(`ðŸŽ¨ UstawiÅ‚eÅ› kolor: ${selected.name}! Napisz coÅ› na czacie.`, player.id, selected.value, 'bold', HaxNotification.CHAT);
    } else {
        room.sendAnnouncement(`âŒ NieprawidÅ‚owy numer. SprawdÅº "!kolory" lub wpisz "!wybierz reset".`, player.id, errorColor, 'bold', HaxNotification.CHAT);
    }
}
// --- KOMENDY ADMINA (MONETY I KOLORY) ---

function adminCoinCommand(player, message) {
    if (!debugMode && getRole(player) < Role.MASTER) return;

    var msgArray = message.split(/ +/);
    var cmd = msgArray[0].toLowerCase();
    var isAdd = (cmd.includes('add') || cmd.includes('give'));

    if (msgArray.length < 3) {
        room.sendAnnouncement(`UÅ¼ycie: ${cmd} #ID/@Auth <kwota>`, player.id, infoColor, 'bold', HaxNotification.CHAT);
        return;
    }

    var targetInput = msgArray[1];
    var amount = parseInt(msgArray[2]);
    if (isNaN(amount)) return;

    var targetAuth = null;
    var targetName = "Gracz";

    if (targetInput.startsWith("#")) {
        var id = parseInt(targetInput.replace('#', ''));
        var p = room.getPlayer(id);
        if (p) { targetAuth = getAuthIdByPlayer(p); targetName = p.name; }
    } else if (targetInput.startsWith("@") || targetInput.length > 5) {
        targetAuth = targetInput.replace('@', '');
        if (globalThis.eloStore && globalThis.eloStore.names[targetAuth]) targetName = globalThis.eloStore.names[targetAuth];
        else targetName = "Offline";
    }

    if (!targetAuth) {
        room.sendAnnouncement(`Nie znaleziono celu.`, player.id, errorColor, 'bold', HaxNotification.CHAT);
        return;
    }

    if (!coinStore.balances[targetAuth]) coinStore.balances[targetAuth] = 0;

    if (isAdd) {
        coinStore.balances[targetAuth] += amount;
        room.sendAnnouncement(`ðŸ’° Dodano ${amount} monet dla ${targetName}.`, player.id, successColor, 'bold', HaxNotification.CHAT);
    } else {
        if (coinStore.balances[targetAuth] < amount) coinStore.balances[targetAuth] = 0;
        else coinStore.balances[targetAuth] -= amount;
        room.sendAnnouncement(`ðŸ’¸ Zabrano ${amount} monet graczowi ${targetName}.`, player.id, warningColor, 'bold', HaxNotification.CHAT);
    }
    saveCoinStore();
}

function adminSetColorCommand(player, message) {
    if (getRole(player) < Role.MASTER) return;

    var msgArray = message.split(/ +/);
    if (msgArray.length < 4) {
        room.sendAnnouncement(`UÅ¼ycie: !setcolor #ID <Hex/Nazwa> <Dni>`, player.id, infoColor, 'bold', HaxNotification.CHAT);
        return;
    }

    var targetInput = msgArray[1];
    var colorInput = msgArray[2];
    var days = parseInt(msgArray[3]);

    var targetAuth = null;
    var targetName = "Gracz";

    if (targetInput.startsWith("#")) {
        var id = parseInt(targetInput.replace('#', ''));
        var p = room.getPlayer(id);
        if (p) { targetAuth = getAuthIdByPlayer(p); targetName = p.name; }
    } else {
        targetAuth = targetInput.replace('@', '');
    }

    if (!targetAuth) return;

    var colorValue = 0;
    var colorName = "Unikalny Kolor";
    var colorId = "custom_" + Date.now();

    // Czy to kolor ze sklepu?
    if (SHOP_ITEMS[colorInput.toLowerCase()]) {
        var shopItem = SHOP_ITEMS[colorInput.toLowerCase()];
        colorValue = shopItem.value;
        colorName = shopItem.name;
        colorId = colorInput.toLowerCase();
    } 
    else {
        var cleanHex = colorInput.replace('#', '');
        if (/^[0-9A-Fa-f]{6}$/.test(cleanHex)) {
            colorValue = parseInt(cleanHex, 16);
            colorName = "Specjalny Kolor Admina";
        } else { 
            room.sendAnnouncement(`ZÅ‚y kolor.`, player.id, errorColor, 'bold', HaxNotification.CHAT); return; 
        }
    }

    if (!coinStore.ownedColors[targetAuth]) coinStore.ownedColors[targetAuth] = [];
    
    var now = Date.now();
    var durationMs = days * 24 * 60 * 60 * 1000;
    
    // SprawdÅº czy ma juÅ¼ ten kolor
    var existing = coinStore.ownedColors[targetAuth].find(c => c.value === colorValue);
    
    if (existing) {
        if (existing.expires > now) existing.expires += durationMs;
        else existing.expires = now + durationMs;
    } else {
        coinStore.ownedColors[targetAuth].push({
            id: colorId,
            name: colorName,
            value: colorValue,
            expires: now + durationMs
        });
    }
    
    // Ustaw jako aktywny
    coinStore.activeColor[targetAuth] = colorValue;
    saveCoinStore();

    room.sendAnnouncement(`ðŸŽ¨ Nadano kolor dla ${targetName} na ${days} dni!`, player.id, successColor, 'bold', HaxNotification.CHAT);
}

function adminRemoveColorCommand(player, message) {
    if (getRole(player) < Role.MASTER) return;
    var msgArray = message.split(/ +/);
    var targetInput = msgArray[1];
    var targetAuth = null;

    if (targetInput.startsWith("#")) {
        var id = parseInt(targetInput.replace('#', ''));
        var p = room.getPlayer(id);
        if (p) targetAuth = getAuthIdByPlayer(p);
    } else {
        targetAuth = targetInput.replace('@', '');
    }

    if (targetAuth) {
        // CzyÅ›cimy aktywny kolor
        if (coinStore.activeColor[targetAuth]) {
            delete coinStore.activeColor[targetAuth];
        }
        // CzyÅ›cimy ekwipunek (opcjonalnie, jeÅ›li chcesz zabraÄ‡ mu wszystko)
        if (coinStore.ownedColors[targetAuth]) {
            coinStore.ownedColors[targetAuth] = [];
        }
        
        saveCoinStore();
        room.sendAnnouncement(`ðŸ—‘ï¸ UsuniÄ™to kolory gracza (wyczyszczono ekwipunek).`, player.id, successColor, 'bold', HaxNotification.CHAT);
    } else {
        room.sendAnnouncement(`âŒ Nie znaleziono gracza/autha.`, player.id, errorColor, 'bold', HaxNotification.CHAT);
    }
}

/* ================= SYSTEM CYKLICZNYCH OGÅOSZEÅƒ (Z BOGACZAMI) ================= */

const QUOTES = [
    { text: "SzaleÅ„stwo: robiÄ‡ wciÄ…Å¼ to samo i oczekiwaÄ‡ rÃ³Å¼nych rezultatÃ³w.", author: "A. Einstein" },
    { text: "Najbardziej niezrozumiaÅ‚e w Å›wiecie jest to, Å¼e jest on zrozumiaÅ‚y.", author: "A. Einstein" },
    { text: "Wszystko jest energiÄ…. I to wszystko.", author: "Anonimowy Fizyk" },
    { text: "Nie martw siÄ™ trudnoÅ›ciami w matematyce. Zapewniam ciÄ™, Å¼e moje sÄ… jeszcze wiÄ™ksze.", author: "A. Einstein" },
    { text: "Jedynym sposobem na to, by uniknÄ…Ä‡ demoralizujÄ…cego skutku bycia chwalonym jest kontynuowanie pracy.", author: "A. Einstein" },
    { text: "Nie moÅ¼na jednoczeÅ›nie przygotowywaÄ‡ siÄ™ do wojny i oczekiwaÄ‡ pokoju.", author: "A. Einstein" }
];

const ECO_MESSAGES = [
    "â„¹ï¸ NOWOÅšCI: SprawdÅº portfel (!kasa) | Kup kolory na 7 dni (!sklep) | Graj w ruletkÄ™ (!ruletka, !liczba)!",
    "ðŸ’° Chcesz siÄ™ wyrÃ³Å¼niÄ‡? Wpisz !sklep i kup unikalny ZÅOTY lub NEONOWY kolor!",
    "ðŸŽ° Masz Å¼yÅ‚kÄ™ hazardzisty? Wpisz !ruletka 100 i pomnÃ³Å¼ swÃ³j majÄ…tek!",
    "ðŸ’¸ Graj mecze, strzelaj bramki i asystuj - za kaÅ¼dÄ… dobrÄ… akcjÄ™ dostajesz monety!",
    "ðŸŽ² SprÃ³buj szczÄ™Å›cia w grze liczbowej! Wpisz !liczba <1-10> <stawka>. Wygrana 10x!",
    "ðŸ‘€ SprawdÅº kto rzÄ…dzi na dzielni! Wpisz !bogacze aby zobaczyÄ‡ ranking kasy."
];

const TECH_MESSAGES = [
    "ðŸ› ï¸ AKTUALIZACJA: System wybierania zostaÅ‚ zmieniony. Wybierz najlepszych na roomie dziÄ™ki \"best\", oraz wybieraj po nicku! .",
    "âš™ï¸ UPDATE: System ELO zostaÅ‚ zoptymalizowany. Walka o ranking jest teraz sprawiedliwa!",
    "ðŸ”§ INFO: Wprowadzono nowy system auto-restartu meczÃ³w 3v3.",
    "ðŸ›¡ï¸ ZABEZPIECZENIA: System anty-AFK czuwa."
];

const SEASON_MESSAGES = [
    "ðŸ† SEZON FUTSAL #1 ROZPOCZÄ˜TY! Wbijaj ELO i walcz o rangÄ™ NieÅ›miertelny!",
    "âš½ Ranking ELO jest aktywny! KaÅ¼dy mecz siÄ™ liczy.",
    "ðŸ‘‘ Czy wiesz, Å¼e za bycie w TOP 3 rankingu przewidziane sÄ… unikalne nagrody? Walcz do koÅ„ca!"
];

const ANNOUNCEMENT_INTERVAL_MS = 5 * 60 * 1000; 

function sendRecurringAnnouncement() {
    if (room.getPlayerList().length <= 0) {
        return;
    }

    // Losujemy kategoriÄ™ (0=Sezon, 1=Eko, 2=Cytat, 3=Tech, 4=BOGACZE)
    const type = Math.floor(Math.random() * 5);

    switch (type) {
        case 0: // SEZON
            const seasonMsg = SEASON_MESSAGES[Math.floor(Math.random() * SEASON_MESSAGES.length)];
            room.sendAnnouncement(seasonMsg, null, 0xFFD700, 'bold', HaxNotification.CHAT);
            break;

        case 1: // EKONOMIA
            const ecoMsg = ECO_MESSAGES[Math.floor(Math.random() * ECO_MESSAGES.length)];
            room.sendAnnouncement(ecoMsg, null, 0x00FF00, 'small', HaxNotification.CHAT);
            break;

        case 2: // CYTATY
            const randomQuote = QUOTES[Math.floor(Math.random() * QUOTES.length)];
            const quoteText = `ðŸ§  CYTAT: "${randomQuote.text}" â€” ${randomQuote.author}`;
            room.sendAnnouncement(quoteText, null, 0xAAAAFF, 'small', HaxNotification.CHAT);
            break;

        case 3: // TECHNICZNE
            const techMsg = TECH_MESSAGES[Math.floor(Math.random() * TECH_MESSAGES.length)];
            room.sendAnnouncement(techMsg, null, 0x75FF75, 'small', HaxNotification.CHAT);
            break;

        case 4: // TOP BOGACZE (NOWOÅšÄ†)
            if (coinStore && coinStore.balances) {
                var entries = Object.entries(coinStore.balances).sort((a, b) => b[1] - a[1]).slice(0, 3);
                if (entries.length > 0) {
                    var richList = entries.map((e, i) => {
                        var n = (globalThis.eloStore && globalThis.eloStore.names && globalThis.eloStore.names[e[0]]) 
                                ? globalThis.eloStore.names[e[0]] 
                                : "Gracz";
                        return `${i+1}. ${n} (${e[1]} ðŸ’°)`;
                    }).join("  |  ");
                    room.sendAnnouncement(`ðŸ¦ NAJBOGATSI NA ROOMIE:`, null, 0xFFD700, 'bold', HaxNotification.CHAT);
                    room.sendAnnouncement(richList, null, 0xFFFFFF, 'small', HaxNotification.CHAT);
                } else {
                    // Fallback jeÅ›li pusto
                    room.sendAnnouncement("ðŸ’° Zbieraj monety grajÄ…c mecze! Wpisz !sklep aby je wydaÄ‡.", null, 0x00FF00, 'small', HaxNotification.CHAT);
                }
            }
            break;
    }
}

setInterval(sendRecurringAnnouncement, ANNOUNCEMENT_INTERVAL_MS);
/* --- OBSÅUGA BANÃ“W ELO --- */

function getEloBansList() {
    var list = [];
    // Przeszukujemy wszystkie aktywne bany czasowe
    timedBanTasks.forEach(function(record) {
        // Szukamy tych nadanych przez "System ELO" lub z powodem "Spadek"
        if (record.adminName === "ðŸ“‰ System ELO" || (record.reason && record.reason.includes("Spadek"))) {
            list.push(record);
        }
    });
    return list;
}

function eloBansCommand(player, message) {
    // DostÄ™pne dla AdminÃ³w (Å¼eby mogli sprawdziÄ‡ kto poleciaÅ‚)
    if (getRole(player) < Role.ADMIN_TEMP) return;

    var list = getEloBansList();
    
    if (list.length === 0) {
        room.sendAnnouncement("ðŸŸ¢ Czysto! Brak aktywnych banÃ³w za ELO.", player.id, successColor, 'bold', HaxNotification.CHAT);
        return;
    }

    room.sendAnnouncement(`ðŸ“‰ Aktywne bany za ELO (${list.length}):`, player.id, errorColor, 'bold', HaxNotification.CHAT);
    
    for (var i = 0; i < list.length; i++) {
        var rec = list[i];
        var rem = formatBanRemaining(rec); // Funkcja z Twojego skryptu
        // WyÅ›wietlamy: 1. Nick [czas]
        room.sendAnnouncement(`${i + 1}. ${rec.name} [pozostaÅ‚o: ${rem}]`, player.id, infoColor, 'small', HaxNotification.CHAT);
    }
    
    if (getRole(player) >= Role.MASTER) {
        room.sendAnnouncement(`Wpisz "!unbanelo <numer>" aby anulowaÄ‡ karÄ™, lub "!unbanelo all" by usunÄ…Ä‡ wszystkie.`, player.id, infoColor, 'small', HaxNotification.CHAT);
    }
}

function unbanEloCommand(player, message) {
    // Tylko Master moÅ¼e zdejmowaÄ‡ bany
    if (getRole(player) < Role.MASTER) {
        room.sendAnnouncement("â›” Tylko Master Admin moÅ¼e zdejmowaÄ‡ bany ELO.", player.id, errorColor, 'bold', HaxNotification.CHAT);
        return;
    }

    var msgArray = message.split(/ +/);
    if (msgArray.length < 2) {
        room.sendAnnouncement(`UÅ¼ycie: !unbanelo <numer_z_listy> lub !unbanelo all`, player.id, warningColor, 'bold', HaxNotification.CHAT);
        return;
    }
    
    var arg = msgArray[1].toLowerCase();
    var list = getEloBansList();

    // Opcja ALL - czyÅ›ci wszystko
    if (arg === 'all' || arg === 'wszystkie') {
        var count = list.length;
        if (count === 0) {
            room.sendAnnouncement("Nie ma czego usuwaÄ‡.", player.id, infoColor, 'bold', HaxNotification.CHAT);
            return;
        }
        for (var rec of list) {
            clearTimedBan(rec.key, { notify: false }); // Usuwamy bez spamu powiadomieniami
        }
        room.sendAnnouncement(`ðŸ—‘ï¸ Amnestia! UsuniÄ™to wszystkie bany za ELO (${count}).`, null, successColor, 'bold', HaxNotification.CHAT);
        return;
    }

    // Opcja Numer - usuwa konkretnego
    var index = parseInt(arg) - 1; // -1 bo lista jest od 1, a tablica od 0
    
    if (isNaN(index) || index < 0 || index >= list.length) {
        room.sendAnnouncement(`âŒ NieprawidÅ‚owy numer. SprawdÅº listÄ™ wpisujÄ…c !elobans`, player.id, errorColor, 'bold', HaxNotification.CHAT);
        return;
    }

    var targetRec = list[index];
    clearTimedBan(targetRec.key); // Zdejmuje bana i czyÅ›ci wpis
    
    room.sendAnnouncement(`âœ… ZdjÄ™to karÄ™ ELO dla gracza ${targetRec.name}.`, null, successColor, 'bold', HaxNotification.CHAT);
}
/* --- SYSTEM ZAPISU BEZ LAGÃ“W --- */

function performDiskSave() {
    // 1. Zapis Monet (jeÅ›li byÅ‚y zmiany)
    if (typeof coinStoreDirty !== 'undefined' && coinStoreDirty) {
        cleanExpiredColors(); // Przy okazji czyÅ›cimy wygasÅ‚e kolory
        try {
            localStorage.setItem(COIN_STORAGE_KEY, JSON.stringify(coinStore));
            coinStoreDirty = false;
            // if(debugMode) console.log("ðŸ’¾ Zapisano monety.");
        } catch(e) {}
    }
    
    // 2. Zapis ELO (jeÅ›li byÅ‚y zmiany)
    if (typeof globalThis.eloStoreDirty !== 'undefined' && globalThis.eloStoreDirty && typeof globalThis.eloStore !== 'undefined') {
        try {
            const payload = {
                ratings: globalThis.eloStore.ratings,
                games: globalThis.eloStore.games,
                names: globalThis.eloStore.names,
                resets: globalThis.eloStore.resets
            };
            localStorage.setItem("__eloStore", JSON.stringify(payload));
            globalThis.eloStoreDirty = false;
            // if(debugMode) console.log("ðŸ’¾ Zapisano ELO.");
        } catch(e) {}
    }
}

// Zapisuj dane co 10 minut (backup) oraz przy waÅ¼nych wydarzeniach
setInterval(performDiskSave, 10 * 60 * 1000);
/* --- SYSTEM KOLEJKOWANIA LOGÃ“W DISCORDA (ANTY-LAG) --- */

var chatLogBuffer = []; // Tu zbieramy wiadomoÅ›ci
const CHAT_BUFFER_SEND_INTERVAL = 5000; // WysyÅ‚aj co 5 sekund

function flushChatLogs() {
    if (chatLogBuffer.length === 0) return;
    if (roomWebhook == '') {
        chatLogBuffer = []; // JeÅ›li nie ma webhooka, czyÅ›cimy bufor
        return;
    }

    // ÅÄ…czymy wiadomoÅ›ci w jednÄ… duÅ¼Ä… paczkÄ™
    // Discord przyjmuje max 2000 znakÃ³w, wiÄ™c w razie czego dzielimy
    var payload = chatLogBuffer.join("\n");
    chatLogBuffer = []; // CzyÅ›cimy bufor natychmiast

    // WysyÅ‚amy jednÄ… duÅ¼Ä… wiadomoÅ›Ä‡ zamiast dziesiÄ™ciu maÅ‚ych
    safeFetch(roomWebhook, {
        method: 'POST',
        body: JSON.stringify({
            content: payload,
            username: roomName,
        }),
        headers: { 'Content-Type': 'application/json' },
    });
}

// Uruchamiamy wysyÅ‚anie logÃ³w co 5 sekund
setInterval(flushChatLogs, CHAT_BUFFER_SEND_INTERVAL);
